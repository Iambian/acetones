;PPU-related stuff is written here, though not all of it is localized in
;this file. Some of it will necessarily be located with the mapper code
;that handles PPU I/O.

; NOTES ON SPRITE 0 HIT IS LOCATED IN MAIN.Z80, AROUND THE CODE WHERE
; MAPPER 0 READ HANDLER HANDLES READING PPU_STATUS.


;
; Scratchpadding some stuff
;


;Note: Can't figure out how to keep DE as the pointer to the nametable.
;Perhaps consider keeping nametable stuff inside the shadow registers?
;
;



;
; You may want to investigate macros to duplicate this bit of code but with
; labels changed around based on a single input. This stretch of code is
; going to be re-used a lot, and calling is out of the question, since the
; stack is unavailable at the time these would be called. At least, not without
; a painful amount of SP retrieval and storage.
;

ppu_left:
;PPU_XSCROLL_FINE, PPU_YSCROLL_FINE
    ld  a,(ix+PPU_XSCROLL_FINE)
    ld  a,(de)
    exx
    ;SP is presumed to have been rewound to the scanline at the top of the
    ;sprite and on the left edge of the screen.
ppu_left_bufinit .equ $+1
    ld  hl,0
    add hl,sp
    ex  de,hl
    ld  c,a
    ld  b,64
    mlt bc
ppu_left_smc_sprinit .equ $+1
    ld  hl,0
    add hl,bc
ppu_left_smc_drawheight .equ $+1
    ld  a,8
ppu_left_smc_copylen .equ $+1
    jr  $
    ldi \ ldi \ ldi \ ldi \ ldi \ ldi \ ldi \ ldi
ppu_left_smc_sprskip .equ $+1
    ld  bc,0
    add hl,bc
    ex  de,hl
ppu_left_smc_bufskip .equ $+1
    ld  c,0
    add hl,bc
    ex  de,hl
    dec a
    jr  nz,ppu_left_smc_copylen-1
ppu_left_smc_bufreset .equ $+1
    ld  hl,-1
    add hl,de
    ld  sp,hl
    exx


















ppu_cache_bank: ;HL=dest, DE=sauce
    push de
    pop iy
    ld  c,0
_:  ld  b,8
_:  ld  e,(iy+0)
    ld  d,(iy+8)
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    inc iy
    djnz -_
    lea iy,iy+8
    dec c
    jr  nz,--_
    ret


ppu_drawFrameSuper:
    ;===================================================================
    ;THIS WHOLE CACHEING THING NEEDS TO BE DOINE IN THE MAPPER INSTEAD 
    ;OF HERE. THE MAPPER IS WHAT CONTROLS WHAT CHR_ROM GETS BANKED WHERE
    ;jr $
    ld  de,(chr_rom_base)
    ld  hl,(chr_rom_cachefrom_A)
    or  a,a
    sbc hl,de   ;Check if current bank matches cached location
    push de
        ld  (chr_rom_cachefrom_A),de
        ld  hl,chr_rom_1_cache
        call nz,ppu_cache_bank
    pop de
    ld  hl,256*16   ;THIS PART ACTUALLY HAS TO BE HANDLED BY THE MAPPER.
    add hl,de       ;SOME MAPPERS ARE CAPABLE OF BANK SPLITTING.
    ex  de,hl
    ld  hl,(chr_rom_cachefrom_B)
    or  a,a
    sbc hl,de
    ld  (chr_rom_cachefrom_B),de
    ld  hl,chr_rom_2_cache
    call nz,ppu_cache_bank
    ;===================================================================
    ;set primecell palette from PPU VRAM palette data
    ld  hl,paletteData      ;actual colors
    ld  de,mpLcdPalette     ;where colors go
    ld  bc,vram_palette     ;indices found here
    ld  a,(bc)
    ld  (++_+1),a
_:  ld  a,c
    and a,3
    ld  a,(bc)
    jr  nz,+_+2
_:  ld  a,0
    push hl
        push bc
            ld  c,2
            ld  b,a
            mlt bc
            add hl,bc
            ldi
            ldi
        pop bc
    pop hl
    inc bc
    ld  a,c
    cp  a,32
    jr  nz,--_
    ;set base rom addresses
    ld  hl,chr_rom_1_cache
    ld  de,chr_rom_2_cache
    push hl \ push de
    ld  a,(ix+PPU_CTRL)
    bit 4,a     ;background pattern base offset
    jr  z,$+3
    ex  de,hl
    ld  (chr_rom_tiles),hl
    ld  (ppu_midHorizLoop_cachesmc),hl
    pop de \ pop hl
    bit 5,a     ;sprite pattern base offset
    jr  z,$+3
    ex de,hl
    ld  (chr_rom_sprites),hl
    ;set coarse x,y scroll positions. B=Y, C=x.
    ;Note: Pre-incrementing Y to simulate first row skip
    ld  bc,(ix+PPU_XSCROLL)
    ld  a,b
    rra
    rra
    rra
    and a,%00011111
    inc a
    cp  a,$30
    jr  c,$+3
    xor a,a
    ld  b,a
    sra c
    sra c
    sra c
    ld  (ix+PPU_XSCROLL_ROUGH),c
    ;set base nametable addresses
    ld  hl,nametable00
    ld  a,(ix+PPU_CTRL)
    and a,3
    add a,a
    add a,a
    ld  L,a
    ld  (ix+PPU_NAMETABLE_PTR),hl   ;maybe this time we'll need it?
    ;In-place setting of nametable address wrt X,Y
    ;%------YY YYYXXXXX
    ld  de,(hl)
    ld  a,b     ;Set lower 3 bits of Y into new E.
    rrca
    rrca
    rrca
    ld  b,a     ;keep this for now. Bit pattern YYY---YY.
    xor a,c
    and a,%11100000 ;Write X into low 5 bits of address, retaining Y.
    xor a,c
    ld  e,a         ;Low byte of address formed.
    ld  a,b         ;A has high Y bits
    xor a,d         ;merging address...
    and a,%00000011 ;Write address into A, keeping Y bits
    xor a,d
    ld  d,a
    ;Fetch first attribute byte from address
    ;%------YY YYYXXXXX -> %------11 11YYYXXX
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    srl e
    rra
    srl e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rlca
    rlca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  e,c \ ld  d,b
    ;Selects attribute from A bitpacked DE = %------yy yYyxxxXx y: e6, x: e1
    ;into the format %0000AA00
    bit 6,e
    jr  z,+_
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
_:  bit 1,e
    jr  nz,+_   ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
_:  and a,%00001100
    ld  (ppu_midHorizLoop_masksmc+0),a
    ld  (ppu_midHorizLoop_masksmc+1),a
    ld  (ppu_midHorizLoop_masksmc+2),a
    ;Set SP to screen buffer write location. Which one byte past the end
    ;of the current tile at its bottom-right corner, no wrap.
    ld  (ppu_midRestoreSP),sp
    ld  bc,(256*7)+8
    ld  hl,(curScreenBuf)
    add hl,bc
    ld  sp,hl
    ld  (ix+PPU_VCOUNT),29      ;first row processed, do not draw last row


    ;jr $


ppu_midVertLoop:
    ld  (ix+PPU_HCOUNT),32
ppu_midHorizLoop:
;Retrieve tile from nametable, then make pointer to buffer.
    ld  a,(de)      ;DE=nametable pointer
    ld  c,a
    ld  b,64        ;sprites are 64 bytes wide
    mlt bc
ppu_midHorizLoop_cachesmc = $+2
    ld  iy,$000000  ;FILL IN LATER TO POINTER TO BG TILE CACHE/BUFFER
    add iy,bc
ppu_midHorizLoop_masksmc  = $+1
    ld  bc,0
    ;r7 21 bytes per segement. 
    ld  hl,(iy+64- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r6
    ld  hl,(iy+56- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r5
    ld  hl,(iy+48- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r4
    ld  hl,(iy+40- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r3
    ld  hl,(iy+32- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r2
    ld  hl,(iy+24- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r1
    ld  hl,(iy+16- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r0
    ld  hl,(iy+ 8- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 8)   \   add hl,bc   \   inc sp  \   push hl
    ;ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;320 cycles per tile. Not as good as I first thought.
    ;
    ;Horizontal movement handling
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  hl,(ix+PPU_NAMETABLE_PTR)
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  (ix+PPU_NAMETABLE_PTR),a
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  ld  hl,(256*7)+16
    add hl,sp
    ld  sp,hl
    dec (ix+PPU_HCOUNT)
    jp  nz,ppu_midHorizLoop
    ;
    ;Vertical movement handling
    ;
    ld  hl,(ix+PPU_NAMETABLE_PTR)
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  (ix+PPU_NAMETABLE_PTR),hl
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    ld  hl,256*7
    add hl,sp
    ld  sp,hl
    dec (ix+PPU_VCOUNT)
    jp  nz,ppu_midVertLoop
ppu_midRestoreSP .equ $+1
    ld  sp,0
;The following is a framecounter. Mask out if needed.
    call newPage
    ld  a,(ix+PPU_FRAMECOUNT)
    call printFrameCounterPair
    ;call skipSpace
    xor a,a
    sbc hl,hl
    ld  de,($F20000)
    ld  a,d
    or  a,a     ;Framerate too large to bother calculating. Or far too small.
    jp  z,ppu_noframerate
    ld  ($F20000),hl
    ld  hl,32768
    xor a,a
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    push de
        call printFrameCounterPair
        ;call skipSpace
    pop de
    xor a,a
    ld  e,d
    ld  d,a
    ld  hl,32768/256*100
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    call printFrameCounterPair
;ppu_noframerate:
    call ppuBufSwap
    ret



;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;    ***   *** ***** *   *  ***  *          *** ***** *   * ***** *****
;   *   * *      *   *   * *   * *         *      *   *   * *     *    
;   ***** *      *   *   * ***** *          ***   *   *   * ***   ***  
;   *   * *      *   *   * *   * *             *  *   *   * *     *    
;   *   *  ***   *    ***  *   * *****      ***   *    ***  *     *    
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



;
ppu_init:
    ; Reset palette RAM, PPU, and APU registers
    ld  ix,core_memory_ix
    lea hl,ix-128
    lea de,ix-127
    ld  bc,126
    ld  (hl),$00
    ldir
    ; Bit pattern used in detecting even-odd frames
    ld  a,WREG_CONST
    ld  (ix+PPU_W),a
    ; Copies converted 64 colors to hardware LCD palette RAM.
    ; The data is from https://www.nesdev.org/wiki/PPU_palettes
    ; The destination is the Primecell PL111 LCD controller, documented here:
    ; https://wikiti.brandonw.net/index.php?title=84PCE:Ports:4000
    ld  de,mpLcdPalette
    ld  hl,paletteData
    ld  bc,64*2
    ldir
    ; Sets up the core's interrupt subsystem
    xor a,a
    ld  (int_table_len),a
    ld  de,ppu_isr
    ld  bc,27939
    call int6502_insertISA  ;sets ix. ix before this unknown.
    ld  (ix+PPU_SUBCYCLE),2
    ret



;Some bits of this is in "coreint.z80"
ppu_isr:
    ld  a,($F00020)
    and a,%0000001
    jp  nz,endCurrentRun    ;stop execution when ON key is pressed

    ld  a,(ix+PPU_CTRL)
    and a,%00011000     ;sprite and background. if zero, no rendering happens.
    ;jr  z,ppu_isr_nodraw
    ;perform the check that makes odd cycles one ppu cc shorter, but only if
    ;something is being rendered to the screen
    ld  a,(ix+PPU_FRAMECOUNT)
    rrca
    jr  nc,+_
    dec (ix+PPU_SUBCYCLE)
_:  ;there... should be something else to do?
    ;call ppu_drawBGSprites
    push iy
        call ppu_drawFrame
    pop iy
    ;call ppu_drawFGSprites
ppu_isr_nodraw:
    inc (ix+PPU_FRAMECOUNT)
    ld  bc,27939
    ld  a,(ix+PPU_SUBCYCLE)
    add a,2     ;add the 2/3rds cycle
    cp  a,3     ;but is it more than 3? (0,1,2)
    jr  c,+_
    sub a,3
    inc bc
_:  ld  (ix+PPU_SUBCYCLE),a
    lea hl,iy+0
    or  a,a
    sbc hl,bc
    push hl
    pop iy
    ld  de,ppu_isr
    call int6502_adjustTimings
    call int6502_pushISRAfterPop
    set 7,(ix+PPU_STATUS)
    ld  hl,(ppu_smc_gate)
    ld  (hl),$00        ;nop out ret so writes no longer ignored.
    ;
    ; TODO: Figure this one out:
    ; Do we need something to unset VBlank active flag at the end of
    ; VBlank if left unread?
    ;
    bit 7,(ix+PPU_CTRL)     ;VBlank NMI enable flag
    jp  z,i6502RetryFirstLoad
    ld  a,$FF
    ld  (ix+NMI_TRIGGERED),a
    jp  inst6502_brk






ppu_drawFrame:
    ;set base rom addresses
    ld  hl,(chr_rom_base)
    ld  bc,$001000
    ld  a,(ix+PPU_CTRL)
    push hl
        bit 4,a     ;background pattern base offset
        jr  z,+_
        add hl,bc
_:      ld  (chr_rom_tiles),hl
    pop hl
    bit 5,a     ;sprite pattern base offset
    jr  z,+_
    add hl,bc
_:  ld  (chr_rom_sprites),hl
    ;set coarse x,y scroll positions. B=Y, C=x
    ld  bc,(ix+PPU_XSCROLL)
    sra b
    sra b
    sra b
    sra c
    sra c
    sra c
    ld  (ix+PPU_XSCROLL_ROUGH),c
    ;set base nametable addresses
    ld  hl,nametable00
    ld  a,(ix+PPU_CTRL)
    and a,3
    add a,a
    add a,a
    ld  L,a
    ld  (ix+PPU_NAMETABLE_PTR),hl   ;yeah. let's cache this so we don't lose it
    ;In-place setting of nametable address wrt X,Y
    ;%------YY YYYXXXXX
    ld  de,(hl)
    ld  a,b     ;Set lower 3 bits of Y into new E.
    rrca
    rrca
    rrca
    ld  b,a     ;keep this for now. Bit pattern YYY---YY.
    xor a,c
    and a,%11100000 ;Write X into low 5 bits of address, retaining Y.
    xor a,c
    ld  e,a         ;Low byte of address formed.
    ld  a,b         ;A has high Y bits
    xor a,d         ;merging address...
    and a,%00000011 ;Write address into A, keeping Y bits
    xor a,d
    ld  d,a
    ;Fetch first attribute byte from address
    ;%------YY YYYXXXXX -> %------11 11YYYXXX
    push de
        ld  a,d
        rra
        srl e
        rra
        srl e       ;YYYYYXXX
        set 0,d
        set 1,d
        ld  a,e
        rlca
        rlca
        or  a,%11000000
        xor a,e
        and a,%11111000
        xor a,e
        ld  e,a
        ld  a,(de)
    pop de
    ;Selects attribute from A from B=Y, C=X in format %0000AA00
    ;Let's instead use DE %------yy yYyxxxXx y: e6, x: e1
    bit 6,e
    jr  z,+_
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
_:  bit 1,e
    jr  nz,+_   ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
_:  and a,%00001100




    ld  (ppu_mainTileLoop_attribute_write),a

    ld  (ix+PPU_VCOUNT),29      ;first row processed, do not draw last row
    ld  iy,(curScreenBuf)
    ;lea iy,iy+32
    jp  ppu_FirstRowDrawSkip    ;remove first row.
ppu_verticalLoop:
    ld  (ix+PPU_HCOUNT),32
ppu_horizontalLoop:
    ld  a,(de)
    push hl
        push de
            ld  hl,(chr_rom_tiles)
            ld  c,a
            ld  b,16
            mlt bc
            add hl,bc
            ld  (ix+PPU_TCOUNT),8
            lea de,iy+0
ppu_mainTileLoop:
            ld  a,(hl)
            ld  bc,8
            add hl,bc
            ld  b,(hl)
            ld  c,a
            push hl
                ld  hl,vram_palette
ppu_mainTileLoop_attribute_write    .equ $+1
                ld  a,0
                ;Attrib to LSB of VRAM_PALETTE, shift CHR_ROM data to LSB to
                ;form full address+offset. Copy from palette to buffer.
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;1/8 12b apiece
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;2/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;3/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;4/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;5/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;6/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;7/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;8/8 96b tot
                ld  hl,256-8
                add hl,de
                ex  de,hl   ;screen ptr in DE. Advanced to next row
            pop hl
            ld  bc,-7
            add hl,bc
            dec (ix+PPU_TCOUNT)
            jr  nz,ppu_mainTileLoop
            ;start wrapping up the horizontal loop
        pop de
    pop hl      ;HL= pointer to nametable mapping block
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  lea iy,iy+8     ;next position on the buffer.
    dec (ix+PPU_HCOUNT)
    jp  nz,ppu_horizontalLoop
    ;the X buffer *will* have changed at some point and rolled around
    ;so there's no need to deal with X. Still gotta do Y first...
    ld  bc,(256*7)+0
    add iy,bc       ;move cursor pointer to the next row
    ld  a,L         ;Flip back to previous horizontal buffer since this was
    xor a,%00000100 ;most definitely changed by the time we end the row draw.
    ld  L,a         ;Resetting X position will come later.
ppu_FirstRowDrawSkip:
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    dec (ix+PPU_VCOUNT)
    jp  nz,ppu_verticalLoop




;The following is a framecounter. Mask out if needed.
    call newPage
    ld  a,(ix+PPU_FRAMECOUNT)
    call printFrameCounterPair
    ;call skipSpace
    xor a,a
    sbc hl,hl
    ld  de,($F20000)
    ld  a,d
    or  a,a     ;Framerate too large to bother calculating. Or far too small.
    jr  z,ppu_noframerate
    ld  ($F20000),hl
    ld  hl,32768
    xor a,a
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    push de
        call printFrameCounterPair
        ;call skipSpace
    pop de
    xor a,a
    ld  e,d
    ld  d,a
    ld  hl,32768/256*100
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    call printFrameCounterPair
ppu_noframerate:
    call ppuBufSwap
    ret

;TODO: Test changes to the PPU and link together something in the mapper
;to perform controls. Also. Those freakin' interrupts. DO THEM.
;Might also want to implement a drawlist of sorts since writes to the ports
;ought to be timestamped. That way, we'll be able to tell what the hell is
;being done mid-frame and then make adjustments to such things as
;BG rendering mid-draw, if necessary. Or be able to detect such attempts as
;I don't think I want to deal with that. Only deal with stuff that should
;be occurring within the VBlank period.




;backdrop color. Do not render the following if there are no
;sprites to hide in the background.
    ld  hl,(curScreenBuf)
    ld  bc,256*224+1    ;because push.
    add hl,bc
    ld  (++_+1),sp
    ld  sp,hl
    ld  b,191
    ld  de,0
_:  push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    djnz -_
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de 
_:  ld  sp,0







