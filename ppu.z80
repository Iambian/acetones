;PPU-related stuff is written here, though not all of it is localized in
;this file. Some of it will necessarily be located with the mapper code
;that handles PPU I/O.

; NOTES ON SPRITE 0 HIT IS LOCATED IN MAIN.Z80, AROUND THE CODE WHERE
; MAPPER 0 READ HANDLER HANDLES READING PPU_STATUS.


;
; Scratchpadding some stuff
;


;Note: Can't figure out how to keep DE as the pointer to the nametable.
;Perhaps consider keeping nametable stuff inside the shadow registers?
;
;



;
; You may want to investigate macros to duplicate this bit of code but with
; labels changed around based on a single input. This stretch of code is
; going to be re-used a lot, and calling is out of the question, since the
; stack is unavailable at the time these would be called. At least, not without
; a painful amount of SP retrieval and storage.
;

#define PRINT_PPU_SUBROUTINE_SIZES

ppu_cache_bank: ;HL=dest, DE=sauce
    push de
    pop iy
    ld  c,0
_:  ld  b,8
_:  ld  e,(iy+0)
    ld  d,(iy+8)
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    inc iy
    djnz -_
    lea iy,iy+8
    dec c
    jr  nz,--_
    ret

ppu_configureCaches:
    ;===================================================================
    ;THIS WHOLE CACHEING THING NEEDS TO BE DOINE IN THE MAPPER INSTEAD 
    ;OF HERE. THE MAPPER IS WHAT CONTROLS WHAT CHR_ROM GETS BANKED WHERE
    
    ld  de,(chr_rom_base)
    ld  hl,(chr_rom_cachefrom_A)
    or  a,a
    sbc hl,de   ;Check if current bank matches cached location
    push de
        ld  (chr_rom_cachefrom_A),de
        ld  hl,chr_rom_1_cache
        call nz,ppu_cache_bank
    pop de
    ld  hl,256*16   ;THIS PART ACTUALLY HAS TO BE HANDLED BY THE MAPPER.
    add hl,de       ;SOME MAPPERS ARE CAPABLE OF BANK SPLITTING.
    ex  de,hl
    ld  hl,(chr_rom_cachefrom_B)
    or  a,a
    sbc hl,de
    ld  (chr_rom_cachefrom_B),de
    ld  hl,chr_rom_2_cache
    call nz,ppu_cache_bank
    ;===================================================================
    ;set primecell palette from PPU VRAM palette data
    ld  hl,vram_palette
    ld  de,vram_cache
    ld  bc,32
_:  ld  a,(de)
    cp  a,(hl)
    jr  nz,+_
    ldi
    jp  pe,-_
    jr  ppu_drawFrameSuper_skipPaletteReload
_:  ldir    ;finish the copy, then proceed to update palette
    ld  hl,paletteData      ;actual colors
    ld  de,mpLcdPalette     ;where colors go
    ld  iy,vram_palette     ;indices found here
    ld  a,(iy)
    ld  (++_+1),a
    ld  bc,(32*256)+255 ;B=32 for loop. C=255 to keep B safe from LDI
_:  ld  a,iyl
    and a,3
    ld  a,(iy)
    jr  nz,+_+2
_:  ld  a,0
    add a,a     ;input value range 0-63. Maybe 0-127 if single-extend.
    add a,paletteData&255
    ld  L,a
    adc a,(paletteData>>8)&255
    sub a,L
    ld  h,a
    ldi
    ldi
    inc iy
    djnz --_
ppu_drawFrameSuper_skipPaletteReload:
    ;set base rom addresses
    ld  hl,chr_rom_1_cache
    ld  de,chr_rom_2_cache
    push hl \ push de
    ld  a,(ix+PPU_CTRL)
    bit 4,a     ;background pattern base offset
    jr  z,$+3
    ex  de,hl
    ld  (chr_rom_tiles),hl
    ld  bc,64
    add hl,bc
    ld  (ppu_midHorizLoop_cachesmc),hl  ;cache at end of sprite
    pop de \ pop hl
    bit 5,a     ;sprite pattern base offset
    jr  z,$+3
    ex de,hl
    ld  (chr_rom_sprites),hl
    ret





;4288
ppu_drawFrameSuper:
    ;set base nametable addresses
    ld  hl,nametable00
    ld  a,(ix+PPU_CTRL)
    and a,3
    add a,a
    add a,a
    ld  L,a
    ld  (ix+PPU_NAMETABLE_PTR),hl   ;maybe this time we'll need it?
    ;set coarse x,y scroll positions. B=Y, C=x.
    ;Note: Pre-incrementing Y to simulate first row skip
    ld  bc,(ix+PPU_XSCROLL)
    ;HANDLE YSCROLL
    ld  a,b
    and a,%00000111
    ld  (ix+PPU_YSCROLL_FINE),a
    ld  a,b
    rra
    rra
    rra
    and a,%00011111
    inc a
    cp  a,30
    jr  c,+_
    push af
        ld  a,L
        xor a,%00001000
        ld  L,a
        ld  (ix+PPU_NAMETABLE_PTR),hl
    pop af
    sub a,30
_:  ld  b,a
    ;HANDLE XSCROLL
    ld  a,c
    and a,%00000111
    ld  (ix+PPU_XSCROLL_FINE),a
    ld  a,c
    rra
    rra
    rra
    and a,%00011111
    ld  (ix+PPU_XSCROLL_ROUGH),a
    ld  c,a

    ;In-place setting of nametable address wrt X,Y
    ;%------YY YYYXXXXX
    ld  de,(hl)
    ld  a,b     ;Set lower 3 bits of Y into new E.
    rrca
    rrca
    rrca
    ld  b,a     ;keep this for now. Bit pattern YYY---YY.
    xor a,c
    and a,%11100000 ;Write X into low 5 bits of address, retaining Y.
    xor a,c
    ld  e,a         ;Low byte of address formed.
    ld  a,b         ;A has high Y bits
    xor a,d         ;merging address...
    and a,%00000011 ;Write address into A, keeping Y bits
    xor a,d
    ld  d,a
    ;Fetch first attribute byte from address
    ;%------YY YYYXXXXX -> %------11 11YYYXXX
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    rr e
    rra
    rr e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rrca
    rrca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a
    ld  e,c \ ld  d,b
    ;Selects attribute from A bitpacked DE = %------yy yYyxxxXx y: e6, x: e1
    ;into the format %0000AA00
    bit 6,e
    jr  z,+_
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
_:  bit 1,e
    jr  nz,+_   ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
_:  and a,%00001100
    ld  (ppu_midHorizLoop_masksmc+0),a
    ld  (ppu_midHorizLoop_masksmc+1),a
    ld  (ppu_midHorizLoop_masksmc+2),a
    ld  (ppu_midRestoreSP),sp

    ld  a,(ix+PPU_YSCROLL_FINE)
    or  a,a
    jp  nz,ppu_drawFrameSuper_fineYScrolling
    ld  a,(ix+PPU_XSCROLL_FINE)
    or  a,a
    jp  nz,ppu_drawFrameSuper_fineXScrolling

    ;Set SP to screen buffer write location. Which one byte past the end
    ;of the current tile at its bottom-right corner, no wrap.
    ld  bc,(256*7)+8
    ld  hl,(curScreenBuf)
    add hl,bc
    ld  sp,hl
    ld  (ix+PPU_VCOUNT),28      ;first row processed, do not draw last row

    ld  a,(de)
    ld  (ppu_debug_first_byte_in_nametable+1),a

    


ppu_midVertLoop:
    ld  (ix+PPU_HCOUNT),32
ppu_midHorizLoop:
;Retrieve tile from nametable, then make pointer to buffer.
    ld  a,(de)      ;DE=nametable pointer
    ld  c,a
    ld  b,64        ;sprites are 64 bytes wide
    mlt bc
ppu_midHorizLoop_cachesmc = $+2
    ld  iy,$000000  ;FILL IN LATER TO POINTER TO BG TILE CACHE/BUFFER
    add iy,bc
ppu_midHorizLoop_masksmc  = $+1
    ld  bc,0
    ;r7 22 bytes per segement. 
    ld  hl,(iy+64- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r6
    ld  hl,(iy+56- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r5
    ld  hl,(iy+48- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r4
    ld  hl,(iy+40- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r3
    ld  hl,(iy+32- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r2
    ld  hl,(iy+24- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r1
    ld  hl,(iy+16- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r0
    ld  hl,(iy+ 8- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 8)   \   add hl,bc   \   inc sp  \   push hl
    ;ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;320 cycles per tile. Not as good as I first thought.
    ;
    ;Horizontal movement handling
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  hl,(ix+PPU_NAMETABLE_PTR)
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  (ix+PPU_NAMETABLE_PTR),a
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  ld  hl,(256*7)+16
    add hl,sp
    ld  sp,hl
    dec (ix+PPU_HCOUNT)
    jr  z,+++_
    ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  ppu_midHorizLoop
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    rr e
    rra
    rr e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rrca
    rrca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_midHorizLoop_masksmc+0),a
    ld  (ppu_midHorizLoop_masksmc+1),a
    ld  (ppu_midHorizLoop_masksmc+2),a
    jp ppu_midHorizLoop
_:  ;
    ;Vertical movement handling
    ;
    ld  hl,(ix+PPU_NAMETABLE_PTR)
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  (ix+PPU_NAMETABLE_PTR),hl
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    ld  hl,256*7
    add hl,sp
    ld  sp,hl
    ;Fetch first attribute byte from address
    ;%------YY YYYXXXXX -> %------11 11YYYXXX
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    rr e
    rra
    rr e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rrca
    rrca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a
    ld  e,c \ ld  d,b
    ;Selects attribute from A bitpacked DE = %------yy yYyxxxXx y: e6, x: e1
    ;into the format %0000AA00
    bit 6,e
    jr  z,+_
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
_:  bit 1,e
    jr  nz,+_   ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
_:  and a,%00001100
    ld  (ppu_midHorizLoop_masksmc+0),a
    ld  (ppu_midHorizLoop_masksmc+1),a
    ld  (ppu_midHorizLoop_masksmc+2),a
    dec (ix+PPU_VCOUNT)
    jp  nz,ppu_midVertLoop
ppu_drawFrameSuper_ending:
ppu_midRestoreSP .equ $+1
    ld  sp,0
    ;jr ppu_noframerateSuper
;The following is a framecounter. Mask out if needed.
    call newPage
    ld  a,(ix+PPU_FRAMECOUNT)

ppu_debug_first_byte_in_nametable:
    ld a,0

    call printFrameCounterPair
    ;call skipSpace
    xor a,a
    sbc hl,hl
    ld  de,($F20000)
    ld  a,d
    or  a,a     ;Framerate too large to bother calculating. Or far too small.
    jp  z,ppu_noframerateSuper
    ld  ($F20000),hl
    ld  hl,32768
    xor a,a
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    push de
        ;ld  a,(ix+PPU_XSCROLL)
        ld a,(OBJECT_ATTRIB_MEM+OAM_XPOS)
        call printFrameCounterPair
        ;call skipSpace
    pop de
    xor a,a
    ld  e,d
    ld  d,a
    ld  hl,32768/256*100
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    ;ld  a,(ix+PPU_YSCROLL)
    ld a,(OBJECT_ATTRIB_MEM+OAM_YPOS)
    call printFrameCounterPair
ppu_noframerateSuper:
    ret

;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================

;set up some stuff, then do the fine Y scroll stuff
ppu_drawFrameSuper_fineYScrolling:
    ld  c,a ;fine Y scroll value
    ld  a,(ix+PPU_XSCROLL_FINE)
    or  a,a
    jp  nz,ppu_drawFrameSuper_fineAllScrolling
    ;Adjusting mask values. Only need to do this for the first row.
    ld  hl,(ppu_midHorizLoop_masksmc)
    ld  (ppu_fineYstart_mask),hl        ;others will be filled in-loop
    ;Adjuting pointers to cache
    ld  hl,(ppu_midHorizLoop_cachesmc)  ;recall midloop cache
    ld  (ppu_fineYmidLoop_cache),hl
    ld  (ppu_fineYendLoop_cache),hl
    ld  a,c
    ld  b,8
    mlt bc
    add hl,bc
    ld  (ppu_fineYstartLoop_cache),hl
    ;Adjusting jump targets for top side clip
    ld  c,a
    ld  b,21    ;20 bytes per segment
    mlt bc
    ld  hl,ppu_fineYstartLoop_jumptable+3
    add hl,bc
    ld  (ppu_fineYstartLoop_jumptable),hl
    ;Adjusting restart value for top side clip
    ld  c,a
    ld  a,7
    sub a,c
    ld  (ppu_fineYstartLoop_restartbuf+1),a
    ;Adjusting jump targets for bottom side clip
    push bc
        add a,-8+1
        ld  c,a
        ld  b,8
        mlt bc
        add hl,bc
        ;ld  (ppu_fineYendLoop_cache),hl
    pop bc
    ld  a,7
    sub a,c
    ld  b,a     ;high byte offset
    ld  c,9     ;low byte offset +1 to account for decrement below.
    dec.s bc    ;clears BCU
    ld  hl,(curScreenBuf)
    add hl,bc
    ld  sp,hl
    ld  (ix+PPU_VCOUNT),29       ;INITIAL DEBUG VALUE. SET TO RIGHT VAL L8R.

    ;ld  a,(ix+PPU_YSCROLL_FINE)
    ;cp  a,7
    ;jr  z,$
    
    ld  hl,(ix+PPU_NAMETABLE_PTR)
ppu_fineYVertLoop:
    ld  (ix+PPU_HCOUNT),32
ppu_fineYHorizLoop_top:
    ld  a,(de)
    exx
    ld  c,a
    ld  b,64
    mlt bc
ppu_fineYstartLoop_cache .equ $+2
ppu_fineYmidLoop_cache .equ $+2
ppu_fineYendLoop_cache .equ $+2
    ld  iy,0
    add iy,bc
ppu_fineYstart_mask .equ $+1
    ld  bc,0
    ld  de,-256+8
ppu_fineYstartLoop_jumptable .equ $+1
    jp 0
;-------------------------------------
    ld  hl,(iy+64- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+56- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+48- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+40- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+32- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+24- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+16- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+ 8- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 8)   \   add hl,bc   \   inc sp  \   push hl
    ;sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
ppu_fineYstartLoop_restartbuf .equ $+1
    ld  hl,(256*7)+16
    add hl,sp
    ld  sp,hl
    exx
    ;
    ;Horizontal movement handling
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  dec (ix+PPU_HCOUNT)
    jr  z,+++_
    ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  ppu_fineYHorizLoop_top
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    rr e
    rra
    rr e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rrca
    rrca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_fineYstart_mask+0),a
    ld  (ppu_fineYstart_mask+1),a
    ld  (ppu_fineYstart_mask+2),a
    jp ppu_fineYHorizLoop_top
_:  ;
    ;Vertical movement handling
    ;
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    exx
    ld  a,7
    ld  (ppu_fineYstartLoop_restartbuf+1),a
    ld  hl,ppu_fineYstartLoop_jumptable+3
    ld  (ppu_fineYstartLoop_jumptable),hl
    ld  hl,(ppu_midHorizLoop_cachesmc)
    ld  (ppu_fineYmidLoop_cache),hl
    ;
    ld  hl,256*7
    add hl,sp
    ld  sp,hl
    exx
    ;
    ; Note: You'll want to add in some kind of attribute byte correction at
    ; this stage to handle left columns at boundaries
    ;
    dec (ix+PPU_VCOUNT)
    ld  a,(ix+PPU_VCOUNT)
        cp  a,1
    jr  nz,+_
    ;jr  $
    exx
    ld  a,(ix+PPU_YSCROLL_FINE)
    ld  hl,-1
    add a,-9
    ld  h,a
    add hl,sp
    inc hl
    ld  sp,hl   ;readjust

    ld  c,(ix+PPU_YSCROLL_FINE)
    ld  a,8
    sub a,c
    ld  c,a
    ld  b,21
    mlt bc
    ld  hl,ppu_fineYstartLoop_jumptable+3
    add hl,bc
    ld  (ppu_fineYstartLoop_jumptable),hl
    ld  a,(ix+PPU_YSCROLL_FINE)
    dec a
    ld  (ppu_fineYstartLoop_restartbuf+1),a
    exx
    ;jp  ppu_drawFrameSuper_ending
    xor a,a
    inc a
_:  or  a,a
    jp  nz,ppu_fineYVertLoop
    ;The final iteration will render all the bottoms.
    jp  ppu_drawFrameSuper_ending

;=============================================================================
;=============================================================================
;=============================================================================


ppu_drawFrameSuper_fineXScrolling:
    ;ld a,(ix+PPU_XSCROLL_FINE)
    ;cp 7
    ;jr z,$
    ;ld a, (ix+PPU_XSCROLL_ROUGH)
    ;or a,a
    ;jr  nz,$
    push de
        ; Configure initial mask settings
        ld  a,(ppu_midHorizLoop_masksmc)
        ld  (ppu_fineXHorizLoop_maskleft),a
        ; Adjusting pointers to cache
        ld  hl,(ppu_midHorizLoop_cachesmc)  ;recall midloop cache
        ld  (ppu_fineXmidLoop_cache),hl
        ;ld  hl,(chr_rom_tiles)              ;nonadjusted tiles cache
        ld  (ppu_fineXHorizLoop_cacheright),hl      ;init = +0
        ex  de,hl   ;cache address in DE. Going to use HL to build offset
        or  a,a
        sbc hl,hl
        ld  L,(ix+PPU_XSCROLL_FINE)
        add hl,de
        ld  (ppu_fineXHorizLoop_cacheleft),hl   ;init = +X
        ; Adjusting jump targets for right and left side clipping
        ld  a,(ix+PPU_XSCROLL_FINE)    ;values 1-7
        dec a
        ld  e,a
        add a,a     ;x2
        add a,a     ;x4
        add a,e     ;x5
        ;add a,2     ;x5+jr offset
        ld  (ppu_fineXHorizLoop_loopleft),a
        ;   Note: value saved was X-1, so table is using the result of that
        ;   0->6, 1->5, 2->4, 3->3, 4->2, 5->1, 6->0.
        ld  a,e
        cpl
        add a,7
        ld  d,a
        add a,a
        add a,a
        add a,d
        ;add a,2
        ld  (ppu_fineXHorizLoop_loopright),a
        ; Adjusting skip values
        ld  a,(ix+PPU_XSCROLL_FINE)
        ld  e,a
        ld  (ppu_fineXHorizLoop_sprskipleft),a
        add a,248
        ld  (ppu_fineXHorizLoop_bufskipleft),a
        ld  a,(-240)&255
        sub a,e
        ld  (ppu_fineXHorizLoop_resetbufleft),a
        ld  a,8
        sub a,e
        ld  (ppu_fineXHorizLoop_sprskipright),a
        xor a,a
        sub a,e
        ld  (ppu_fineXHorizLoop_bufskipright),a
        ld  a,e
        ld  (ppu_fineXHorizLoop_resetbufright),a
        ;
        ld  a,28
        ld  (ix+PPU_VCOUNT),a
    pop de
    ;Sets up screen buffer
    ld  hl,(curScreenBuf)
    ld  sp,hl

    ld  hl,(ix+PPU_NAMETABLE_PTR)
ppu_fineXVertLoop:
    ld (ix+PPU_HCOUNT),31+1
ppu_fineXHorizLoop_left:
    ld  a,(de)
ppu_fineXHorizLoop_maskleft .equ $+1
    ld  bc,$000800  ;embed loop counter
    exx         ;TO:Loop
    ld  b,a
    ld  c,64
    mlt bc
ppu_fineXHorizLoop_cacheleft .equ $+1
    ld  hl,0
    add hl,bc
    ex  de,hl
    sbc hl,hl
    add hl,sp   ;HL=buf DE=spr
    ld  b,0
    exx     ;TO:Normal
_:  ld  a,c
    exx     ;TO:Loop
    ld  c,a
ppu_fineXHorizLoop_loopleft .equ $+1
    jr  $
    ;5 bytes per pixel drawn. Only need 7 here.
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
ppu_fineXHorizLoop_sprskipleft .equ $+1
    ld  c,0    ; = X
    ex  de,hl
    add hl,bc
ppu_fineXHorizLoop_bufskipleft .equ $+1
    ld  c,0     ; = 248 + X
    ex  de,hl
    add hl,bc
    exx     ;TO: Normal
    ld  a,b
    and a,%11110000
    jr  nz,$
    djnz -_
    exx     ;TO: Loop
ppu_fineXHorizLoop_resetbufleft .equ $+1
    ld  de,-1   ; = -240-x. Short because midwrites start from bottom of tile
    add hl,de
    ld  sp,hl
    exx     ;TO: Normal
    ;Fixing PPU pointers before starting the next render. Doing things this
    ;way counts as a middle loop iteration, so adjust accordingly. (31+1)
    jp  ppu_fineXmidLoop_HorizontalRecalibration

ppu_fineXHorizLoop_midLoop:
    ld  a,(de)
    exx
    ld  c,a
    ld  b,64
    mlt bc
ppu_fineXmidLoop_cache .equ $+2
    ld  iy,0
    add iy,bc
ppu_fineXmidLoop_mask .equ $+1
    ld  bc,0
    ld  de,-256+8
ppu_fineXmidLoop_jumptable .equ $+1
    jp $+4
;-------------------------------------
    ld  hl,(iy+64- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+56- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+48- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+40- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+32- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+24- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+16- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+ 8- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 8)   \   add hl,bc   \   inc sp  \   push hl
    ;sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
ppu_fineXmidtLoop_restartbuf .equ $+1
    ld  hl,(256*7)+16
    add hl,sp
    ld  sp,hl
    exx
ppu_fineXmidLoop_HorizontalRecalibration:
    ;
    ;Horizontal movement handling
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  dec (ix+PPU_HCOUNT)
    jr  z,+++_
    ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  ppu_fineXHorizLoop_midLoop
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    rr e
    rra
    rr e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rrca
    rrca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_fineXmidLoop_mask+0),a
    ld  (ppu_fineXmidLoop_mask+1),a
    ld  (ppu_fineXmidLoop_mask+2),a
    jp ppu_fineXHorizLoop_midLoop
_:  ld  a,(ppu_fineXmidLoop_mask)
    ld  (ppu_fineXHorizLoop_maskright),a
ppu_fineXHorizLoop_right:
    ld  a,(de)
    ld  b,8
ppu_fineXHorizLoop_maskright .equ $+1
    ld  c,0
    exx     ;TO:Loop
    ld  b,a
    ld  c,64
    mlt bc
ppu_fineXHorizLoop_cacheright .equ $+1
    ld  hl,0
    add hl,bc
    ex  de,hl
    ld  hl,-((256*7)+8)
    add hl,sp   ;HL=buf DE=spr
    ld  b,0
    exx     ;TO:Normal
_:  ld  a,c
    exx     ;TO:Loop
    ld  c,a
ppu_fineXHorizLoop_loopright .equ $+1
    jr  $
    ;5 bytes per pixel drawn. Only need 7 here.
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
ppu_fineXHorizLoop_sprskipright .equ $+1
    ld  c,0    ; = 8-X
    ex  de,hl
    add hl,bc
ppu_fineXHorizLoop_bufskipright .equ $+1
    ld  c,0     ; = 256-X
    ex  de,hl
    add hl,bc
    exx     ;TO: Normal
    djnz -_
    exx     ;TO: Loop
    
ppu_fineXHorizLoop_resetbufright .equ $+1
    ld  de,-1    ; = X. We are already at the correct height.
    ;ABOVE COMMENT IS A LIAR. IT'S ACTUALLY... I... DON'T KNOW.
    ;CHANGING 0 to -1 BASED ON THE IDEA THAT IT NEEDED TO GO BACK
    ;UP ONE ROW SEEMED TO WORK BUT I HAVE NO FIRM IDEA WHY.
    add hl,de
    ld  sp,hl
    exx     ;TO: Normal
    ;
    ;Horizontal movement handling (from middle to right)
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  +++_    ;skip adjustmentations to reach the center
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    rr e
    rra
    rr e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rrca
    rrca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_fineXHorizLoop_maskleft),a
_:  ;NOTE: NOT ADJUSTED YET
    ;Vertical movement handling
    ;
;    ld  a,L
;    xor a,%00000100 ;X is crossing backward. Reset this.
;    ld  L,a
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    exx
    ;ld  a,7
    ;ld  (ppu_fineYstartLoop_restartbuf+1),a
    ;ld  hl,ppu_fineYstartLoop_jumptable+3
    ;ld  (ppu_fineYstartLoop_jumptable),hl
    ;ld  hl,(ppu_midHorizLoop_cachesmc)
    ;ld  (ppu_fineYmidLoop_cache),hl
    ;
    ;ld  hl,256*7
    ;add hl,sp
    ;ld  sp,hl
    exx
    ;
    ; Note: You'll want to add in some kind of attribute byte correction at
    ; this stage to handle left columns at boundaries
    ;
    dec (ix+PPU_VCOUNT)
    ;
    ; Codeblock removed was for adjusting Y parameters for fine Y scrolling.
    ; When you copy and paste this whole shebang back in for the combined
    ; X/Y routine, this is where you'll reinsert that code.
    ;
    jp  nz,ppu_fineXVertLoop
    ;The final iteration will render all the bottoms.
    jp  ppu_drawFrameSuper_ending












;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================


ppu_drawFrameSuper_fineAllScrolling:
;
; Note: It's bascially the same as X, but includes the Y initializations.
; Further initializations because of the four corners.
;
;
    ;BELOW STUB EXISTS FOR TESTING PURPOSES. IT CLEARS THE SCREEN SO THERE'S
    ;NO FLASHING ARTIFACTS FROM UNWRITTEN PORTION OF THE SCREEN
    ;REMOVE THE BELOW WHEN DONE
    push de
        ld  hl,(curScreenBuf)
        push hl
        pop de
        inc de
        ld  (hl),0
        ld  bc,(256*224)-1
        ldir
    pop de
    ;TESTING CODE IS ABOVE THIS LINE
    ;REMOVE THE CODE ABOVE WHEN DONE TESTING

    ;NOTE: The code below will be modified and extended to support starting
    ;Y-position as well. Compare this to ppu_drawFrameSuper_fineXScrolling
    ;for cacheing middle-of-screen values
    ld  bc,(ix+PPU_XSCROLL_FINE)    ;c=xscrollfine, b=yscrollfine
    push de
        ; Turn on run-once code
        xor a,a
        ld  (ppu_fineAllHoriz_topToMidReinitSMC),a
        ; Configure initial mask settings
        ld  a,(ppu_midHorizLoop_masksmc)
        ld  (ppu_fineAllHorizLoop_maskleft),a
        ; Adjusting pointers to sprite cache
        ld  hl,(ppu_midHorizLoop_cachesmc)  ;recall midloop cache
        ld  e,b     ;|
        ld  d,8     ;| Code added to 
        mlt de      ;| adjust for initial Y
        add hl,de   ;|
        ld  (ppu_fineAllmidLoop_cache),hl
        ;ld  hl,(chr_rom_tiles)              ;nonadjusted tiles cache
        ;Note: Since HL was taken as-is, presume that the adjusted
        ;HL for verticality is also correct.
        ld  (ppu_fineAllHorizLoop_cacheright),hl      ;init = +0
        ex  de,hl   ;cache address in DE. Going to use HL to build offset
        or  a,a
        sbc hl,hl
        ld  L,c     ;Scroll X fine in HL
        add hl,de
        ld  (ppu_fineAllHorizLoop_cacheleft),hl   ;init = +X
        ; Adjusting jump targets for right and left side clipping
        ld  a,c     ;values 1-7
        dec a
        ld  e,a
        add a,a     ;x2
        add a,a     ;x4
        add a,e     ;x5
        ;add a,2     ;x5+jr offset
        ld  (ppu_fineAllHorizLoop_loopleft),a
        ;   Note: value saved was X-1, so table is using the result of that
        ;   0->6, 1->5, 2->4, 3->3, 4->2, 5->1, 6->0.
        ld  a,e
        cpl
        add a,7
        ld  d,a
        add a,a
        add a,a
        add a,d
        ;add a,2
        ld  (ppu_fineAllHorizLoop_loopright),a
        ;Adjust loop limits for topleft and topright iteration
        ld  a,8
        sub a,b
        ld  (ppu_fineAllHorizLoop_maskleft+1),a     ;loop rolled into mask MSB
        ld  (ppu_fineAllHorizLoop_maskright+1),a    ;Also rolled into mask MSB
        ;Adjust jump targets for top side center clip
        ld  e,b
        ld  d,21
        mlt de
        ld  hl,ppu_fineAllmidLoop_jumptable+3
        add hl,de
        ld  (ppu_fineAllmidLoop_jumptable),hl
        ;Adjust restart value for top middle side clip
        ld  a,7
        sub a,b
        ld  (ppu_fineAllmidtLoop_restartbuf+1),a
        ;Middle-to-top-right screen buffer adjust
        ld  a,-8
        add a,b
        ld  (ppu_fineAllHorizLoop_bufptrinit+1),a
        ;Restart value for top-left side clip does not require special attention
        ; Adjusting skip values
        ld  a,(ix+PPU_XSCROLL_FINE)
        ld  e,a
        ld  (ppu_fineAllHorizLoop_sprskipleft),a
        add a,248
        ld  (ppu_fineAllHorizLoop_bufskipleft),a
        ld  a,(-240)&255
        sub a,e
        ld  (ppu_fineAllHorizLoop_resetbufleft),a
        ld  a,8
        sub a,e
        ld  (ppu_fineAllHorizLoop_sprskipright),a
        xor a,a
        sub a,e
        ld  (ppu_fineAllHorizLoop_bufskipright),a
        ld  a,e
        ld  (ppu_fineAllHorizLoop_resetbufright),a
        ;
        ld  a,29
        ld  (ix+PPU_VCOUNT),a
    pop de
    ;Sets up screen buffer
    ld  hl,(curScreenBuf)
    ld  sp,hl

    ld  hl,(ix+PPU_NAMETABLE_PTR)
ppu_fineAllVertLoop:
    ld (ix+PPU_HCOUNT),31+1
ppu_fineAllHorizLoop_left:
    ld  a,(de)
ppu_fineAllHorizLoop_maskleft .equ $+1
    ld  bc,$000800  ;embed loop counter
    exx         ;TO:Loop
    ld  b,a
    ld  c,64
    mlt bc
ppu_fineAllHorizLoop_cacheleft .equ $+1
    ld  hl,0
    add hl,bc
    ex  de,hl
    sbc hl,hl
    add hl,sp   ;HL=buf DE=spr
    ld  b,0
    exx     ;TO:Normal
_:  ld  a,c
    exx     ;TO:Loop
    ld  c,a
ppu_fineAllHorizLoop_loopleft .equ $+1
    jr  $
    ;5 bytes per pixel drawn. Only need 7 here.
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
ppu_fineAllHorizLoop_sprskipleft .equ $+1
    ld  c,0    ; = X
    ex  de,hl
    add hl,bc
ppu_fineAllHorizLoop_bufskipleft .equ $+1
    ld  c,0     ; = 248 + X
    ex  de,hl
    add hl,bc
    exx     ;TO: Normal
    ld  a,b
    and a,%11110000
    jr  nz,$
    djnz -_
    exx     ;TO: Loop
ppu_fineAllHorizLoop_resetbufleft .equ $+1
    ld  de,-1   ; = -240-x. Short because midwrites start from bottom of tile
    add hl,de
    ld  sp,hl
    exx     ;TO: Normal
    ;Fixing PPU pointers before starting the next render. Doing things this
    ;way counts as a middle loop iteration, so adjust accordingly. (31+1)
    jp  ppu_fineAllmidLoop_HorizontalRecalibration

ppu_fineAllHorizLoop_midLoop:
    ld  a,(de)
    exx
    ld  c,a
    ld  b,64
    mlt bc
ppu_fineAllmidLoop_cache .equ $+2
    ld  iy,0
    add iy,bc
ppu_fineAllmidLoop_mask .equ $+1
    ld  bc,0
    ld  de,-256+8
ppu_fineAllmidLoop_jumptable .equ $+1
    jp $+4
;-------------------------------------
    ld  hl,(iy+64- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+56- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+48- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+40- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+32- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+24- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+16- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+ 8- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 8)   \   add hl,bc   \   inc sp  \   push hl
    ;sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
ppu_fineAllmidtLoop_restartbuf .equ $+1
    ld  hl,(256*7)+16
    add hl,sp
    ld  sp,hl
    exx
ppu_fineAllmidLoop_HorizontalRecalibration:
    ;
    ;Horizontal movement handling
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  dec (ix+PPU_HCOUNT)
    jr  z,+++_
    ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  ppu_fineAllHorizLoop_midLoop
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    rr e
    rra
    rr e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rrca
    rrca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_fineAllmidLoop_mask+0),a
    ld  (ppu_fineAllmidLoop_mask+1),a
    ld  (ppu_fineAllmidLoop_mask+2),a
    jp ppu_fineAllHorizLoop_midLoop
_:  ld  a,(ppu_fineAllmidLoop_mask)
    ld  (ppu_fineAllHorizLoop_maskright),a
ppu_fineAllHorizLoop_right:
    ld  a,(de)
ppu_fineAllHorizLoop_maskright .equ $+1
    ld  bc,$000800
    exx     ;TO:Loop
    ld  b,a
    ld  c,64
    mlt bc
ppu_fineAllHorizLoop_cacheright .equ $+1
    ld  hl,0
    add hl,bc
    ex  de,hl
ppu_fineAllHorizLoop_bufptrinit .equ $+1
    ld  hl,-((256*7)+8)
    add hl,sp   ;HL=buf DE=spr
    ld  b,0
    exx     ;TO:Normal
_:  ld  a,c
    exx     ;TO:Loop
    ld  c,a
ppu_fineAllHorizLoop_loopright .equ $+1
    jr  $
    ;5 bytes per pixel drawn. Only need 7 here.
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
ppu_fineAllHorizLoop_sprskipright .equ $+1
    ld  c,0    ; = 8-X
    ex  de,hl
    add hl,bc
ppu_fineAllHorizLoop_bufskipright .equ $+1
    ld  c,0     ; = 256-X
    ex  de,hl
    add hl,bc
    exx     ;TO: Normal
    djnz -_
    exx     ;TO: Loop
    
ppu_fineAllHorizLoop_resetbufright .equ $+1
    ld  de,-1    ; = X. We are already at the correct height.
    ;ABOVE COMMENT IS A LIAR. IT'S ACTUALLY... I... DON'T KNOW.
    ;CHANGING 0 to -1 BASED ON THE IDEA THAT IT NEEDED TO GO BACK
    ;UP ONE ROW SEEMED TO WORK BUT I HAVE NO FIRM IDEA WHY.
    add hl,de
    ld  sp,hl
    exx     ;TO: Normal
    ;
    ;Horizontal movement handling (from middle to right)
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  +++_    ;skip adjustmentations to reach the center
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    rr e
    rra
    rr e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rrca
    rrca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_fineAllHorizLoop_maskleft),a
_:  ;NOTE: NOT ADJUSTED YET
    ;Vertical movement handling
    ;
;    ld  a,L
;    xor a,%00000100 ;X is crossing backward. Reset this.
;    ld  L,a
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    ;
    ; This section here sets and reaffirm the vertical center of the screen.
    ; If you can figure out how to cheaply exclude this section AFTER it
    ; gets run exactly once, do that.
    ;
ppu_fineAllHoriz_topToMidReinitSMC .equ $+1
    jr  ppu_fineAllHoriz_topToMidReinitSkip
ppu_fineAllHoriz_topToMidReinitStart:
    exx
    ld  hl,-((256*7)+8)
    ld  (ppu_fineAllHorizLoop_bufptrinit),hl
    ld  bc,(ix+PPU_XSCROLL_FINE)
    ld  hl,(ppu_midHorizLoop_cachesmc)  ;recall midloop cache
    ld  (ppu_fineAllmidLoop_cache),hl
    ld  (ppu_fineAllHorizLoop_cacheright),hl      ;init = +0
    ex  de,hl   ;cache address in DE. Going to use HL to build offset
    or  a,a
    sbc hl,hl
    ld  L,c     ;Scroll X fine in HL
    add hl,de
    ld  (ppu_fineAllHorizLoop_cacheleft),hl   ;init = +X
    ;-- left sprite buffer wasn't changed wrt dY
    ld  a,8
    ld  (ppu_fineAllHorizLoop_maskleft+1),a     ;loop rolled into mask MSB
    ld  (ppu_fineAllHorizLoop_maskright+1),a    ;Also rolled into mask MSB
    ld  a,7
    ld  (ppu_fineAllmidtLoop_restartbuf+1),a
    ld  hl,ppu_fineAllmidLoop_jumptable+3         ;roll back the jump target
    ld  (ppu_fineAllmidLoop_jumptable),hl
    ;Turn off run-once code
    ld  a,ppu_fineAllHoriz_topToMidReinitSkip-ppu_fineAllHoriz_topToMidReinitStart
    ld  (ppu_fineAllHoriz_topToMidReinitSMC),a
    exx
ppu_fineAllHoriz_topToMidReinitSkip:
    ;
    ; Note: You'll want to add in some kind of attribute byte correction at
    ; this stage to handle left columns at boundaries
    ;
    dec (ix+PPU_VCOUNT)
    ld  a,(ix+PPU_VCOUNT)
    cp  a,1     ;A is required to be kept intact in case of A=0
    jr  nz,ppu_fineAll_skipAdjustLastRow
    exx
    ;
    ; Codeblock removed was for adjusting Y parameters for fine Y scrolling.
    ; When you copy and paste this whole shebang back in for the combined
    ; X/Y routine, this is where you'll reinsert that code.
    ;
    ; Screen buffer adjustments will be unnecessary. On either side.
    ;
    ld  c,(ix+PPU_YSCROLL_FINE)
    ld  a,c
    ld  (ppu_fineAllHorizLoop_maskleft+1),a     ;loop rolled into mask MSB
    ld  (ppu_fineAllHorizLoop_maskright+1),a    ;Also rolled into mask MSB
    ;
    neg
    ld  (ppu_fineAllHorizLoop_bufptrinit+1),a
    ;
    ld  a,8
    sub a,c
    ld  c,a
    ld  b,21
    mlt bc
    ld  hl,ppu_fineAllmidLoop_jumptable+3
    add hl,bc
    ld  (ppu_fineAllmidLoop_jumptable),hl
    ld  a,(ix+PPU_YSCROLL_FINE)
    dec a
    ld  (ppu_fineAllmidtLoop_restartbuf+1),a
    ;
    ;
    ;
    xor a,a
    inc a
    exx
ppu_fineAll_skipAdjustLastRow:
    or  a,a
    jp  nz,ppu_fineAllVertLoop
    ;The final iteration will render all the bottoms.
    jp  ppu_drawFrameSuper_ending




#ifdef PRINT_PPU_SUBROUTINE_SIZES
.echo "DrawBG size: ",$ - ppu_drawFrameSuper
#endif































;Requires that ppu_drawFrameSuper is called prior to this to set up pointers. 
;This will later be merged into the frame draw.

    ld  b,a
    sub a,8
    jr  nc,ppu_drawFGSprites_skipTopClip
    ld  a,b
    add a,a
    add a,a
    add a,a     ;x8 for sprite width adjust
    ld  (ix+TEMP_MEMORY),a
    ld  a,b
    cpl
    add a,9     ;If the initial result was exactly 8, then we went out of
    and a,7     ;and we need to consider this a full clip, but add 16x8 mode
    add a,c     ;to see if it stays that way.
    jp  z,ppu_drawFGSpritesLoop_skipRender  ;
    ld  (ppu_drawFGSpritesLoop_vLoopCountSMC),a
    ld  b,8     ;Fixes screen-Y position to 0 as we are top-clipping, pre-adj.
    jr  ppu_drawFGSpritesLoop_vClipFinish
ppu_drawFGSprites_skipTopClip:
    ld  a,224
    sub a,c     ;adjust for possible 16x8 mode
    cp  a,b
    jr  nc,ppu_drawFGSprites_skipBtmClip
    add a,8
    add a,c
    ld  (ppu_drawFGSpritesLoop_vLoopCountSMC),a
    jp  ppu_drawFGSpritesLoop_vClipFinish
ppu_drawFGSprites_skipBtmClip:
    ld  a,8
    add a,c
    ld  (ppu_drawFGSpritesLoop_vLoopCountSMC),a
ppu_drawFGSpritesLoop_vClipFinish:
    ;B=preserved Y value. Need to -8 to adjust to actual screen.
    ;C can be discarded.
    xor a,a
    ld  (ppu_drawFGSpritesLoop_hJumpTargetSMC),a
    ld  e,8     ;X-slop for not clipped values. Used in skip calc further below
    ld  a,256-8
    ld  (ppu_drawFGSpritesLoop_nextScreenLineSMC),a
;    ld  a,256-8
    ld  c,(iy+OAM_XPOS)
    sub a,c
    jr  nc,ppu_drawFGSpritesLoop_skipRightClip
    ;256-x.
    ;Have: -1,-2,-3,-4,-5,-6,-7,N/A
    ld  (ppu_drawFGSpritesLoop_nextScreenLineSMC),a
    neg
    ld  e,a ;X-slop for clipped values. Used in skip calc below
    ;
    ;Perform multiply of A by size of pixel draw code
    ;
    ;FP: 5-wide
    ld  d,a ;[1,2,3,4,5,6,7,*]
    add a,a
    add a,a
    add a,d ;x5
    ld  (ppu_drawFGSpritesLoop_hJumpTargetSMC),a
ppu_drawFGSpritesLoop_skipRightClip:
;    or  a,a
    sbc hl,hl       ;Ensures all bits of HL are cleared, including HLU.
    ld  h,b         ;MSB (Y)
    ld  L,c         ;LSB (X)
    ld  bc,(curScreenBuf)
    add hl,bc       ;This resets carry, unless something went horribly wrong
    ld  sp,hl       ;SP=screenbuf
    ;
    ;The stuff below are calculations pertaining to the sprite pointer
    ;and (further) modifications to the render loop.
    ;
    ;NOTE: The stuff below is threading two different calculations together,
    ;       tied by H/VFLIP split. A for sprite skip, and HL for sprite
    ;       pointer offset to be added to sprite pointer (later) for init ptr.
    ;
    sbc hl,hl       ;clears out HL to have zeroed sprite offset
    ld  a,e         ;preserved X-slop.
    neg
    add a,8
    ;operations are not commutative. HFLIP must be tested first.
    ld  c,(iy+OAM_ATTRIBUTES)
    bit OAM_HFLIP,c
    jr  z,+_
    ld  L,7     ;horizontally-flipped sprite puts offset at right edge of sprite
    neg
_:  bit OAM_VFLIP,c
    jr  z,+_
    ld  b,a     ;preserve A during calculations
    ld  a,(ix+PPU_CTRL)     ;16x8mode bit in 5th spot, labeled as "SPRITE_SIZE"
    rrca
    rrca
    ld  d,8
    and a,d
    add a,7                 ;7=8x8mode, 15=16x8mode
    ld  e,a
    mlt de      ;vert-flip offset
    add hl,de
    ld  b,a     ;restores A to continue spriteskip calculations
    sub a,16
_:  ;ld  (ppu_drawFGSpritesLoop_spriteOffsetSMC),hl
    ld  b,a
    add a,a     ;sign extension
    sbc hl,hl
    ld  L,b
    ld  (ppu_drawFGSpritesLoop_nextSpriteLineSMC),hl
    ;Modifying unrolled loop contents for sprite increment vs decrement
    ;inc de = $13, dec de = $1B
    ld  a,$13   ;inc de
    bit OAM_HFLIP,c
    jr  z,+_
    ld  a,$1B   ;dec de
_:  ld  de,5        ;5 = FP STRIDE. CHANGE THIS TO 9 FOR BP STRIDE
    ld  hl,ppu_drawFGSpritesLoop_hJumpTargetSMC+1+4
    ld  (hl),a \ add hl,de
    ld  (hl),a \ add hl,de
    ld  (hl),a \ add hl,de
    ld  (hl),a \ add hl,de
    ld  (hl),a \ add hl,de
    ld  (hl),a \ add hl,de
    ld  (hl),a \ add hl,de
    ld  (hl),a \ add hl,de




;
; Let's go ahead and restart all over again. Starting with the absolute barest
; basics and work our way up from there. No fancy math until we actually
; need to use it. Grow it from inner-outward.
;


ppu_drawFGSprites:
    ld  (ppu_drawFGSprites_saveSP),sp
    ld  iy,OBJECT_ATTRIB_MEM+(256-4)
    ld  (ix+PPU_TCOUNT),64      ;64 sprites
ppu_drawFGSpritesLoop:
    ;Skip rendering if sprite priority does not match what we're drawing.
    bit OAM_PRIORITY,(iy+OAM_ATTRIBUTES)
    ;jp  nz,ppu_drawFGSpritesLoop_skipRender ;FP: do not draw BP sprites.
    ;B=Y. Determine if the sprite hasn't gone past the bottom of the screen.
    ld  b,(iy+OAM_YPOS)
    inc b   ;"Sprite data is delayed by one scanline."
    ld  a,240-8-1 ;not drawing bottom 8 pixels. -1 for carry
    cp  a,b
    jp  c,ppu_drawFGSpritesLoop_skipRender
    ;-----------------------------------------------------------------
    ;Init values. Remove sections from this as things are implemented.
    xor a,a
    sbc hl,hl
    ld  (ix+TEMP_MEMORY),a
    ld  (ppu_drawFGSpritesLoop_hJumpTargetSMC),a        ;X-clipping
    ld  (ppu_drawFGSpritesLoop_nextSpriteLineSMC),hl    ;X-clipping & flips
    ld  a,256-8
    ld  (ppu_drawFGSpritesLoop_nextScreenLineSMC),a     ;X-clipping
    ;-----------------------------------------------------------------
    ;C=0|8. Do some magic to get 16x8 bit to become either 0 or 8.
    ld  a,(ix+PPU_CTRL)
    rrca
    rrca
    and a,8
    ld  c,a
    ;Determine if sprite is off the top of the screen, since we're not
    ;rendering the first 8 rows. 
    ld  a,b
    cp  a,8
    jr  nc,+_
    ;   Clipping: Removing the first few rows from top of sprite.
    ;   Number of rows to remove is equal to 8-Y.
    ;   The number of rows to draw, however, is just Y.
    ;   The Y value has to be fixed to the top of the screen, though.
    ld  a,8
    sub a,b
    add a,a
    add a,a
    add a,a     ;x8 because tiles are 8 pixels wide.
    ld  (ix+TEMP_MEMORY),a
    ld  a,b
    add a,c
    jp  z,ppu_drawFGSpritesLoop_skipRender
    ld  (ppu_drawFGSpritesLoop_vLoopCountSMC),a
    ld  b,8
    jr  ppu_drawFGSpritesLoop_endVertTest
_:  ;Determine if sprite is partially off the bottom of the screen. In addition
    ;to the illegal area past 240, we also aren't rendering 232-239
    ld  a,224
    sub a,c     ;adjust for 16x8 mode.
    sub a,b
    jr  nc,+_
    ;   Clipping: Only the vdraw loop value has to be shortened, since we're
    ;   still going to draw from the start of the sprite.
    ;   We don't have to fix Y.
    add a,c
    add a,8
    ld  (ppu_drawFGSpritesLoop_vLoopCountSMC),a
    jr  ppu_drawFGSpritesLoop_endVertTest
_:  ;There is no clipping to be done. Fix vloop to the full 8x8 or 16x8 range.
    ld  a,8
    add a,c
    ld  (ppu_drawFGSpritesLoop_vLoopCountSMC),a
ppu_drawFGSpritesLoop_endVertTest:
    ;Testing if we need to perform right-clipping.
    ld  c,(iy+OAM_XPOS)
    ld  a,256-8
    sub a,c     ;PIVOT-ACTUAL. Carry if need the clipping
    jr  nc,+_
    ;   Clipping: Received values [-1,-2,-3,..] need the following values:
    ;   8*[1,2,3,..] for ppu_drawFGSpritesLoop_hJumpTargetSMC
    ;   [1,2,3,..] for BASE VALUE of ppu_drawFGSpritesLoop_nextSpriteLineSMC
    ;   [249,250,251,..] for ppu_drawFGSpritesLoop_nextScreenLineSMC
    neg
    ld  (ppu_drawFGSpritesLoop_nextSpriteLineSMC),a
    ld  e,a
    add a,a
    add a,a
    add a,a
    ld  (ppu_drawFGSpritesLoop_hJumpTargetSMC),a
    ld  a,e
    add a,248
    ld  (ppu_drawFGSpritesLoop_nextScreenLineSMC),a
_:  ;Prepare and establish screen buffer pointer.
    or  a,a
    sbc hl,hl   ;clear out HLU
    ld  a,b
    sub a,8
    ld  h,a
    ld  L,c
    ld  bc,(curScreenBuf)
    add hl,bc
    ld  sp,hl

;Configure sprite cursor horizontal direction based on HFLIP
    ld  a,$13   ;inc de
    bit OAM_HFLIP,(IY+OAM_ATTRIBUTES)
    jr  z,+_
    ld  a,$1B   ;dec de
_:  ld  de,8
    ld  hl,ppu_drawFGSpritesLoop_hJumpTargetSMC
    ld  b,8
_:  add hl,de
    ld  (hl),a
    djnz -_

;Fill out the sprite color attributes.
    ld  a,(iy+OAM_ATTRIBUTES)
    and a,%00000011
    rlca
    rlca
    or  a,%00010000
    ld  (ppu_drawFGSpritesLoop_attribMask),a

;Find bank for base sprite address
    ld  c,(iy+OAM_INDEX)
    ld  b,64
    ld  hl,(chr_rom_sprites)
    bit PPU_CTRL_SPRITE_SIZE,(ix+PPU_CTRL)
    jr  z,ppu_drawFGSpritesLoop_shortSprite
    ld  hl,chr_rom_1_cache
    rrc c
    rlc b
ppu_drawFGSpritesLoop_shortSprite:
    mlt bc
    add hl,bc
    ;Set up a few things to perform offset and next-sprite-line calculations
    ;Add some 16x8 magic to the mix.
    ld  a,(ix+PPU_CTRL)
    rlca
    and a,64
    ld  b,a
    ld  c,(IY+OAM_ATTRIBUTES)
    ld  a,(ix+TEMP_MEMORY)
    bit OAM_HFLIP,c
    jr  nz,+_
    ;   Sprite remains as-is horizontally.
    bit OAM_VFLIP,c
    jr  z,ppu_drawFGSpritesLoop_flipFinish
    ;   Sprite has only vertically flipped. Sprite offset must start at the
    ;   bottom-left, so negate existing vertical offset and add (64-8)
    ;   Existing value in ppu_drawFGSpritesLoop_nextSpriteLineSMC wrt x-clip
    ;   has to have -16 added to it to make the cursor go up, not down, per row.
    neg
    add a,64-8
    add a,b
    ex  de,hl
    ld  bc,-16
    ld  hl,(ppu_drawFGSpritesLoop_nextSpriteLineSMC)
    add hl,bc
    ld  (ppu_drawFGSpritesLoop_nextSpriteLineSMC),hl
    ex  de,hl
    jr  ppu_drawFGSpritesLoop_flipFinish
_:  ;   Sprite has been horizontally flipped.
    bit OAM_VFLIP,c
    jr  nz,+_
    ;   Sprite has only horizontally flipped. Sprite offset is simply on the
    ;   other side of the sprite (+7). Sprite traversal already handled.
    ;   ppu_drawFGSpritesLoop_nextSpriteLineSMC needs to be negated to reach
    ;   backwards to previous row, but havd 16 added to it to instead hit next.
    add a,7
    ex  de,hl
    or  a,a
    ld  hl,16
    ld  bc,(ppu_drawFGSpritesLoop_nextSpriteLineSMC)
    sbc hl,bc
    ld  (ppu_drawFGSpritesLoop_nextSpriteLineSMC),hl
    ex  de,hl
    jr  ppu_drawFGSpritesLoop_flipFinish
_:  ;   Sprite has been both horizontally and vertically flipped.
    ;   Sprite offset is a fine combination of the above stuff.
    ;   Negate, then add (64-8) to reach the row. Then add 7 to reach column.
    ;   ppu_drawFGSpritesLoop_nextSpriteLineSMC needs to be negated to reach
    ;   backwards to previous row. Nothing else is needed since that's the
    ;   direction we're headed to already.
    neg
    add a,(64-8)+7
    add a,b
    ex  de,hl
    or  a,a
    sbc hl,hl
    ld  bc,(ppu_drawFGSpritesLoop_nextSpriteLineSMC)
    sbc hl,bc
    ld  (ppu_drawFGSpritesLoop_nextSpriteLineSMC),hl
    ex  de,hl
ppu_drawFGSpritesLoop_flipFinish:
    ld  bc,0
    ld  c,a
    add hl,bc

    ld  bc,64   ;kludge. fix later.
    add hl,bc

    ex  de,hl
    sbc hl,hl
    add hl,sp
    ;The SMC code below is near loop init.
ppu_drawFGSpritesLoop_attribMask    .equ $+1
ppu_drawFGSpritesLoop_vLoopCountSMC .equ $+2
    ld  bc,0
ppu_drawFGSpritesLoop_hJumpTargetSMC .equ $+1
    jr  $+2
    ld  a,(de) \ or a,a \ jr z,$+4 \ or a,c \ ld (hl),a \ inc hl \ inc de   ;8-wide
    ld  a,(de) \ or a,a \ jr z,$+4 \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld  a,(de) \ or a,a \ jr z,$+4 \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld  a,(de) \ or a,a \ jr z,$+4 \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld  a,(de) \ or a,a \ jr z,$+4 \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld  a,(de) \ or a,a \ jr z,$+4 \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld  a,(de) \ or a,a \ jr z,$+4 \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld  a,(de) \ or a,a \ jr z,$+4 \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld  sp,hl       ;screen buffer storage
ppu_drawFGSpritesLoop_nextSpriteLineSMC .equ $+1
    ld  hl,0
    add hl,de
    ex  de,hl
ppu_drawFGSpritesLoop_nextScreenLineSMC .equ $+1
    ld  hl,256-8
    add hl,sp
    djnz ppu_drawFGSpritesLoop_hJumpTargetSMC-1
ppu_drawFGSpritesLoop_skipRender:
    lea iy,iy-4
    dec (ix+PPU_TCOUNT)
    jp  nz,ppu_drawFGSpritesLoop
ppu_drawFGSprites_saveSP .equ $+1
    ld  sp,0
    ret
#ifdef PRINT_PPU_SUBROUTINE_SIZES
.echo "DrawFGSprites size: ", $ - ppu_drawFGSprites
#endif

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;    ***   *** ***** *   *  ***  *          *** ***** *   * ***** *****
;   *   * *      *   *   * *   * *         *      *   *   * *     *    
;   ***** *      *   *   * ***** *          ***   *   *   * ***   ***  
;   *   * *      *   *   * *   * *             *  *   *   * *     *    
;   *   *  ***   *    ***  *   * *****      ***   *    ***  *     *    l
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



;
ppu_init:
    ; Reset palette RAM, PPU, and APU registers
    ld  ix,core_memory_ix
    lea hl,ix-128
    lea de,ix-127
    ld  bc,126
    ld  (hl),$00
    ldir
    ; Bit pattern used in detecting even-odd frames
    ld  a,WREG_CONST
    ld  (ix+PPU_W),a
    ; Copies converted 64 colors to hardware LCD palette RAM.
    ; The data is from https://www.nesdev.org/wiki/PPU_palettes
    ; The destination is the Primecell PL111 LCD controller, documented here:
    ; https://wikiti.brandonw.net/index.php?title=84PCE:Ports:4000
    ld  de,mpLcdPalette
    ld  hl,paletteData
    ld  bc,64*2
    ldir
    ; Sets up the core's interrupt subsystem
    ld  de,ppu_isr
    ld  bc,27939
    ld  (ix+PPU_SUBCYCLE),2
    jp  int6502_init


;
;Some bits of this is in "coreint.z80"
;
ppu_isr:
    ld  a,($F00020)
    and a,%0000001
    jp  nz,endCurrentRun    ;stop execution when ON key is pressed

    ld  a,(ix+PPU_MASK)
    and a,(1<<PPU_MASK_RENDER_BG)|(1<<PPU_MASK_RENDER_SPRITES)
    jr  z,+_
    ld  a,(ix+PPU_FRAMECOUNT)
    rrca
    jr  nc,+_
    dec (ix+PPU_SUBCYCLE)
_:  ;Begin processing event stack
    ;
    ;NOTE: WHAT WE HAVE HERE IS A STOPGAP MEASURE INTENDED TO TURN THE RENDERER
    ;       ON OR OFF TO PREVENT LOCKUPS.
    ;
    push iy
        or  a,a
        sbc hl,hl
        add.s hl,sp
        ex  de,hl
        ld  hl,$010000
        or  a,a
        sbc hl,de
        srl h \ rr l
        srl h \ rr l    ;div by 4. HL is now number of entries the stack pushed.
        push hl
        pop bc
        inc.s bc    ;checking if there were any entries. Didn't want to do it
        cpi         ;this way, but that darned HLU/BCU byte made it hard.
        jp  po,ppu_isr_stackEmpty
        ld  iy,$010000-4    ;+0=[MSB=data,LSB=port], +2=time
ppu_isr_stackLoop:
        ld.s bc,(iy+0)
        ld  a,c
        cp  a,PPU_MASK_ADR
        jr  nz,+_
        ld  (ix+PPU_MASK),b
_:      lea iy,iy-4
        cpi     ;using this solely for loop checking using BC
        jp  pe,ppu_isr_stackLoop
ppu_isr_stackEmpty:
        ;
        call ppu_configureCaches
        bit PPU_MASK_RENDER_BG,(ix+PPU_MASK)
        jr  nz,+_
        call ppu_drawSolidBackdrop
        jr  ++_
_:      call ppu_drawFrameSuper
_:      bit PPU_MASK_RENDER_SPRITES,(ix+PPU_MASK)
        jr z,+_
        ;call ppu_drawBGSprites
        call ppu_drawFGSprites
_:      call ppuBufSwap
    pop iy
    ;Set CPU timing
    inc (ix+PPU_FRAMECOUNT)
    ld  bc,27939
    ld  a,(ix+PPU_SUBCYCLE)
    add a,2     ;add the 2/3rds cycle
    cp  a,3     ;but is it more than 3? (0,1,2)
    jr  c,+_
    sub a,3
    inc bc
_:  ld  (ix+PPU_SUBCYCLE),a
    
    or  a,a
    sbc hl,hl
    sbc hl,bc
    ex  de,hl
    add iy,de   ;Adjust CPU cycle counter
    ; Push ISR handlers to interrupt stack
    call int6502_nmiAdjust
    ld  bc,2273     ;distance from NMI to start of next frame render
    ld  de,ppu_end_vsync
    call int6502_insert
    set 7,(ix+PPU_STATUS)
    ; Reinit variables
    ld  hl,(ppu_smc_gate)
    ld  a,(ppu_smc_gate_ports)
    ld  (hl),a
    ; Return to system
    bit PPU_CTRL_VBLANK_NMI_ENABLE,(ix+PPU_CTRL)
    jp  z,i6502RetryFirstLoad
    ld  a,$FF
    ld  (ix+NMI_TRIGGERED),a
    jp  inst6502_brk_from_handler

ppu_end_vsync:
    ;TODO: Predict sprite 0 hit at this stage. If sprite 0 is predicted to
    ;be hit, call int6502_pushISRAfterPop instead of int6502_removeTop with
    ;DE set to ppu_sprite0_hit and BC set to which clock cycle to trigger on.
    ;The math is as follows:
    ;
    ;   OOPS I HAVEN'T THOUGHT OF IT. SOZ.
    ;
    call int6502_consume
    xor a,a
    ld  (ix+PPU_STATUS),a   ;all status flags reset at start of frame
    ld  a,(ix+PPU_MASK)
    and a,(1<<PPU_MASK_RENDER_BG)|(1<<PPU_MASK_RENDER_SPRITES)
    call nz,ppu_gate_out_ppu    ;if rendering, push render calls to event stack
    jp  i6502RetryFirstLoad

ppu_gate_out_ppu:
    
    ld  hl,(ppu_smc_gate)
    ld  a,(ppu_smc_gate_stack)
    ld  (hl),a
    ld.s sp,EVENT_STACK_S
    ret


ppu_sprite0_hit:
    call int6502_consume
    set PPU_STATUS_SPRITE_0_HIT,(ix+PPU_STATUS)
    jp  i6502RetryFirstLoad

;==============================================================================
;
; Note: Old background renderer was removed. As of this writing, the improved
; background renderer is nearly ready for deployment for games that do not
; use sprite zero collision tricks. A sprite renderer still needs to be made.
;
;==============================================================================


;backdrop color. Do not render the following if there are no
;sprites to hide in the background.
ppu_drawSolidBackdrop:
    ld  (++_+1),sp
    ld  hl,(curScreenBuf)
    ld  sp,256*224
    add hl,sp
    ld  sp,hl
    ld  b,191
    ld  de,0
    ;    1         2         3         4         5         6         7         8         9         10 
_:  push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    djnz -_     ;100 pushes. 3 bytes. 300 bytes per iter. B=191.
    ;Remaining bytes to write: 44
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    ;Remaining bytes to write: 14.
    push de \ push de \ push de \ push de 
    ;Remaining bytes to write: 2
    inc sp
    push de 
_:  ld  sp,0
    ret






