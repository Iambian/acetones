;PPU-related stuff is written here, though not all of it is localized in
;this file. Some of it will necessarily be located with the mapper code
;that handles PPU I/O.

; NOTES ON SPRITE 0 HIT IS LOCATED IN MAIN.Z80, AROUND THE CODE WHERE
; MAPPER 0 READ HANDLER HANDLES READING PPU_STATUS.


;
; Scratchpadding some stuff
;


;Note: Can't figure out how to keep DE as the pointer to the nametable.
;Perhaps consider keeping nametable stuff inside the shadow registers?
;
;



;
; You may want to investigate macros to duplicate this bit of code but with
; labels changed around based on a single input. This stretch of code is
; going to be re-used a lot, and calling is out of the question, since the
; stack is unavailable at the time these would be called. At least, not without
; a painful amount of SP retrieval and storage.
;

    ;configuring things
    ld  a,0
    ld  (ppu_left_bufinit+2),a
    ld  (ppu_left_smc_sprinit),a
    ld  (ppu_left_smc_drawheight),a
    ld  (ppu_left_smc_copylen),a
    ld  (ppu_left_smc_sprskip),a
    ld  (ppu_left_smc_bufreset),a

    ld  (ppu_right_bufinit+2),a
    ld  (ppu_right_smc_sprinit),a
    ld  (ppu_right_smc_drawheight),a
    ld  (ppu_right_smc_copylen),a
    ld  (ppu_right_smc_sprskip),a
    ld  (ppu_right_smc_bufreset),a




ppu_left:
;PPU_XSCROLL_FINE, PPU_YSCROLL_FINE
    ld  a,(ix+PPU_XSCROLL_FINE)
    ld  a,(de)
    exx
    ;SP is presumed to have been rewound to the scanline at the top of the
    ;sprite and on the left edge of the screen.
ppu_left_bufinit .equ $+1
    ld  hl,0
    add hl,sp
    ex  de,hl
    ld  c,a
    ld  b,64
    mlt bc
ppu_left_smc_sprinit .equ $+1
    ld  hl,0
    add hl,bc
ppu_left_smc_drawheight .equ $+1
    ld  a,8
ppu_left_smc_copylen .equ $+1
    jr  $
    ldi \ ldi \ ldi \ ldi \ ldi \ ldi \ ldi \ ldi
ppu_left_smc_sprskip .equ $+1
    ld  bc,0
    add hl,bc
    ex  de,hl
ppu_left_smc_bufskip .equ $+1
    ld  c,0
    add hl,bc
    ex  de,hl
    dec a
    jr  nz,ppu_left_smc_copylen-1
ppu_left_smc_bufreset .equ $+1
    ld  hl,-1
    add hl,de
    ld  sp,hl
    exx


ppu_right:
;PPU_XSCROLL_FINE, PPU_YSCROLL_FINE
    ld  a,(ix+PPU_XSCROLL_FINE)
    ld  a,(de)
    exx
    ;SP is presumed to have been rewound to the scanline at the top of the
    ;sprite and on the left edge of the screen.
ppu_right_bufinit .equ $+1
    ld  hl,0
    add hl,sp
    ex  de,hl
    ld  c,a
    ld  b,64
    mlt bc
ppu_right_smc_sprinit .equ $+1
    ld  hl,0
    add hl,bc
ppu_right_smc_drawheight .equ $+1
    ld  a,8
ppu_right_smc_copylen .equ $+1
    jr  $
    ldi \ ldi \ ldi \ ldi \ ldi \ ldi \ ldi \ ldi
ppu_right_smc_sprskip .equ $+1
    ld  bc,0
    add hl,bc
    ex  de,hl
ppu_right_smc_bufskip .equ $+1
    ld  c,0
    add hl,bc
    ex  de,hl
    dec a
    jr  nz,ppu_right_smc_copylen-1
ppu_right_smc_bufreset .equ $+1
    ld  hl,-1
    add hl,de
    ld  sp,hl
    exx



;Variant with x-scrolling being non-aligned
ppu_drawFrame_xs:










ppu_cache_bank: ;HL=dest, DE=sauce
    push de
    pop iy
    ld  c,0
_:  ld  b,8
_:  ld  e,(iy+0)
    ld  d,(iy+8)
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    xor a,a \ sla d \ rla \ sla e \ rla \ ld  (hl),a \ inc hl
    inc iy
    djnz -_
    lea iy,iy+8
    dec c
    jr  nz,--_
    ret


ppu_drawFrameSuper:
    ;===================================================================
    ;THIS WHOLE CACHEING THING NEEDS TO BE DOINE IN THE MAPPER INSTEAD 
    ;OF HERE. THE MAPPER IS WHAT CONTROLS WHAT CHR_ROM GETS BANKED WHERE
    ;jr $
    ld  de,(chr_rom_base)
    ld  hl,(chr_rom_cachefrom_A)
    or  a,a
    sbc hl,de   ;Check if current bank matches cached location
    push de
        ld  (chr_rom_cachefrom_A),de
        ld  hl,chr_rom_1_cache
        call nz,ppu_cache_bank
    pop de
    ld  hl,256*16   ;THIS PART ACTUALLY HAS TO BE HANDLED BY THE MAPPER.
    add hl,de       ;SOME MAPPERS ARE CAPABLE OF BANK SPLITTING.
    ex  de,hl
    ld  hl,(chr_rom_cachefrom_B)
    or  a,a
    sbc hl,de
    ld  (chr_rom_cachefrom_B),de
    ld  hl,chr_rom_2_cache
    call nz,ppu_cache_bank
    ;===================================================================
    ;set primecell palette from PPU VRAM palette data
    ld  hl,vram_palette
    ld  de,vram_cache
    ld  bc,32
_:  ld  a,(de)
    cp  a,(hl)
    jr  nz,+_
    ldi
    jp  pe,-_
    jr  ppu_drawFrameSuper_skipPaletteReload
_:  ldir    ;finish the copy, then proceed to update palette
    ld  hl,paletteData      ;actual colors
    ld  de,mpLcdPalette     ;where colors go
    ld  iy,vram_palette     ;indices found here
    ld  a,(iy)
    ld  (++_+1),a
    ld  bc,(32*256)+255 ;B=32 for loop. C=255 to keep B safe from LDI
_:  ld  a,iyl
    and a,3
    ld  a,(iy)
    jr  nz,+_+2
_:  ld  a,0
    add a,a     ;input value range 0-63. Maybe 0-127 if single-extend.
    add a,paletteData&255
    ld  L,a
    adc a,(paletteData>>8)&255
    sub a,L
    ld  h,a
    ldi
    ldi
    inc iy
    djnz --_
ppu_drawFrameSuper_skipPaletteReload:
    ;set base rom addresses
    ld  hl,chr_rom_1_cache
    ld  de,chr_rom_2_cache
    push hl \ push de
    ld  a,(ix+PPU_CTRL)
    bit 4,a     ;background pattern base offset
    jr  z,$+3
    ex  de,hl
    ld  (chr_rom_tiles),hl
    ld  bc,64
    add hl,bc
    ld  (ppu_midHorizLoop_cachesmc),hl  ;cache at end of sprite
    pop de \ pop hl
    bit 5,a     ;sprite pattern base offset
    jr  z,$+3
    ex de,hl
    ld  (chr_rom_sprites),hl
    ;set base nametable addresses
    ld  hl,nametable00
    ld  a,(ix+PPU_CTRL)
    and a,3
    add a,a
    add a,a
    ld  L,a
    ld  (ix+PPU_NAMETABLE_PTR),hl   ;maybe this time we'll need it?
    ;set coarse x,y scroll positions. B=Y, C=x.
    ;Note: Pre-incrementing Y to simulate first row skip
    ld  bc,(ix+PPU_XSCROLL)
    ;HANDLE YSCROLL
    ld  a,b
    and a,%00000111
    ld  (ix+PPU_YSCROLL_FINE),a
    ld  a,b
    rra
    rra
    rra
    and a,%00011111
    inc a
    cp  a,30
    jr  c,+_
    push af
        ld  a,L
        xor a,%00001000
        ld  L,a
        ld  (ix+PPU_NAMETABLE_PTR),hl
    pop af
    sub a,30
_:  ld  b,a
    ;HANDLE XSCROLL
    ld  a,c
    and a,%00000111
    ld  (ix+PPU_XSCROLL_FINE),a
    ld  a,c
    rra
    rra
    rra
    and a,%00011111
    ld  (ix+PPU_XSCROLL_ROUGH),a
    ld  c,a

    ;In-place setting of nametable address wrt X,Y
    ;%------YY YYYXXXXX
    ld  de,(hl)
    ld  a,b     ;Set lower 3 bits of Y into new E.
    rrca
    rrca
    rrca
    ld  b,a     ;keep this for now. Bit pattern YYY---YY.
    xor a,c
    and a,%11100000 ;Write X into low 5 bits of address, retaining Y.
    xor a,c
    ld  e,a         ;Low byte of address formed.
    ld  a,b         ;A has high Y bits
    xor a,d         ;merging address...
    and a,%00000011 ;Write address into A, keeping Y bits
    xor a,d
    ld  d,a
    ;Fetch first attribute byte from address
    ;%------YY YYYXXXXX -> %------11 11YYYXXX
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    srl e
    rra
    srl e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rlca
    rlca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a
    ld  e,c \ ld  d,b
    ;Selects attribute from A bitpacked DE = %------yy yYyxxxXx y: e6, x: e1
    ;into the format %0000AA00
    bit 6,e
    jr  z,+_
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
_:  bit 1,e
    jr  nz,+_   ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
_:  and a,%00001100
    ld  (ppu_midHorizLoop_masksmc+0),a
    ld  (ppu_midHorizLoop_masksmc+1),a
    ld  (ppu_midHorizLoop_masksmc+2),a
    ld  (ppu_midRestoreSP),sp

    ld  a,(ix+PPU_YSCROLL_FINE)
    or  a,a
    jp  nz,ppu_drawFrameSuper_fineYScrolling
    ld  a,(ix+PPU_XSCROLL_FINE)
    or  a,a
    jp  nz,ppu_drawFrameSuper_fineXScrolling

    ;Set SP to screen buffer write location. Which one byte past the end
    ;of the current tile at its bottom-right corner, no wrap.
    ld  bc,(256*7)+8
    ld  hl,(curScreenBuf)
    add hl,bc
    ld  sp,hl
    ld  (ix+PPU_VCOUNT),28      ;first row processed, do not draw last row

    ld  a,(de)
    ld  (ppu_debug_first_byte_in_nametable+1),a

    ;jr $


ppu_midVertLoop:
    ld  (ix+PPU_HCOUNT),32
ppu_midHorizLoop:
;Retrieve tile from nametable, then make pointer to buffer.
    ld  a,(de)      ;DE=nametable pointer
    ld  c,a
    ld  b,64        ;sprites are 64 bytes wide
    mlt bc
ppu_midHorizLoop_cachesmc = $+2
    ld  iy,$000000  ;FILL IN LATER TO POINTER TO BG TILE CACHE/BUFFER
    add iy,bc
ppu_midHorizLoop_masksmc  = $+1
    ld  bc,0
    ;r7 22 bytes per segement. 
    ld  hl,(iy+64- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r6
    ld  hl,(iy+56- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r5
    ld  hl,(iy+48- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r4
    ld  hl,(iy+40- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r3
    ld  hl,(iy+32- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r2
    ld  hl,(iy+24- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r1
    ld  hl,(iy+16- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 8)   \   add hl,bc   \   inc sp  \   push hl
    ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;r0
    ld  hl,(iy+ 8- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 8)   \   add hl,bc   \   inc sp  \   push hl
    ;ld  hl,-256+8       \   add hl,sp   \   ld  sp,hl
    ;320 cycles per tile. Not as good as I first thought.
    ;
    ;Horizontal movement handling
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  hl,(ix+PPU_NAMETABLE_PTR)
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  (ix+PPU_NAMETABLE_PTR),a
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  ld  hl,(256*7)+16
    add hl,sp
    ld  sp,hl
    dec (ix+PPU_HCOUNT)
    jr  z,+++_
    ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  ppu_midHorizLoop
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    srl e
    rra
    srl e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rlca
    rlca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_midHorizLoop_masksmc+0),a
    ld  (ppu_midHorizLoop_masksmc+1),a
    ld  (ppu_midHorizLoop_masksmc+2),a
    jp ppu_midHorizLoop
_:  ;
    ;Vertical movement handling
    ;
    ld  hl,(ix+PPU_NAMETABLE_PTR)
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  (ix+PPU_NAMETABLE_PTR),hl
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    ld  hl,256*7
    add hl,sp
    ld  sp,hl
    ;
    ; Note: You'll want to add in some kind of attribute byte correction at
    ; this stage to handle left columns at boundaries
    ;
    dec (ix+PPU_VCOUNT)
    jp  nz,ppu_midVertLoop
ppu_drawFrameSuper_ending:
ppu_midRestoreSP .equ $+1
    ld  sp,0
    ;jr ppu_noframerateSuper
;The following is a framecounter. Mask out if needed.
    call newPage
    ld  a,(ix+PPU_FRAMECOUNT)

ppu_debug_first_byte_in_nametable:
    ld a,0

    call printFrameCounterPair
    ;call skipSpace
    xor a,a
    sbc hl,hl
    ld  de,($F20000)
    ld  a,d
    or  a,a     ;Framerate too large to bother calculating. Or far too small.
    jp  z,ppu_noframerate
    ld  ($F20000),hl
    ld  hl,32768
    xor a,a
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    push de
        ld  a,(ix+PPU_XSCROLL)
        call printFrameCounterPair
        ;call skipSpace
    pop de
    xor a,a
    ld  e,d
    ld  d,a
    ld  hl,32768/256*100
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    ld  a,(ix+PPU_YSCROLL)
    call printFrameCounterPair
ppu_noframerateSuper:
    call ppuBufSwap
    ret

;=============================================================================
;=============================================================================
;=============================================================================

;set up some stuff, then do the fine Y scroll stuff
ppu_drawFrameSuper_fineYScrolling:
    ld  c,a ;fine Y scroll value
    ld  a,(ix+PPU_XSCROLL_FINE)
    or  a,a
    jp  nz,ppu_drawFrameSuper_fineAllScrolling
    ;Adjusting mask values. Only need to do this for the first row.
    ld  hl,(ppu_midHorizLoop_masksmc)
    ld  (ppu_fineYstart_mask),hl        ;others will be filled in-loop
    ;Adjuting pointers to cache
    ld  hl,(ppu_midHorizLoop_cachesmc)  ;recall midloop cache
    ld  (ppu_fineYmidLoop_cache),hl
    ld  (ppu_fineYendLoop_cache),hl
    ld  a,c
    ld  b,8
    mlt bc
    add hl,bc
    ld  (ppu_fineYstartLoop_cache),hl
    ;Adjusting jump targets for top side clip
    ld  c,a
    ld  b,21    ;20 bytes per segment
    mlt bc
    ld  hl,ppu_fineYstartLoop_jumptable+3
    add hl,bc
    ld  (ppu_fineYstartLoop_jumptable),hl
    ;Adjusting restart value for top side clip
    ld  c,a
    ld  a,7
    sub a,c
    ld  (ppu_fineYstartLoop_restartbuf+1),a
    ;Adjusting jump targets for bottom side clip
    push bc
        add a,-8+1
        ld  c,a
        ld  b,8
        mlt bc
        add hl,bc
        ;ld  (ppu_fineYendLoop_cache),hl
    pop bc
    ld  a,7
    sub a,c
    ld  b,a     ;high byte offset
    ld  c,9     ;low byte offset +1 to account for decrement below.
    dec.s bc    ;clears BCU
    ld  hl,(curScreenBuf)
    add hl,bc
    ld  sp,hl
    ld  (ix+PPU_VCOUNT),29       ;INITIAL DEBUG VALUE. SET TO RIGHT VAL L8R.



    ;ld  a,(ix+PPU_YSCROLL_FINE)
    ;cp  a,7
    ;jr  z,$
    ;jr $
    ld  hl,(ix+PPU_NAMETABLE_PTR)
ppu_fineYVertLoop:
    ld  (ix+PPU_HCOUNT),32
ppu_fineYHorizLoop_top:
    ld  a,(de)
    exx
    ld  c,a
    ld  b,64
    mlt bc
ppu_fineYstartLoop_cache .equ $+2
ppu_fineYmidLoop_cache .equ $+2
ppu_fineYendLoop_cache .equ $+2
    ld  iy,0
    add iy,bc
ppu_fineYstart_mask .equ $+1
    ld  bc,0
    ld  de,-256+8
ppu_fineYstartLoop_jumptable .equ $+1
    jp 0
;-------------------------------------
    ld  hl,(iy+64- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+56- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+48- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+40- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+32- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+24- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+16- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+ 8- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 8)   \   add hl,bc   \   inc sp  \   push hl
    ;sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
ppu_fineYstartLoop_restartbuf .equ $+1
    ld  hl,(256*7)+16
    add hl,sp
    ld  sp,hl
    exx
    ;
    ;Horizontal movement handling
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  dec (ix+PPU_HCOUNT)
    jr  z,+++_
    ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  ppu_fineYHorizLoop_top
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    srl e
    rra
    srl e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rlca
    rlca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_fineYstart_mask+0),a
    ld  (ppu_fineYstart_mask+1),a
    ld  (ppu_fineYstart_mask+2),a
    jp ppu_fineYHorizLoop_top
_:  ;
    ;Vertical movement handling
    ;
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    exx
    ld  a,7
    ld  (ppu_fineYstartLoop_restartbuf+1),a
    ld  hl,ppu_fineYstartLoop_jumptable+3
    ld  (ppu_fineYstartLoop_jumptable),hl
    ld  hl,(ppu_midHorizLoop_cachesmc)
    ld  (ppu_fineYmidLoop_cache),hl
    ;
    ld  hl,256*7
    add hl,sp
    ld  sp,hl
    exx
    ;
    ; Note: You'll want to add in some kind of attribute byte correction at
    ; this stage to handle left columns at boundaries
    ;
    dec (ix+PPU_VCOUNT)
    ld  a,(ix+PPU_VCOUNT)
    cp  a,1
    jr  nz,+_
    ;jr  $
    exx
    ld  a,(ix+PPU_YSCROLL_FINE)
    ld  hl,-1
    add a,-9
    ld  h,a
    add hl,sp
    inc hl
    ld  sp,hl   ;readjust

    ld  c,(ix+PPU_YSCROLL_FINE)
    ld  a,8
    sub a,c
    ld  c,a
    ld  b,21
    mlt bc
    ld  hl,ppu_fineYstartLoop_jumptable+3
    add hl,bc
    ld  (ppu_fineYstartLoop_jumptable),hl
    ld  a,(ix+PPU_YSCROLL_FINE)
    dec a
    ld  (ppu_fineYstartLoop_restartbuf+1),a
    exx
    ;jp  ppu_drawFrameSuper_ending
    xor a,a
    inc a
_:  or  a,a
    jp  nz,ppu_fineYVertLoop
    ;The final iteration will render all the bottoms.
    jp  ppu_drawFrameSuper_ending

;=============================================================================
;=============================================================================
;=============================================================================


ppu_drawFrameSuper_fineXScrolling:
    ld a,(ix+PPU_XSCROLL_FINE)
    cp 7
    jr z,$
    push de
        ; Configure initial mask settings
        ld  a,(ppu_midHorizLoop_masksmc)
        ld  (ppu_fineXHorizLoop_maskleft),a
        ; Adjusting pointers to cache
        ld  hl,(ppu_midHorizLoop_cachesmc)  ;recall midloop cache
        ld  (ppu_fineXmidLoop_cache),hl
        ld  hl,(chr_rom_tiles)              ;nonadjusted tiles cache
        ld  (ppu_fineXHorizLoop_cacheright),hl      ;init = +0
        ex  de,hl
        or  a,a
        sbc hl,hl
        ld  L,(ix+PPU_XSCROLL_FINE)
        add hl,de
        ld  (ppu_fineXHorizLoop_cacheleft),hl   ;init = +X
        ; Adjusting jump targets for right and left side clipping
        ld  a,(ix+PPU_XSCROLL_FINE)    ;values 1-7
        dec a
        ld  e,a
        add a,a     ;x2
        add a,a     ;x4
        add a,e     ;x5
        add a,2     ;x5+jr offset
        ld  (ppu_fineXHorizLoop_loopleft),a
        ;   Note: value saved was X-1, so table is using the result of that
        ;   0->6, 1->5, 2->4, 3->3, 4->2, 5->1, 6->0.
        ld  a,e
        cpl
        add a,7
        ld  d,a
        add a,a
        add a,a
        add a,d
        ;add a,2
        ld  (ppu_fineXHorizLoop_loopright),a
        ; Adjusting skip values
        ld  a,(ix+PPU_XSCROLL_FINE)
        ld  e,a
        ld  (ppu_fineXHorizLoop_sprskipleft),a
        add a,248
        ld  (ppu_fineXHorizLoop_bufskipleft),a
        ld  a,(-240)&255    ;spasm-ng wouldn't shut up about needing to truncate
        sub a,e
        ld  (ppu_fineXHorizLoop_resetbufleft),a
        ld  a,8
        sub a,e
        ld  (ppu_fineXHorizLoop_sprskipright),a
        xor a,a
        sub a,e
        ld  (ppu_fineXHorizLoop_bufskipright),a
        ld  a,e
        ld  (ppu_fineXHorizLoop_resetbufright),a
        ;
        ld  a,1
        ld  (ix+PPU_VCOUNT),a
    pop de
    ;Sets up screen buffer
    ld  hl,(curScreenBuf)
    ld  sp,hl


    ;
    ;
    ;
    ;jr  $
    ;
    ;
    ;

    ld  hl,(ix+PPU_NAMETABLE_PTR)
ppu_fineXVertLoop:
    ld (ix+PPU_HCOUNT),31+1
ppu_fineXHorizLoop_left:
    ld  a,(de)
    ld  b,8
ppu_fineXHorizLoop_maskleft .equ $+1
    ld  c,0
    exx     ;TO:Loop
    ld  b,a
    ld  c,64
    mlt bc
ppu_fineXHorizLoop_cacheleft .equ $+1
    ld  hl,0
    add hl,bc
    ex  de,hl
    sbc hl,hl
    add hl,sp   ;HL=buf DE=spr
    ld  b,0
    exx     ;TO:Normal
_:  ld  a,c
    exx     ;TO:Loop
    ld  c,a
ppu_fineXHorizLoop_loopleft .equ $+1
    jr  $
    ;5 bytes per pixel drawn. Only need 7 here.
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
ppu_fineXHorizLoop_sprskipleft .equ $+1
    ld  c,0    ; = X
    ex  de,hl
    add hl,bc
ppu_fineXHorizLoop_bufskipleft .equ $+1
    ld  c,0     ; = 248 + X
    ex  de,hl
    add hl,bc
    exx     ;TO: Normal
    djnz -_
    exx     ;TO: Loop
ppu_fineXHorizLoop_resetbufleft .equ $+1
    ld  de,-1   ; = -240-x. Short because midwrites start from bottom of tile
    add hl,de
    ld  sp,hl
    exx     ;TO: Normal
    ;Fixing PPU pointers before starting the next render. Doing things this
    ;way counts as a middle loop iteration, so adjust accordingly. (31+1)
    jp  ppu_fineXmidLoop_HorizontalRecalibration

ppu_fineXHorizLoop_midLoop:
    ld  a,(de)
    exx
    ld  c,a
    ld  b,64
    mlt bc
ppu_fineXmidLoop_cache .equ $+2
    ld  iy,0
    add iy,bc
ppu_fineXmidLoop_mask .equ $+1
    ld  bc,0
    ld  de,-256+8
ppu_fineXmidLoop_jumptable .equ $+1
    jp $+4
;-------------------------------------
    ld  hl,(iy+64- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+64- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+56- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+56- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+48- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+48- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+40- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+40- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+32- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+32- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+24- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+24- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+16- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+16- 8)   \   add hl,bc   \   inc sp  \   push hl
    sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
    ld  hl,(iy+ 8- 3)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 6)   \   add hl,bc   \   push hl
    ld  hl,(iy+ 8- 8)   \   add hl,bc   \   inc sp  \   push hl
    ;sbc hl,hl \ add hl,de \ add hl,sp   \   ld  sp,hl
;-------------------------------------
ppu_fineXmidtLoop_restartbuf .equ $+1
    ld  hl,(256*7)+16
    add hl,sp
    ld  sp,hl
    exx
ppu_fineXmidLoop_HorizontalRecalibration:
    ;
    ;Horizontal movement handling
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  dec (ix+PPU_HCOUNT)
    jr  z,+++_
    ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  ppu_fineXHorizLoop_midLoop
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    srl e
    rra
    srl e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rlca
    rlca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_fineXmidLoop_mask+0),a
    ld  (ppu_fineXmidLoop_mask+1),a
    ld  (ppu_fineXmidLoop_mask+2),a
    jp ppu_fineXHorizLoop_midLoop
_:  ld  a,(ppu_fineXmidLoop_mask)
    ld  (ppu_fineXHorizLoop_maskright),a
ppu_fineXHorizLoop_right:
    ld  a,(de)
    ld  b,8
ppu_fineXHorizLoop_maskright .equ $+1
    ld  c,0
    exx     ;TO:Loop
    ld  b,a
    ld  c,64
    mlt bc
ppu_fineXHorizLoop_cacheright .equ $+1
    ld  hl,0
    add hl,bc
    ex  de,hl
    ld  hl,-((256*7)+8)
    add hl,sp   ;HL=buf DE=spr
    ld  b,0
    exx     ;TO:Normal
_:  ld  a,c
    exx     ;TO:Loop
    ld  c,a
ppu_fineXHorizLoop_loopright .equ $+1
    jr  $
    ;5 bytes per pixel drawn. Only need 7 here.
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
    ld a,(de) \ or a,c \ ld (hl),a \ inc hl \ inc de
ppu_fineXHorizLoop_sprskipright .equ $+1
    ld  c,0    ; = 8-X
    ex  de,hl
    add hl,bc
ppu_fineXHorizLoop_bufskipright .equ $+1
    ld  c,0     ; = 256-X
    ex  de,hl
    add hl,bc
    exx     ;TO: Normal
    djnz -_
    exx     ;TO: Loop
    ;jr $
ppu_fineXHorizLoop_resetbufright .equ $+1
    ld  de,0    ; = X. We are already at the correct height.
    add hl,de
    ld  sp,hl
    exx     ;TO: Normal
    ;
    ;Horizontal movement handling (from middle to right)
    ;
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  ld  a,e
    dec a
    xor a,e     ;undo earlier increment to check for boundary crossings
    bit 2,a     ;coarse adjust: new byte
    jr  nz,+_
    bit 1,a     ;fine adjust: choose new byte orientation
    jr  nz,++_
    jp  +++_    ;skip adjustmentations to reach the center
_:  ;Coarse adjust: Obtain new byte
    ld  c,e \ ld  b,d
    ld  a,d
    rra
    srl e
    rra
    srl e       ;YYYYYXXX
    set 0,d
    set 1,d
    ld  a,e
    rlca
    rlca
    or  a,%11000000
    xor a,e
    and a,%11111000
    xor a,e
    ld  e,a
    ld  a,(de)
    ld  (ix+PPU_ATTRIBUTE_CACHE),a    
    ld  e,c \ ld  d,b
_:  ;fine adjust: Move byte, then load to SMC
    ld a,(ix+PPU_ATTRIBUTE_CACHE)
    bit 6,e
    jr  z,$+6
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
    bit 1,e
    jr  nz,$+4  ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
    and a,%00001100
    ld  (ppu_fineXHorizLoop_maskleft+1),a
_:  ;NOTE: NOT ADJUSTED YET
    ;Vertical movement handling
    ;
;    ld  a,L
;    xor a,%00000100 ;X is crossing backward. Reset this.
;    ld  L,a
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    exx
    ;ld  a,7
    ;ld  (ppu_fineYstartLoop_restartbuf+1),a
    ;ld  hl,ppu_fineYstartLoop_jumptable+3
    ;ld  (ppu_fineYstartLoop_jumptable),hl
    ;ld  hl,(ppu_midHorizLoop_cachesmc)
    ;ld  (ppu_fineYmidLoop_cache),hl
    ;
    ;ld  hl,256*7
    ;add hl,sp
    ;ld  sp,hl
    exx
    ;
    ; Note: You'll want to add in some kind of attribute byte correction at
    ; this stage to handle left columns at boundaries
    ;
    dec (ix+PPU_VCOUNT)
    ;
    ; Codeblock removed was for adjusting Y parameters for fine Y scrolling.
    ; When you copy and paste this whole shebang back in for the combined
    ; X/Y routine, this is where you'll reinsert that code.
    ;
    jp  nz,ppu_fineXVertLoop
    ;The final iteration will render all the bottoms.
    jp  ppu_drawFrameSuper_ending












;=============================================================================
;=============================================================================
;=============================================================================


ppu_drawFrameSuper_fineAllScrolling:
    jp  ppu_drawFrameSuper_ending





;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;    ***   *** ***** *   *  ***  *          *** ***** *   * ***** *****
;   *   * *      *   *   * *   * *         *      *   *   * *     *    
;   ***** *      *   *   * ***** *          ***   *   *   * ***   ***  
;   *   * *      *   *   * *   * *             *  *   *   * *     *    
;   *   *  ***   *    ***  *   * *****      ***   *    ***  *     *    
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



;
ppu_init:
    ; Reset palette RAM, PPU, and APU registers
    ld  ix,core_memory_ix
    lea hl,ix-128
    lea de,ix-127
    ld  bc,126
    ld  (hl),$00
    ldir
    ; Bit pattern used in detecting even-odd frames
    ld  a,WREG_CONST
    ld  (ix+PPU_W),a
    ; Copies converted 64 colors to hardware LCD palette RAM.
    ; The data is from https://www.nesdev.org/wiki/PPU_palettes
    ; The destination is the Primecell PL111 LCD controller, documented here:
    ; https://wikiti.brandonw.net/index.php?title=84PCE:Ports:4000
    ld  de,mpLcdPalette
    ld  hl,paletteData
    ld  bc,64*2
    ldir
    ; Sets up the core's interrupt subsystem
    xor a,a
    ld  (int_table_len),a
    ld  de,ppu_isr
    ld  bc,27939
    call int6502_insertISA  ;sets ix. ix before this unknown.
    ld  (ix+PPU_SUBCYCLE),2
    ret



;Some bits of this is in "coreint.z80"
ppu_isr:
    ld  a,($F00020)
    and a,%0000001
    jp  nz,endCurrentRun    ;stop execution when ON key is pressed

    ld  a,(ix+PPU_CTRL)
    and a,%00011000     ;sprite and background. if zero, no rendering happens.
    ;jr  z,ppu_isr_nodraw
    ;perform the check that makes odd cycles one ppu cc shorter, but only if
    ;something is being rendered to the screen
    ld  a,(ix+PPU_FRAMECOUNT)
    rrca
    jr  nc,+_
    dec (ix+PPU_SUBCYCLE)
_:  ;there... should be something else to do?
    ;call ppu_drawBGSprites
    push iy
        call ppu_drawFrame
    pop iy
    ;call ppu_drawFGSprites
ppu_isr_nodraw:
    inc (ix+PPU_FRAMECOUNT)
    ld  bc,27939
    ld  a,(ix+PPU_SUBCYCLE)
    add a,2     ;add the 2/3rds cycle
    cp  a,3     ;but is it more than 3? (0,1,2)
    jr  c,+_
    sub a,3
    inc bc
_:  ld  (ix+PPU_SUBCYCLE),a
    lea hl,iy+0
    or  a,a
    sbc hl,bc
    push hl
    pop iy
    ld  de,ppu_isr
    call int6502_adjustTimings
    call int6502_pushISRAfterPop
    set 7,(ix+PPU_STATUS)
    ld  hl,(ppu_smc_gate)
    ld  (hl),$00        ;nop out ret so writes no longer ignored.
    ;
    ; TODO: Figure this one out:
    ; Do we need something to unset VBlank active flag at the end of
    ; VBlank if left unread?
    ;
    bit 7,(ix+PPU_CTRL)     ;VBlank NMI enable flag
    jp  z,i6502RetryFirstLoad
    ld  a,$FF
    ld  (ix+NMI_TRIGGERED),a
    jp  inst6502_brk






ppu_drawFrame:
    ;set base rom addresses
    ld  hl,(chr_rom_base)
    ld  bc,$001000
    ld  a,(ix+PPU_CTRL)
    push hl
        bit 4,a     ;background pattern base offset
        jr  z,+_
        add hl,bc
_:      ld  (chr_rom_tiles),hl
    pop hl
    bit 5,a     ;sprite pattern base offset
    jr  z,+_
    add hl,bc
_:  ld  (chr_rom_sprites),hl
    ;set coarse x,y scroll positions. B=Y, C=x
    ld  bc,(ix+PPU_XSCROLL)
    sra b
    sra b
    sra b
    sra c
    sra c
    sra c
    ld  (ix+PPU_XSCROLL_ROUGH),c
    ;set base nametable addresses
    ld  hl,nametable00
    ld  a,(ix+PPU_CTRL)
    and a,3
    add a,a
    add a,a
    ld  L,a
    ld  (ix+PPU_NAMETABLE_PTR),hl   ;yeah. let's cache this so we don't lose it
    ;In-place setting of nametable address wrt X,Y
    ;%------YY YYYXXXXX
    ld  de,(hl)
    ld  a,b     ;Set lower 3 bits of Y into new E.
    rrca
    rrca
    rrca
    ld  b,a     ;keep this for now. Bit pattern YYY---YY.
    xor a,c
    and a,%11100000 ;Write X into low 5 bits of address, retaining Y.
    xor a,c
    ld  e,a         ;Low byte of address formed.
    ld  a,b         ;A has high Y bits
    xor a,d         ;merging address...
    and a,%00000011 ;Write address into A, keeping Y bits
    xor a,d
    ld  d,a
    ;Fetch first attribute byte from address
    ;%------YY YYYXXXXX -> %------11 11YYYXXX
    push de
        ld  a,d
        rra
        srl e
        rra
        srl e       ;YYYYYXXX
        set 0,d
        set 1,d
        ld  a,e
        rlca
        rlca
        or  a,%11000000
        xor a,e
        and a,%11111000
        xor a,e
        ld  e,a
        ld  a,(de)
    pop de
    ;Selects attribute from A from B=Y, C=X in format %0000AA00
    ;Let's instead use DE %------yy yYyxxxXx y: e6, x: e1
    bit 6,e
    jr  z,+_
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
_:  bit 1,e
    jr  nz,+_   ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
_:  and a,%00001100




    ld  (ppu_mainTileLoop_attribute_write),a

    ld  (ix+PPU_VCOUNT),29      ;first row processed, do not draw last row
    ld  iy,(curScreenBuf)
    ;lea iy,iy+32
    jp  ppu_FirstRowDrawSkip    ;remove first row.
ppu_verticalLoop:
    ld  (ix+PPU_HCOUNT),32
ppu_horizontalLoop:
    ld  a,(de)
    push hl
        push de
            ld  hl,(chr_rom_tiles)
            ld  c,a
            ld  b,16
            mlt bc
            add hl,bc
            ld  (ix+PPU_TCOUNT),8
            lea de,iy+0
ppu_mainTileLoop:
            ld  a,(hl)
            ld  bc,8
            add hl,bc
            ld  b,(hl)
            ld  c,a
            push hl
                ld  hl,vram_palette
ppu_mainTileLoop_attribute_write    .equ $+1
                ld  a,0
                ;Attrib to LSB of VRAM_PALETTE, shift CHR_ROM data to LSB to
                ;form full address+offset. Copy from palette to buffer.
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;1/8 12b apiece
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;2/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;3/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;4/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;5/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;6/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;7/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;8/8 96b tot
                ld  hl,256-8
                add hl,de
                ex  de,hl   ;screen ptr in DE. Advanced to next row
            pop hl
            ld  bc,-7
            add hl,bc
            dec (ix+PPU_TCOUNT)
            jr  nz,ppu_mainTileLoop
            ;start wrapping up the horizontal loop
        pop de
    pop hl      ;HL= pointer to nametable mapping block
    ld  a,e
    inc e
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;A jump here means that bit 5 didn't change. X still in range.
    and a,%11100000     ;retain old Y values from A
    xor a,e             ;keeping only the changes made in the low bits.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,L
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor a,d         ;
    and a,%00000011 ;write high bits of D, keeping old Y values
    xor a,d
    ld  d,a         ;and map coords into a new nametable
_:  lea iy,iy+8     ;next position on the buffer.
    dec (ix+PPU_HCOUNT)
    jp  nz,ppu_horizontalLoop
    ;the X buffer *will* have changed at some point and rolled around
    ;so there's no need to deal with X. Still gotta do Y first...
    ld  bc,(256*7)+0
    add iy,bc       ;move cursor pointer to the next row
    ld  a,L         ;Flip back to previous horizontal buffer since this was
    xor a,%00000100 ;most definitely changed by the time we end the row draw.
    ld  L,a         ;Resetting X position will come later.
ppu_FirstRowDrawSkip:
    ld  a,e
    add a,32    ;increment Y
    ld  e,a
    ld  a,d
    adc a,0     ;increment next byte's Y
    ld  d,a
    rrca
    rrca        ;......yy -> yy......
    and a,e     ;merge two together top 4 bits of Y, leaving lowest bit alone.
    and a,$C0   ;and clear off the remaining bits
    cp  a,$C0   ;If all those bits were set, we went out of Y range (30,31)
    jr  nz,+_   ;Jump if we didn't go out of range (any of the bits not set)
    ld  a,L
    xor a,%00001000 ;flip to next vertical buffer
    ld  L,a         ;Resetting Y will not be needed.
    xor a,a
    ld  b,a
    jr  ++_
_:  ld  a,e
    ld  b,d
_:  ld  de,(hl)     ;Reset nametable
    ld  e,(ix+PPU_XSCROLL_ROUGH)    ;reset X positions
    xor a,e         ;A=oldyposition, E=reset X positions
    and a,%11100000 ;write X position into A
    xor a,e
    ld  e,a         ;And copy completed into address
    ld  a,b         ;A=oldyposition
    xor a,d         ;A=oldyposition, D=address components
    and a,%00000011 ;Write address components into A
    xor a,d
    ld  d,a         ;Nametable mapped.
    dec (ix+PPU_VCOUNT)
    jp  nz,ppu_verticalLoop




;The following is a framecounter. Mask out if needed.
    call newPage
    ld  a,(ix+PPU_FRAMECOUNT)
    call printFrameCounterPair
    ;call skipSpace
    xor a,a
    sbc hl,hl
    ld  de,($F20000)
    ld  a,d
    or  a,a     ;Framerate too large to bother calculating. Or far too small.
    jr  z,ppu_noframerate
    ld  ($F20000),hl
    ld  hl,32768
    xor a,a
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    push de
        call printFrameCounterPair
        ;call skipSpace
    pop de
    xor a,a
    ld  e,d
    ld  d,a
    ld  hl,32768/256*100
_:  inc a
    sbc hl,de
    jr  nc,-_
    dec a
    or  a,a ;clears necessary flags
    daa
    call printFrameCounterPair
ppu_noframerate:
    call ppuBufSwap
    ret

;TODO: Test changes to the PPU and link together something in the mapper
;to perform controls. Also. Those freakin' interrupts. DO THEM.
;Might also want to implement a drawlist of sorts since writes to the ports
;ought to be timestamped. That way, we'll be able to tell what the hell is
;being done mid-frame and then make adjustments to such things as
;BG rendering mid-draw, if necessary. Or be able to detect such attempts as
;I don't think I want to deal with that. Only deal with stuff that should
;be occurring within the VBlank period.




;backdrop color. Do not render the following if there are no
;sprites to hide in the background.
    ld  hl,(curScreenBuf)
    ld  bc,256*224+1    ;because push.
    add hl,bc
    ld  (++_+1),sp
    ld  sp,hl
    ld  b,191
    ld  de,0
_:  push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    djnz -_
    push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de \ push de
    push de \ push de \ push de \ push de \ push de 
_:  ld  sp,0







