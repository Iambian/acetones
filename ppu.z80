;PPU-related stuff is written here, though not all of it is localized in
;this file. Some of it will necessarily be located with the mapper code
;that handles PPU I/O.


    ;Do this before a lot of other things.
    ;Select current character rom banks from PPU settings.
    ld  hl,(chr_rom_base)
    ld  bc,$001000
    ld  a,(ix+PPU_CONFIG)
    push hl
        bit 4,a     ;background pattern base offset
        jr  z,+_
        add hl,bc
_:      ld  (chr_rom_tiles),hl
    pop hl
    bit 5,a     ;sprite pattern base offset
    jr  z,+_
    add hl,bc
_:  ld  (chr_rom_sprites),hl



    ;B=Y, C=X. Obtain nametable address
    ;You must preserve BC yourself. Somehow. Or not depending on how you loop.
    ;B and C are modified to fit inside the nametable selected.
    ld  hl,nametable00>>3
    ld  a,b
    sub 32
    jr  c,+_
    ld  a,b
_:  ld  b,a
    ccf
    adc hl,hl
    ld  a,c
    sub 30
    jr  c,+_
    ld  a,c
_:  ld  c,a
    ccf
    adc hl,hl
    add hl,hl   ;HL is now a pointer. do ld hl,(hl) to get actual NT address.


    ;Increment C=X, adjusting nametable pointer table in HL if crossover
    inc c
    ld  a,c
    cp  a,32
    jr  c,+_
    ld  c,0
    ld  a,L
    xor a,%00000100
    ld  L,a
_:  nop

    ;Increment B=Y, adjusting nametable pointer table in HL if crossover
    inc b
    ld  a,b
    cp  a,30
    jr  c,+_
    ld  b,0
    ld  a,L
    xor a,%00001000
    ld  L,a
_:  nop

    ;Retrieves attribute byte from B=Y, C=X
    ;HL=nametable pointer table
    ;NTptr tab low byte fmt: %000TIIAA. T=attrib, I=ID, A=address bytes
    push de
        ld  a,c
        srl a
        srl a   ;change 0-30 to 0-7. Discards low 2 bits.
        ld  e,a
        ld  a,b
        and a,3 ;discard two lower bits
        add a,a ;But place remaining bits up higher
        add a,e ;A=%00YYYXXX
        set 4,L ;swap to attrib
        ld  de,(hl)
        res 4,L ;swap back to main nametable pointers
        add a,e ;base is $C0. This will not produce a carry.
        ld  e,a
        ld  a,(de)
    pop de

    ;Selects attribute from A from B=Y, C=X in format %0000AA00
    bit 1,b
    jr  z,+_
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
_:  bit 1,c
    jr  nz,+_   ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
_:  and a,%00001100

    ;Nametable/tilemap variant
    ;Sets DE to current location in nametable wrt B=Y, C=X
    ;HL=current nametable pointer
    push hl
        ld  hl,(hl)
        ld  e,32
        ld  d,b
        mlt de
        ld  a,e
        add a,c
        ld  e,a
        add hl,de
        ;ex  de,hl
    pop hl

    ;TODO: Find way to link stuff above. The task set forth is the following:
    ;Create the main tile rendering loop. We must track the following:
    ;   Screen pointer, nametable position, loop parameters.
    ;With these, we will:
    ;1. Get tileID from nametable position
    ;2. Get attribute data associated with that tile.
    ;3. Retrieve CHR_ROM data and
    ;4. Combine it to retrieve color data, then write it to screen buffer.
    ;
    ;Later on, insert a cacheing step between 2 and 3. to selectively
    ;modify step 4.
    ;
    ; Do in the inlining thing later.
    ;




ppu_drawBG:
    ;set base rom addresses
    ld  hl,(chr_rom_base)
    ld  bc,$001000
    ld  a,(ix+PPU_CONFIG)
    push hl
        bit 4,a     ;background pattern base offset
        jr  z,+_
        add hl,bc
_:      ld  (chr_rom_tiles),hl
    pop hl
    bit 5,a     ;sprite pattern base offset
    jr  z,+_
    add hl,bc
_:  ld  (chr_rom_sprites),hl
    ;set coarse x,y scroll positions. B=Y, C=x
    ld  bc,(ix+PPU_XSCROLL)
    sla b
    sla b
    sla b
    sla c
    sla c
    sla c
    ;set base nametable addresses
    ld  hl,nametable00
    ld  a,(ix+PPU_CONFIG)
    and a,3
    add a,a
    add a,a
    ld  L,a
    ld  (ix+PPU_NAMETABLE_PTR),hl   ;yeah. let's cache this so we don't lose it
    ;In-place setting of nametable address wrt X,Y
    ;%------YY YYYXXXXX
    ld  de,(hl)
    ld  a,c
    rlca
    rlca
    rlca
    ld  e,a
    xor a,d
    and a,%00000011
    xor a,d
    ld  a,e
    xor a,b
    and %11100000
    xor a,b
    ld  e,a
    ;Fetch first attribute byte from address
    ;%------YY YYYXXXXX -> %------11 11YYYXXX
    push de
        ld  a,d
        rra
        srl e
        rra
        srl e       ;YYYYYXXX
        set 0,d
        set 1,d
        ld  a,e
        rlca
        rlca
        or  a,%11000000
        xor a,e
        and a,%11111000
        xor a,e
        ld  e,a
        ld  a,(de)
    pop de
    ;Selects attribute from A from B=Y, C=X in format %0000AA00
    ;Let's instead use DE %------yy yYyxxxXx y: e6, x: e1
    bit 6,e
    jr  z,+_
    rlca    ;If not zero, shift upper nibble into lower nibble
    rlca    ;for further selection.
    rlca
    rlca
_:  bit 1,e
    jr  nz,+_   ;If not zero, upper 2 bits of lower nibble already in position
    rlca        ;Otherwise, move them into position
    rlca        
_:  and a,%00001100
    ld  (ppu_mainTileLoop_attribute_write),a

    ld  (ix+PPU_VCOUNT),30
    ld  iy,(curScreenBuf)
    lea iy,iy+32
ppu_verticalLoop:
    ld  (ix+PPU_HCOUNT),32
ppu_horizontalLoop:
    ld  a,(de)
    push hl
        push de
            ld  hl,(chr_rom_tiles)
            ld  c,a
            ld  b,16
            mlt bc
            add hl,bc
            ld  (ix+PPU_TCOUNT),8
            lea de,iy+0
ppu_mainTileLoop:
            ld  c,(hl)
            inc hl
            ld  b,(hl)
            inc hl
            push hl
                ld  hl,vram_palette
ppu_mainTileLoop_attribute_write    .equ $+1
                ld  a,0
                ;Attrib to LSB of VRAM_PALETTE, shift CHR_ROM data to LSB to
                ;form full address+offset. Copy from palette to buffer.
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;1/8 12b apiece
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;2/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;3/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;4/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;5/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;6/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;7/8
                ld  L,a \ sla b \ rl  L \ sla c \ rl  L \ inc c \ ldi   ;8/8 96b tot
                ld  hl,320-8
                add hl,de
                ex  de,hl
            pop hl
            dec (ix+PPU_TCOUNT)
            jr  nz,ppu_mainTileLoop
            ;start wrapping up the horizontal loop
        pop de
    pop hl
    ld  a,e
    inc de
    xor a,e
    bit 5,a     ;A carry in X would result in a change in bit 5
    jr  z,+_    ;Which means there's no crossover if no sign change
    dec de      ;revert those changes in case they cascaded past E
    inc e
    and a,%11100000     ;The funny thing is that the XOR above...
    xor a,e             ;... is still valid for this masking technique.
    ld  c,a     ;And now let's squirrel this and...
    ld  b,d     ;...D for later merge magic
    ld  a,h
    xor a,%00000100 ;flip to the next horizontal buffer...
    ld  h,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor d
    and a,%00000011
    xor d
    ld  d,a         ;and map coords into a new nametable
_:  lea iy,iy+8     ;next position on the buffer.
    dec (ix+PPU_HCOUNT)
    jp  nz,ppu_horizontalLoop
    ;the X buffer *will* have changed at some point and rolled around
    ;so there's no need to deal with X. Still gotta do Y first...
    ex  de,hl
    ld  a,h
    ld  bc,%00100000
    add hl,bc   ;%-----^yy yYyxxxXx
    ex  de,hl
    ld  c,e     ;coordinate storage.
    ld  b,d
    xor a,d     ;detect sign change in bit 2
    bit 2,a
    jr  z,+_
    ld  a,L
    xor a,%00001000 ;flip to the next vertical buffer...
    ld  L,a
_:  ld  a,L
    xor a,%00000100 ;flip back the horizontal buffer that must've been flipped.
    ld  L,a
    ld  de,(hl)
    ld  e,c
    ld  a,b
    xor d
    and a,%00000011
    xor d
    ld  d,a         ;and map coords into a new nametable
    ld  bc,(320*7)+(320-256)
    add iy,bc       ;move cursor pointer to the next row
    dec (ix+PPU_VCOUNT)
    jp  nz,ppu_verticalLoop
    ret

;TODO: Test changes to the PPU and link together something in the mapper
;to perform controls. Also. Those freakin' interrupts. DO THEM.
;Might also want to implement a drawlist of sorts since writes to the ports
;ought to be timestamped. That way, we'll be able to tell what the hell is
;being done mid-frame and then make adjustments to such things as
;BG rendering mid-draw, if necessary. Or be able to detect such attempts as
;I don't think I want to deal with that. Only deal with stuff that should
;be occurring within the VBlank period.











