#include "defs.inc"

;TODO: DEFINE MEMORY ACCESS MACROS. ONE OR MORE FOR READ AND WRITE.
;FIGURE OUT HOW TO GET BOTH HIGH AND LOW BYTE OF ORIGINAL ADDRESS
;AND PERFORM ALTERNATE ACTIONS BASED ON WHAT HARDWARE WAS ACCESSED.
;NOTE: PATTERN SHOWS THAT D=MSB, C=LSB OF 6502 ADDRESS. USE THIS.
;
;THESE MACROS ARE PLACEHOLDERS. CHANGE THEM LATER ON TO REFLECT ACTUAL
;HARDWARE SHENANIGANS.
;
;NOTE: WRITE ACCESSES RELY ON KNOWING WHAT DATA TO WRITE. CAN'T STORE THAT IN A
;      SINCE WE NEED TO DO CONDITIONING. REGISTER B IS UNUSED SO LET'S USE THAT.
;
#define READ_ACCESS call mapper0_read
#define WRITE_ACCESS call mapper0_write
;Later, put in actual test. Z if not triggered, NZ if triggered. This
;alters the behavior of the BRK instruction.
#define WAS_NMI_TRIGGERED bit 0,(ix+NMI_TRIGGERED)

#define OPRFLG_C res SF_CARRY,b \ jr nc,$+4 \ set SF_CARRY,b
#define OPRFLG_V res SF_OVER,b \ jp po,$+6 \ set SF_OVER,b
#define OPRFLG_Z res SF_ZERO,b \ jr nz,$+4 \ set SF_ZERO,b
#define OPRFLG_N res SF_NEG,b \ jr nc,$+4 \ set SF_NEG,b

#define FLAGS_ZN ld b,(ix+REGSR) \ rlc a \ OPRFLG_Z \ OPRFLG_N \ ld (ix+REGSR),b
#define FLAGS_CZN ld b,(ix+REGSR) \ OPRFLG_C \ rlc a  \ OPRFLG_Z \ OPRFLG_N \ ld (ix+REGSR),b
#define FLAGS_VCZN ld b,(ix+REGSR) \ OPRFLG_V \ OPRFLG_C \ rlc a \ OPRFLG_Z \ OPRFLG_N \ ld (ix+REGSR),b


;Modify later to include provisions for hardware i/o based on page
#define HW_READ(src_reg) ld a,(src_reg)
#define HW_WRITE(dst_reg) ld (dst_reg),a




;=============================================================================
;=============================================================================
;=============================================================================
;=============================================================================
;You should have set up the mappings already. This is because
;mappings are program-dependant. Only $0000-$3FFF will be mapped in here
;more or less because I don't expect anything else to map that.
i6502Init:
    ;
    ; At this point, you may need to randomize 2048 bytes at main_ram
    ;
    ld  hl,main_ram
    ld  bc,$002008
    ld  e,$00
    call i6502_map_pages
    ld  hl,scrap_mapping
    ld  bc,$002001
    ld  e,$20
    call i6502_map_pages
    call i6502_load_instruction_set
    ;
    ld  ix,core_memory_ix
    ld  iy,2    ;8 cycle startup. Hooking into inst6502_jsr for init
    lea hl,ix
    lea de,ix+1
    ld  bc,126
    ld  (hl),$00
    ldir
    ;
    ld  hl,0
    add hl,sp
    ld  (ix+CORE_STACK_BASE),hl

    ;Note: SP may need initialization. So does SR for interrupts. Or somesuch.
    ld  hl,PAGETABLE+(255*BASETABLE_STRIDE)
    ld  hl,(hl)
    ld  de,$0000FC
    add hl,de
    ;
    ;jp inst6502_jsr
    ;Manual loading below. Uncomment "jp inst6502_jsr" to return to original.
    ;Settings below is to run nestest CPU-only test. The reset vector above
    ;requires a working PPU (and probably APU) to be present.
    ld  (ix+REGSR),$24      ;because that's what the log wants?
    ld  hl,$C000
    ld  (ix+REGPC),HL
    ld  iy,7
    ld  (ix+REGSP),$FD
    ;debug stuff
    ld  a,($F20030)
    set 0,a ;turn on timer 1
    ld  ($F20030),a

i6502RetryFirstLoad:    ;reentrant from ISR handler
    ld.s de,(ix+REGPC)
    dec de
    jr +_
i6502FirstLoad:
    ld.s de,(ix+REGPC)
_:  ld  a,e
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl)     ;get address to current page's base
    ld  d,0
    ld  e,a
    add hl,de       ;resolve final address
    jr  i6502FinishLoad
i6502NextLoad:
    inc hl
    inc e
    jr  nz,i6502FinishLoad
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl)     ;get address to current page's base
    ld  e,0         ;PCL known to be zero at this point.
i6502FinishLoad:
    ld  a,(hl)

#ifdef COREDEBUG
    ld  (ix+CURRENT_OPCODES+0),a
    ld  (ix+REGPC+0),e
#endif
    inc hl
    inc e
    jr  nz,i6502PrepNextPage
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl)
    ld  e,0
i6502PrepNextPage:
#ifdef COREDEBUG
    push af
        ld  a,(hl)
        ld  (ix+CURRENT_OPCODES+1),a
        push de
            push hl
                push ix
                    inc hl
                    inc e
                    jr  nz,+_
                    ld  d,(ix+REGPC+1)
                    inc d
                    ld  e,BASETABLE_STRIDE
                    mlt de
                    ld  hl,PAGETABLE
                    add hl,de
                    ld  hl,(hl)
_:                  ld  a,(hl)
                    ld  (ix+CURRENT_OPCODES+2),a
                    lea hl,ix
                    ld  de,core_memory_ix
                    or  a,a
                    sbc hl,de
                    jr  nz,$    ;halt program if IX is not core_memory_ix
                    ;jr $
                    push iy
                        call dbg_printLine
                    pop iy
                    ld  a,(ix+CORE_ERROR_LEVEL)
                    or  a,a
                    jr  z,+_
                    ld  hl,(ix+CORE_STACK_BASE)
                    ld  sp,hl
                    ret
_:                  ld  iy,(ix+CYCLES_CURRENT)  ;remove when done with timings
                    lea hl,iy+0
                    ld  de,DEBUG_STEP_START_CYCLE
                    or  a,a
                    sbc hl,de
                    call nc,waituntilnewkeypress
                pop ix
            pop hl
        pop de
    pop af
#endif
    push hl
        lea hl,iy
i6502_interrupt_timer   .equ $+1
        ld  bc,-26548
        add hl,bc
        jr  c,i6502_take_interrupt
i6502_continue_instruction_fetch:
        ld  h,a
        ld  l,BASETABLE_STRIDE
        mlt hl
        ld  bc,JUMPTABLE
        add hl,bc
        ld  hl,(hl)     ;jumptable
        ex  (sp),hl     ;exch with exec addr, jumpto-via-ret
    ret

i6502_no_interrupts:
        ;This is what happens when you let the core run without setting
        ;up interrupts. It'll be up to the hardware access subroutines
        ;to configure interrupts from now on. See "coreint.z80" for
        ;more information
        ld  hl,$800000  ;INT_MIN. Prevent retry for as long as possible.
        ld  (i6502_take_interrupt),hl
        jp  i6502_continue_instruction_fetch

i6502_take_interrupt:
        ld  h,a
        ld  a,(int_table_len)
        or  a,a
        ld  a,h
        jr  z,i6502_no_interrupts
    pop hl
    xor a,a
    ld  (ix+REGPC+0),e
    ld  hl,(INT_TABLE)  ;Find the routines in "coreint.z80" that handles
    jp  (hl)            ;and maintains the interrupt table being used here.


;Instructions one byte wide returns to the main loop via:
;   JP i6502FinishLoad
;Those with parameters have HL at the address in quetion, and is expected to
;advance HL and E at the end of the instruction. You return to main loop via:
;   JP i6502NextLoad
;Unless you manually advance the pointer to the next instruction.
;You really shouldn't but if you must do that, then also do this:
;   JP i6502FinishLoad
;Remember that register E is very important; it tells you about page boundaries.


;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------

;  ***  *   * ****  ****   ***  *   * ***** ***** **  * *****  ***  
; *     *   * *   * *   * *   * *   *   *     *   **  * *     *     
;  ***  *   * ****  ****  *   * *   *   *     *   * * * ***    ***  
;     * *   * *   * *   * *   * *   *   *     *   *  ** *         * 
;  ***   ***  ****  *   *  ***   ***    *   ***** *  ** *****  ***  

;-----------------------------------------------------------------------------

i6502_load_instruction_set:
    ld  ix,JUMPTABLE
    ld  hl,inst6502_instruction_set
    ld  b,0
_:  ld  de,(hl)
    ld  (ix+0),de
    inc hl
    inc hl
    inc hl
    lea ix,ix+BASETABLE_STRIDE
    djnz -_
    ret

;HL=Base_ez80_address, C=Numpages_in_map, B=numpages_in_space, E=starting_page
;Example: To map and mirror 2KB RAM at $D03800 inside first 8KB of 6502 space
;HL=$D03800, C=$08, B=$20, E=$00
;Note: B should be a power of two and evenly divisible by C.
i6502_map_pages:
    ld  d,BASETABLE_STRIDE
    mlt de
    ld  ix,PAGETABLE
    add ix,de
    ld  a,b     ;A = main counter for total number of pages in mapping space
    ld  de,256
    push hl
    pop iy
_:  ld  b,c     ;looping for number of pages to map
_:  ld  (ix+0),hl
    add hl,de                   ;next page z80
    lea ix,ix+BASETABLE_STRIDE  ;next page entry
    dec a
    ret z
    djnz -_
    lea hl,iy+0     ;start z80 pages over again for mirroring
    jr --_


subroutine6502_abs_split_start:
    ld  c,(hl)
    inc hl
    inc e
    jr nz,+_
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl) ;
    ld  e,0
_:  ld  b,(hl)
    ret

#define PUSH_ABSXSPLIT call subroutine6502_absx_split_start
#define PUSH_ABSXSPLIT_NODEP call subroutine6502_absx_ss_noDep
#define PUSH_ABSYSPLIT call subroutine6502_absy_split_start
#define PUSH_ABSYSPLIT_NODEP call subroutine6502_absy_ss_noDep

subroutine6502_absy_split_start:
    ld  c,(ix+REGY)
    jr +_

subroutine6502_absx_split_start:
    ld  c,(ix+REGX)
_:  ld  a,(hl)
    inc hl
    inc e
    jr nz,+_
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl) ;
    ld  e,0
_:  ld  b,(hl)
    ex  (sp),hl ;save HL onto stack as if we'd pushed HL from the caller
    push hl     ;return address back onto stack. HL is now free to be anything.
        add a,c
        jr  nc,+_
        ADDCYC(1)
        inc b
_:      ld  d,b ;save that high byte for read/write access macros
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
    ret
    
subroutine6502_absy_ss_noDep:
    ld  c,(ix+REGY)
    jr +_
subroutine6502_absx_ss_noDep:
    ld  c,(ix+REGX)
_:  ld  a,(hl)
    inc hl
    inc e
    jr nz,+_
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl) ;
    ld  e,0
_:  ld  b,(hl)
    ex  (sp),hl ;save HL onto stack as if we'd pushed HL from the caller
    push hl     ;return address back onto stack. HL is now free to be anything.
        add a,c
        jr  nc,+_
        inc b
_:      ld  d,b ;save that high byte for read/write access macros
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
    ret







subroutine6502_adc_combined_end:
    ld  a,(ix+REGSR)   ;flags register
    rra             ;gets b0 (6502 carry) into (Z80) carry flag.
    ld  a,(ix+REGA)
    adc a,c
    ld  (ix+REGA),a
    FLAGS_VCZN
    jp i6502NextLoad

subroutine6502_sbc_combined_end:
    ld  a,(ix+REGSR)   ;flags register
    rra             ;gets b0 (6502 carry) into (Z80) carry flag.
    ld  a,(ix+REGA)
    ccf
    sbc a,c
    ccf
    ld  (ix+REGA),a
    FLAGS_VCZN
    jp i6502NextLoad

subroutine6502_cmp_combined_end:
    ld  a,(ix+REGA)
    sub a,b
    ccf     ;because the 6502 is strange like that.
    FLAGS_CZN
    jp i6502NextLoad

subroutine6502_take_branch:
    ADDCYC(1)
    ld  a,(hl)  ;offset byte
    ld  L,a
    add a,a
    sbc a,a
    ld  H,a     ;sign-extending offset byte
    ld  d,(ix+REGPC+1)
    inc de
    add.s hl,de
    ld  a,h
    cp  d       ;is high byte the same?
    jr  z,+_    ;if so, do not add another clock
    ADDCYC(1)
_:  ld.s (ix+REGPC),hl
    jp  i6502FirstLoad


;-----------------------------------------------------------------------------

; *** **  *  *** ***** ***  *   *  *** ***** *** ***  **  *     ***  ***** *****                                                
;  *  **  * *      *   *  * *   * *      *    * *   * **  *    *     *       *                   
;  *  * * *  ***   *   ***  *   * *      *    * *   * * * *     ***  ***     *                          
;  *  *  **     *  *   *  * *   * *      *    * *   * *  **        * *       *                   
; *** *  **  ***   *   *  *  ***   ***   *   *** ***  *  **     ***  *****   *                                 

;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Transfer Instructions
;LDA - Load Accumulator with Memory
;    M -> A
;    N	Z	C	I	D	V
;    +	+	-	-	-	-

;addressing	assembler	opc	bytes	cycles
;immediate	LDA #oper	A9	2	2
inst6502_lda_imm:
    ld  a,(hl)
    ld  (ix+REGA),a
    FLAGS_ZN
    ADDCYC(2)
    jp i6502NextLoad

;zeropage	LDA oper	A5	2	3
inst6502_lda_zp:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  (ix+REGA),a
    FLAGS_ZN
    ADDCYC(3)
    jp i6502NextLoad

;zeropage,X	LDA oper,X	B5	2	4 
inst6502_lda_zpx:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    ld  (ix+REGA),a
    FLAGS_ZN
    ADDCYC(4)
    jp i6502NextLoad

;absolute	LDA oper	AD	3	4
inst6502_lda_abs:
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld (ix+REGA),a
        FLAGS_ZN
        ADDCYC(4)
    pop hl
    jp i6502NextLoad

;absolute,X	LDA oper,X	BD	3	4* 
inst6502_lda_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
        ld (ix+REGA),a
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;absolute,Y	LDA oper,Y	B9	3	4* 
inst6502_lda_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
        ld (ix+REGA),a
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;(indirect,X)	LDA (oper,X)	A1	2	6
inst6502_lda_indx:
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
        ld (ix+REGA),a
        FLAGS_ZN
        ADDCYC(6)
    pop hl
    jp i6502NextLoad

;(indirect),Y	LDA (oper),Y	B1	2	5*
inst6502_lda_indy:
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        ADDCYC(1)
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        ld  (ix+REGA),a
        FLAGS_ZN
        ADDCYC(5)
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;LDX - Load Index X with Memory
;    M -> X
;    N	Z	C	I	D	V
;    +	+	-	-	-	-

;immediate	LDX #oper	A2	2	2  
inst6502_ldx_imm:
    ld  a,(hl)
    ld  (ix+REGX),a
    FLAGS_ZN
    ADDCYC(2)
    jp i6502NextLoad

;zeropage	LDX oper	A6	2	3 
inst6502_ldx_zp:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  (ix+REGX),a
    FLAGS_ZN
    ADDCYC(3)
    jp i6502NextLoad

;zeropage,Y	LDX oper,Y	B6	2	4  
inst6502_ldx_zpy:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGY)
    ld  c,a
    ld  a,(bc)
    ld  (ix+REGX),a
    FLAGS_ZN
    ADDCYC(4)
    jp i6502NextLoad

;absolute	LDX oper	AE	3	4  
inst6502_ldx_abs:
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld (ix+REGX),a
        FLAGS_ZN
        ADDCYC(4)
    pop hl
    jp i6502NextLoad

;absolute,Y	LDX oper,Y	BE	3	4* 
inst6502_ldx_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
        ld (ix+REGX),a
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;LDY -  Load Index Y with Memory
;    M -> Y
;    N	Z	C	I	D	V
;    +	+	-	-	-	-

;immediate	LDY #oper	A0	2	2  
inst6502_ldy_imm:
    ld  a,(hl)
    ld  (ix+REGY),a
    FLAGS_ZN
    ADDCYC(2)
    jp i6502NextLoad

;zeropage	LDY oper	A4	2	3  
inst6502_ldy_zp:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  (ix+REGY),a
    FLAGS_ZN
    ADDCYC(3)
    jp i6502NextLoad

;zeropage,X	LDY oper,X	B4	2	4  
inst6502_ldy_zpx:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    ld  (ix+REGY),a
    FLAGS_ZN
    ADDCYC(4)
    jp i6502NextLoad

;absolute	LDY oper	AC	3	4  
inst6502_ldy_abs:
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld (ix+REGY),a
        FLAGS_ZN
        ADDCYC(4)
    pop hl
    jp i6502NextLoad

;absolute,X	LDY oper,X	BC	3	4* 
inst6502_ldy_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
        ld (ix+REGY),a
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;STA - Store Accumulator in Memory
;    A -> M
;    N	Z	C	I	D	V
;    -	-	-	-	-	-

;zeropage	STA oper	85	2	3  
inst6502_sta_zp:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(ix+REGA)
    ld  (bc),a      ;Zeropage access is not hardware-gated
    ADDCYC(3)
    jp i6502NextLoad

;zeropage,X	STA oper,X	95	2	4  
inst6502_sta_zpx:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(ix+REGA)
    ld  (bc),a      ;Zeropage access is not hardware-gated
    ADDCYC(4)
    jp i6502NextLoad

;absolute	STA oper	8D	3	4
inst6502_sta_abs:
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        ld  b,(ix+REGA)
        WRITE_ACCESS
        ADDCYC(4)
    pop hl
    jp i6502NextLoad

;absolute,X	STA oper,X	9D	3	5  
inst6502_sta_absx:
    ADDCYC(5)
    PUSH_ABSXSPLIT_NODEP
        ld  b,(ix+REGA)
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolute,Y	STA oper,Y	99	3	5  
inst6502_sta_absy:
    ADDCYC(5)
    PUSH_ABSYSPLIT_NODEP
        ld  b,(ix+REGA)
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;(indirect,X)	STA (oper,X)	81	2	6  
inst6502_sta_indx:
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        ld  b,(ix+REGA)
        WRITE_ACCESS
        ADDCYC(6)
    pop hl
    jp i6502NextLoad

;(indirect),Y	STA (oper),Y	91	2	6  
inst6502_sta_indy:
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        ld  b,(ix+REGA)
        WRITE_ACCESS
        ADDCYC(6)
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;STX - Store Index X in Memory
;    X -> M
;    N	Z	C	I	D	V
;    -	-	-	-	-	-

;zeropage	STX oper	86	2	3  
inst6502_stx_zp:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(ix+REGX)
    ld  (bc),a      ;Zeropage access is not hardware-gated
    ADDCYC(3)
    jp i6502NextLoad

;zeropage,Y	STX oper,Y	96	2	4  
inst6502_stx_zpy:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGY)
    ld  c,a
    ld  a,(ix+REGX)
    ld  (bc),a      ;Zeropage access is not hardware-gated
    ADDCYC(4)
    jp i6502NextLoad

;absolute	STX oper	8E	3	4  
inst6502_stx_abs:
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        ld  b,(ix+REGX)
        WRITE_ACCESS
        ADDCYC(4)
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;STY - Store Index Y in Memory
;    Y -> M
;    N	Z	C	I	D	V
;    -	-	-	-	-	-

;zeropage	STY oper	84	2	3  
inst6502_sty_zp:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(ix+REGY)
    ld  (bc),a      ;Zeropage access is not hardware-gated
    ADDCYC(3)
    jp i6502NextLoad

;zeropage,X	STY oper,X	94	2	4  
inst6502_sty_zpx:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(ix+REGY)
    ld  (bc),a      ;Zeropage access is not hardware-gated
    ADDCYC(4)
    jp i6502NextLoad

;absolute	STY oper	8C	3	4  
inst6502_sty_abs:
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        ld  b,(ix+REGY)
        WRITE_ACCESS
        ADDCYC(4)
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;TAX - Transfer Accumulator to Index X [A -> X]
;N	Z	C	I	D	V
;+	+	-	-	-	-
;implied	TAX	AA	1	2
inst6502_tax:
    ld  a,(ix+REGA)
    ld  (ix+REGX),a
    FLAGS_ZN
    ADDCYC(2)
    jp i6502FinishLoad

;TAY - Transfer Accumulator to Index Y [A -> Y]
;N	Z	C	I	D	V
;+	+	-	-	-	-
;implied	TAY	A8	1	2
inst6502_tay:
    ld  a,(ix+REGA)
    ld  (ix+REGY),a
    FLAGS_ZN
    ADDCYC(2)
    jp i6502FinishLoad

;TSX - Transfer Stack Pointer to Index X [SP -> X]
;N	Z	C	I	D	V
;+	+	-	-	-	-
;implied	TSX	BA	1	2
inst6502_tsx:
    ld  a,(ix+REGSP)
    ld  (ix+REGX),a
    FLAGS_ZN
    ADDCYC(2)
    jp i6502FinishLoad

;TXA - Transfer Index X to Accumulator [X -> A]
;N	Z	C	I	D	V
;+	+	-	-	-	-
;implied	TXA	8A	1	2
inst6502_txa:
    ld  a,(ix+REGX)
    ld  (ix+REGA),a
    FLAGS_ZN
    ADDCYC(2)
    jp i6502FinishLoad

;TXS - Transfer Index X to Stack Pointer [X -> SP]
;N	Z	C	I	D	V
;-	-	-	-	-	-
;implied	TXS	9A	1	2
inst6502_txs:
    ld  a,(ix+REGX)
    ld  (ix+REGSP),a
    ADDCYC(2)
    jp i6502FinishLoad

;TYA - Transfer Index Y to Accumulator [Y -> A]
;N	Z	C	I	D	V
;+	+	-	-	-	-
;implied	TYA	98	1	2
inst6502_tya:
    ld  a,(ix+REGY)
    ld  (ix+REGA),a
    FLAGS_ZN
    ADDCYC(2)
    jp i6502FinishLoad

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Stack Instructions
;PHA - Push Accumulator on Stack
;    push A
;    N	Z	C	I	D	V
;    -	-	-	-	-	-
;implied	PHA	48	1	3 
inst6502_pha:
    ADDCYC(3)
    ld  a,(ix+REGA)
    ld  bc,STACKBASE
    ld  c,(ix+REGSP)
    ld  (bc),a
    dec c
    ld  (ix+REGSP),c
    jp i6502FinishLoad

;PHP - Push Processor Status on Stack
;    The status register will be pushed with the break
;    flag and bit 5 set to 1.
;    push SR
;    N	Z	C	I	D	V
;    -	-	-	-	-	-
;implied	PHP	08	1	3  
inst6502_php:
    ADDCYC(3)
    ld  a,(ix+REGSR)
    or  a,%00110000
    ld  bc,STACKBASE
    ld  c,(ix+REGSP)
    ld  (bc),a
    dec c
    ld  (ix+REGSP),c
    jp i6502FinishLoad



;PLA - Pull Accumulator from Stack
;    pull A
;    N	Z	C	I	D	V
;    +	+	-	-	-	-
;implied	PLA	68	1	4  
inst6502_pla:
    ADDCYC(4)
    ld  bc,STACKBASE
    ld  c,(ix+REGSP)
    inc c
    ld  a,(bc)
    ld  (ix+REGSP),c
    ld  (ix+REGA),a
    FLAGS_ZN
    jp i6502FinishLoad

;PLP - Pull Processor Status from Stack
;    The status register will be pulled with the break
;    flag and bit 5 ignored.
;    pull SR
;    N	Z	C	I	D	V
;    from stack
;implied	PLP	28	1	4  
inst6502_plp:
    ADDCYC(4)
    ld  bc,STACKBASE
    ld  c,(ix+REGSP)
    inc c
    ld  a,(bc)
    ld  (ix+REGSP),c
    ld  b,(ix+REGSR)
    xor a,b
    and a,%11001111
    xor a,b
    ld  (ix+REGSR),a
    jp i6502FinishLoad


;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Decrements and Increments

;DEC -  Decrement Memory by One
;    M - 1 -> M
;    N	Z	C	I	D	V
;    +	+	-	-	-	-
;    addressing	assembler	opc	bytes	cycles

;    zeropage	DEC oper	C6	2	5  
inst6502_dec_zp:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    dec a
    ld  (bc),a
    FLAGS_ZN
    ADDCYC(5)
    jp i6502NextLoad

;    zeropage,X	DEC oper,X	D6	2	6  
inst6502_dec_zpx:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    dec a
    ld  (bc),a
    FLAGS_ZN
    ADDCYC(6)
    jp i6502NextLoad

;    absolute	DEC oper	CE	3	6  
inst6502_dec_abs:
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        dec a
        ld  b,a
        ;
        ld  a,(ix+REGSR)
        res SF_ZERO,a
        jr  nz,$+4
        set SF_ZERO,a
        res SF_NEG,a
        jp  p,$+6
        set SF_NEG,a
        ld  (ix+REGSR),a
        ;
        WRITE_ACCESS
        ADDCYC(6)
    pop hl
    jp i6502NextLoad

;    absolute,X	DEC oper,X	DE	3	7  
inst6502_dec_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        dec a
        ld  b,a
        ;
        ld  a,(ix+REGSR)
        res SF_ZERO,a
        jr  nz,$+4
        set SF_ZERO,a
        res SF_NEG,a
        jp  p,$+6
        set SF_NEG,a
        ld  (ix+REGSR),a
        ;
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;DEX - Decrement Index X by One [X - 1 -> X]
;Flags altered: NZ
;implied	DEX	CA	1	2  
inst6502_dex:
    dec (ix+REGX)
_:  ld  a,(ix+REGSR)
    res SF_ZERO,a
    jr  nz,$+4
    set SF_ZERO,a
    res SF_NEG,a
    jp  p,$+6
    set SF_NEG,a
    ld  (ix+REGSR),a
    ADDCYC(2)
    jp i6502FinishLoad

;DEY - Decrement Index Y by One [Y - 1 -> Y]
;Flags altered: NZ
;implied	DEY	88	1	2  
inst6502_dey:
    dec (ix+REGY)
    jr  -_


;INX - Increment Index X by One [X + 1 -> X]
;Flags altered: NZ
;implied	INX	E8	1	2  
inst6502_inx:
    inc (ix+REGX)
    jr  -_


;INY - Increment Index Y by One [Y + 1 -> Y]
;Flags altered: NZ
;implied	INY	C8	1	2  
inst6502_iny:
    inc (ix+REGY)
    jr  -_


;INC - Increment Memory by One
;    M + 1 -> M
;    N	Z	C	I	D	V
;    +	+	-	-	-	-

;zeropage	INC oper	E6	2	5  
inst6502_inc_zp:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    inc a
    ld  (bc),a
    FLAGS_ZN
    ADDCYC(5)
    jp i6502NextLoad

;zeropage,X	INC oper,X	F6	2	6  
inst6502_inc_zpx:
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    inc a
    ld  (bc),a
    FLAGS_ZN
    ADDCYC(6)
    jp i6502NextLoad
    
;absolute	INC oper	EE	3	6
inst6502_inc_abs:
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        inc a
        ld  b,a
        ;
        ld  a,(ix+REGSR)
        res SF_ZERO,a
        jr  nz,$+4
        set SF_ZERO,a
        res SF_NEG,a
        jp  p,$+6
        set SF_NEG,a
        ld  (ix+REGSR),a
        ;
        WRITE_ACCESS
        ADDCYC(6)
    pop hl
    jp i6502NextLoad

;absolute,X	INC oper,X	FE	3	7  
inst6502_inc_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        inc a
        ld  b,a
        ;
        ld  a,(ix+REGSR)
        res SF_ZERO,a
        jr  nz,$+4
        set SF_ZERO,a
        res SF_NEG,a
        jp  p,$+6
        set SF_NEG,a
        ld  (ix+REGSR),a
        ;
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Arithmetic Operations
;ADC - Add Memory to Accumulator with Carry  [A + M + C -> A, C]
;    N	Z	C	I	D	V
;    +	+	+	-	-	+
;addressing	assembler	opc	bytes	cycles

;immediate	ADC #oper	69	2	2  
inst6502_adc_imm:
    ADDCYC(2)
    ld  c,(hl)
    jp  subroutine6502_adc_combined_end
    

;zeropage	ADC oper	65	2	3
inst6502_adc_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  c,a
    jp  subroutine6502_adc_combined_end

;zeropage,X	ADC oper,X	75	2	4  
inst6502_adc_zpx:
    ADDCYC(4)
    ld  a,(hl)
    add a,(ix+REGX)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  c,a
    jp  subroutine6502_adc_combined_end

;absolute	ADC oper	6D	3	4  
inst6502_adc_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_adc_combined_end

;absolute,X	ADC oper,X	7D	3	4* 
inst6502_adc_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_adc_combined_end

;absolute,Y	ADC oper,Y	79	3	4*
inst6502_adc_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_adc_combined_end

;(indirect,X)	ADC (oper,X)	61	2	6  
inst6502_adc_indx:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_adc_combined_end

;(indirect),Y	ADC (oper),Y	71	2	5* 
inst6502_adc_indy:
    ADDCYC(5)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        ADDCYC(1)
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_adc_combined_end


;SBC - Subtract Memory from Accumulator with Borrow
;A - M - CÌ… -> A
;N	Z	C	I	D	V
;+	+	+	-	-	+
;addressing	assembler	opc	bytes	cycles

;immediate	SBC #oper	E9	2	2  
inst6502_sbc_imm:
    ADDCYC(2)
    ld  c,(hl)
    jp  subroutine6502_sbc_combined_end

;zeropage	SBC oper	E5	2	3  
inst6502_sbc_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  c,a
    jp  subroutine6502_sbc_combined_end

;zeropage,X	SBC oper,X	F5	2	4  
inst6502_sbc_zpx:
    ADDCYC(4)
    ld  a,(hl)
    add a,(ix+REGX)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  c,a
    jp  subroutine6502_sbc_combined_end

;absolute	SBC oper	ED	3	4  
inst6502_sbc_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_sbc_combined_end

;absolute,X	SBC oper,X	FD	3	4* 
inst6502_sbc_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_sbc_combined_end

;absolute,Y	SBC oper,Y	F9	3	4* 
inst6502_sbc_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_sbc_combined_end

;(indirect,X)	SBC (oper,X)	E1	2	6  
inst6502_sbc_indx:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_sbc_combined_end

;(indirect),Y	SBC (oper),Y	F1	2	5* 
inst6502_sbc_indy:
    ADDCYC(5)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        ADDCYC(1)
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
    pop hl
    ld  c,a
    jp  subroutine6502_sbc_combined_end



;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Logical Operations

;AND - AND Memory with Accumulator
;A AND M -> A
;N	Z	C	I	D	V
;+	+	-	-	-	-
;addressing	assembler	opc	bytes	cycles

;immediate	AND #oper	29	2	2  
inst6502_and_imm:
    ADDCYC(2)
    ld  a,(hl)
    and a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;zeropage	AND oper	25	2	3  
inst6502_and_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    and a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;zeropage,X	AND oper,X	35	2	4  
inst6502_and_zpx:
    ADDCYC(4)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    and a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;absolute	AND oper	2D	3	4  
inst6502_and_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
    pop hl
    and a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;absolute,X	AND oper,X	3D	3	4* 
inst6502_and_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
        and a,(ix+REGA)
        ld  (ix+REGA),A
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;absolute,Y	AND oper,Y	39	3	4* 
inst6502_and_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
    pop hl
    and a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;(indirect,X)	AND (oper,X)	21	2	6  
inst6502_and_indx:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
    pop hl
    and a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;(indirect),Y	AND (oper),Y	31	2	5* 
inst6502_and_indy:
    ADDCYC(5)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
        ADDCYC(1)
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
    pop hl
    and a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;EOR - Exclusive-OR Memory with Accumulator
;A EOR M -> A
;N	Z	C	I	D	V
;+	+	-	-	-	-
;addressing	assembler	opc	bytes	cycles

;immediate	EOR #oper	49	2	2  
inst6502_eor_imm:
    ADDCYC(2)
    ld  a,(hl)
    xor a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;zeropage	EOR oper	45	2	3  
inst6502_eor_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    xor a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad


;zeropage,X	EOR oper,X	55	2	4  
inst6502_eor_zpx:
    ADDCYC(4)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    xor a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;absolute	EOR oper	4D	3	4  
inst6502_eor_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
    pop hl
    xor a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;absolute,X	EOR oper,X	5D	3	4* 
inst6502_eor_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
        xor a,(ix+REGA)
        ld  (ix+REGA),A
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;absolute,Y	EOR oper,Y	59	3	4* 
inst6502_eor_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
    pop hl
    xor a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;(indirect,X)	EOR (oper,X)	41	2	6  
inst6502_eor_indx:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
    pop hl
    xor a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;(indirect),Y	EOR (oper),Y	51	2	5* 
inst6502_eor_indy:
    ADDCYC(5)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
        ADDCYC(1)
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
    pop hl
    xor a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;ORA - OR Memory with Accumulator
;A OR M -> A
;N	Z	C	I	D	V
;+	+	-	-	-	-
;addressing	assembler	opc	bytes	cycles

;immediate	ORA #oper	09	2	2  
inst6502_ora_imm:
    ADDCYC(2)
    ld  a,(hl)
    or  a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;zeropage	ORA oper	05	2	3  
inst6502_ora_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    or  a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;zeropage,X	ORA oper,X	15	2	4  
inst6502_ora_zpx:
    ADDCYC(4)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    or  a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;absolute	ORA oper	0D	3	4  
inst6502_ora_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
    pop hl
    or  a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;absolute,X	ORA oper,X	1D	3	4* 
inst6502_ora_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
        or  a,(ix+REGA)
        ld  (ix+REGA),A
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;absolute,Y	ORA oper,Y	19	3	4* 
inst6502_ora_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
    pop hl
    or  a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;(indirect,X)	ORA (oper,X)	01	2	6  
inst6502_ora_indx:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
    pop hl
    or  a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;(indirect),Y	ORA (oper),Y	11	2	5* 
inst6502_ora_indy:
    ADDCYC(5)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
        ADDCYC(1)
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
    pop hl
    or  a,(ix+REGA)
    ld  (ix+REGA),A
    FLAGS_ZN
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Shift & Rotate Instructions
;ASL - Shift Left One Bit (Memory or Accumulator)
;C <- [76543210] <- 0
;N	Z	C	I	D	V
;+	+	+	-	-	-
;addressing	assembler	opc	bytes	cycles

;accumulator	ASL A	0A	1	2  
inst6502_asl:
    ADDCYC(2)
    ld  a,(ix+REGA)
    sla a
    ld  (ix+REGA),a
    FLAGS_CZN
    jp i6502FinishLoad

;zeropage	ASL oper	06	2	5  
inst6502_asl_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    sla a
    ld  (bc),a
    FLAGS_CZN
    jp i6502NextLoad

;zeropage,X	ASL oper,X	16	2	6  
inst6502_asl_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    sla a
    ld  (bc),a
    FLAGS_CZN
    jp i6502NextLoad

;absolute	ASL oper	0E	3	6  
inst6502_asl_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        sla a
        ld  c,a
        FLAGS_CZN
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolute,X	ASL oper,X	1E	3	7  
inst6502_asl_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        sla a
        ld  c,a
        FLAGS_CZN
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;LSR - Shift One Bit Right (Memory or Accumulator)
;0 -> [76543210] -> C
;N	Z	C	I	D	V
;0	+	+	-	-	-
;addressing	assembler	opc	bytes	cycles

;accumulator	LSR A	4A	1	2  
inst6502_lsr:
    ADDCYC(2)
    ld  a,(ix+REGA)
    srl a
    ld  (ix+REGA),a
    FLAGS_CZN
    jp i6502FinishLoad

;zeropage	LSR oper	46	2	5  
inst6502_lsr_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    srl a
    ld  (bc),a
    FLAGS_CZN
    jp i6502NextLoad

;zeropage,X	LSR oper,X	56	2	6  
inst6502_lsr_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    srl a
    ld  (bc),a
    FLAGS_CZN
    jp i6502NextLoad
    
;absolute	LSR oper	4E	3	6  
inst6502_lsr_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        srl a
        ld  c,a
        FLAGS_CZN
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolute,X	LSR oper,X	5E	3	7  
inst6502_lsr_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        srl a
        ld  c,a
        FLAGS_CZN
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;ROL - Rotate One Bit Left (Memory or Accumulator)
;C <- [76543210] <- C
;N	Z	C	I	D	V
;+	+	+	-	-	-
;addressing	assembler	opc	bytes	cycles

;accumulator	ROL A	2A	1	2  
inst6502_rol:
    ADDCYC(2)
    ld  a,(ix+REGSR)
    rra
    rl  (ix+REGA)
    ld  a,(ix+REGA)
    FLAGS_CZN
    jp i6502FinishLoad

;zeropage	ROL oper	26	2	5  
inst6502_rol_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(ix+REGSR)
    rra
    ld  a,(bc)
    rla
    ld  (bc),a
    FLAGS_CZN
    jp i6502NextLoad

;zeropage,X	ROL oper,X	36	2	6  
inst6502_rol_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(ix+REGSR)
    rra
    ld  a,(bc)
    rla
    ld  (bc),a
    FLAGS_CZN
    jp i6502NextLoad

;absolute	ROL oper	2E	3	6  
inst6502_rol_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rla
        ld  c,a
        FLAGS_CZN
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolute,X	ROL oper,X	3E	3	7  
inst6502_rol_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rla
        ld  c,a
        FLAGS_CZN
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;ROR - Rotate One Bit Right (Memory or Accumulator)
;C -> [76543210] -> C
;N	Z	C	I	D	V
;+	+	+	-	-	-
;addressing	assembler	opc	bytes	cycles

;accumulator	ROR A	6A	1	2  
inst6502_ror:
    ADDCYC(2)
    ld  a,(ix+REGSR)
    rra
    rr  (ix+REGA)
    ld  a,(ix+REGA)
    FLAGS_CZN
    jp i6502FinishLoad

;zeropage	ROR oper	66	2	5  
inst6502_ror_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(ix+REGSR)
    rra
    ld  a,(bc)
    rra
    ld  (bc),a
    FLAGS_CZN
    jp i6502NextLoad

;zeropage,X	ROR oper,X	76	2	6  
inst6502_ror_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(ix+REGSR)
    rra
    ld  a,(bc)
    rra
    ld  (bc),a
    FLAGS_CZN
    jp i6502NextLoad

;absolute	ROR oper	6E	3	6  
inst6502_ror_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rra
        ld  c,a
        FLAGS_CZN
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolute,X	ROR oper,X	7E	3	7  
inst6502_ror_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rra
        ld  c,a
        FLAGS_CZN
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Flag Instructions

;CLC - Clear Carry Flag
;0 -> C
;N	Z	C	I	D	V
;-	-	0	-	-	-
;addressing	assembler	opc	bytes	cycles
;implied	CLC	18	1	2  
inst6502_clc:
    ADDCYC(2)
    res SF_CARRY,(ix+REGSR)
    jp  i6502FinishLoad

;CLD - Clear Decimal Mode
;0 -> D
;N	Z	C	I	D	V
;-	-	-	-	0	-
;addressing	assembler	opc	bytes	cycles
;implied	CLD	D8	1	2  
inst6502_cld:
    ADDCYC(2)
    res SF_DEC,(ix+REGSR)
    jp  i6502FinishLoad

;CLI -  Clear Interrupt Disable Bit
;0 -> I
;N	Z	C	I	D	V
;-	-	-	0	-	-
;addressing	assembler	opc	bytes	cycles
;implied	CLI	58	1	2  
inst6502_cli:
    ADDCYC(2)
    res SF_INT,(ix+REGSR)
    jp  i6502FinishLoad

;CLV - Clear Overflow Flag
;0 -> V
;N	Z	C	I	D	V
;-	-	-	-	-	0
;addressing	assembler	opc	bytes	cycles
;implied	CLV	B8	1	2  
inst6502_clv:
    ADDCYC(2)
    res SF_OVER,(ix+REGSR)
    jp  i6502FinishLoad

;SEC - Set Carry Flag
;1 -> C
;N	Z	C	I	D	V
;-	-	1	-	-	-
;addressing	assembler	opc	bytes	cycles
;implied	SEC	38	1	2  
inst6502_sec:
    ADDCYC(2)
    set SF_CARRY,(ix+REGSR)
    jp  i6502FinishLoad

;SED - Set Decimal Flag
;1 -> D
;N	Z	C	I	D	V
;-	-	-	-	1	-
;addressing	assembler	opc	bytes	cycles
;implied	SED	F8	1	2  
inst6502_sed:
    ADDCYC(2)
    set SF_DEC,(ix+REGSR)
    jp  i6502FinishLoad

;SEI - Set Interrupt Disable Status
;1 -> I
;N	Z	C	I	D	V
;-	-	-	1	-	-
;addressing	assembler	opc	bytes	cycles
;implied	SEI	78	1	2  
inst6502_sei:
    ADDCYC(2)
    set SF_INT,(ix+REGSR)
    jp  i6502FinishLoad

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Comparisons

;CMP - Compare Memory with Accumulator
;A - M
;N	Z	C	I	D	V
;+	+	+	-	-	-
;addressing	assembler	opc	bytes	cycles

;immediate	CMP #oper	C9	2	2  
inst6502_cmp_imm:
    ADDCYC(2)
    ld  b,(hl)
    jp  subroutine6502_cmp_combined_end

;zeropage	CMP oper	C5	2	3  
inst6502_cmp_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;zeropage,X	CMP oper,X	D5	2	4  
inst6502_cmp_zpx:
    ADDCYC(4)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;absolute	CMP oper	CD	3	4  
inst6502_cmp_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
    pop hl
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;absolute,X	CMP oper,X	DD	3	4* 
inst6502_cmp_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
    pop hl
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;absolute,Y	CMP oper,Y	D9	3	4* 
inst6502_cmp_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
    pop hl
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;(indirect,X)	CMP (oper,X)	C1	2	6  
inst6502_cmp_indx:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
    pop hl
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;(indirect),Y	CMP (oper),Y	D1	2	5* 
inst6502_cmp_indy:
    ADDCYC(5)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
        ADDCYC(1)
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
    pop hl
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;-----------------------------------------------------------------------------
;CPX - Compare Memory and Index X
;X - M
;N	Z	C	I	D	V
;+	+	+	-	-	-
;addressing	assembler	opc	bytes	cycles
;immediate	CPX #oper	E0	2	2  
inst6502_cpx_imm:
    ADDCYC(2)
    ld  a,(ix+REGX)
    sub a,(hl)
    ccf     ;because the 6502 is strange like that.
    FLAGS_CZN
    jp  i6502NextLoad

;zeropage	CPX oper	E4	2	3  
inst6502_cpx_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  b,a
    ld  a,(ix+REGX)
    sub a,b
    ccf     ;because the 6502 is strange like that.
    FLAGS_CZN
    jp i6502NextLoad
;absolute	CPX oper	EC	3	4  
inst6502_cpx_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
    pop hl
    ld  b,a
    ld  a,(ix+REGX)
    sub a,b
    ccf     ;because the 6502 is strange like that.
    FLAGS_CZN
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;CPY - Compare Memory and Index Y
;Y - M
;N	Z	C	I	D	V
;+	+	+	-	-	-
;addressing	assembler	opc	bytes	cycles
;immediate	CPY #oper	C0	2	2  
inst6502_cpy_imm:
    ADDCYC(2)
    ld  a,(ix+REGY)
    sub a,(hl)
    ccf
    FLAGS_CZN
    jp  i6502NextLoad

;zeropage	CPY oper	C4	2	3  
inst6502_cpy_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  b,a
    ld  a,(ix+REGY)
    sub a,b
    ccf     ;because the 6502 is strange like that.
    FLAGS_CZN
    jp i6502NextLoad

;absolute	CPY oper	CC	3	4  
inst6502_cpy_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
    pop hl
    ld  b,a
    ld  a,(ix+REGY)
    sub a,b
    ccf     ;because the 6502 is strange like that.
    FLAGS_CZN
    jp i6502NextLoad


;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Conditional Branch Instructions

;branch on C=0
;relative	BCC oper	90	2	2**
inst6502_bcc:
    ADDCYC(2)
    bit SF_CARRY,(ix+REGSR)
    jp  nz,i6502NextLoad
    jp  subroutine6502_take_branch

;branch on C=1
;relative	BCS oper	B0	2	2**
inst6502_bcs:
    ADDCYC(2)
    bit SF_CARRY,(ix+REGSR)
    jp  z,i6502NextLoad
    jp  subroutine6502_take_branch

;branch on Z=1
;relative	BEQ oper	F0	2	2**
inst6502_beq:
    ADDCYC(2)
    bit SF_ZERO,(ix+REGSR)
    jp  z,i6502NextLoad
    jp  subroutine6502_take_branch

;branch on N=1
;relative	BMI oper	30	2	2**
inst6502_bmi:
    ADDCYC(2)
    bit SF_NEG,(ix+REGSR)
    jp  z,i6502NextLoad
    jp  subroutine6502_take_branch


;branch on Z=0
;relative	BNE oper	D0	2	2**
inst6502_bne:
    ADDCYC(2)
    bit SF_ZERO,(ix+REGSR)
    jp  nz,i6502NextLoad
    jp  subroutine6502_take_branch

;branch on N=0
;relative	BPL oper	10	2	2**
inst6502_bpl:
    ADDCYC(2)
    bit SF_NEG,(ix+REGSR)
    jp  nz,i6502NextLoad
    jp  subroutine6502_take_branch

;branch on V=0
;relative	BVC oper	50	2	2**
inst6502_bvc:
    ADDCYC(2)
    bit SF_OVER,(ix+REGSR)
    jp  nz,i6502NextLoad
    jp  subroutine6502_take_branch

;branch on V=1
;relative	BVS oper	70	2	2**
inst6502_bvs:
    ADDCYC(2)
    bit SF_OVER,(ix+REGSR)
    jp  z,i6502NextLoad
    jp  subroutine6502_take_branch

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Interrupts

;BRK - Force Break
;BRK initiates a software interrupt similar to a hardware
;interrupt (IRQ). The return address pushed to the stack is
;PC+2, providing an extra byte of spacing for a break mark
;(identifying a reason for the break.)
;The status register will be pushed to the stack with the break
;flag set to 1. However, when retrieved during RTI or by a PLP
;instruction, the break flag will be ignored.
;The interrupt disable flag is not set automatically.
;
;interrupt,             N	Z	C	I	D	V
;push PC+2, push SR     -	-	-	1	-	-
;implied	BRK	00	1	7  
inst6502_brk:
    ADDCYC(7)
    ld  hl,STACKBASE
    ld  L,(ix+REGSP)
    ld.s de,(ix+REGPC)
    inc de      ;that extra spacer.
    ld  (hl),d
    dec L
    ld  (hl),e
    dec L
    ld  a,(ix+REGSR)
    set SF_INT,a
    ld  (hl),a
    dec L
    ld  (ix+REGSP),L
    WAS_NMI_TRIGGERED
    ld  bc,$FE  ;IRQ vector
    jr  z,+_
    ld  bc,$FA  ;NMI vector, if NMI is hijacking this instruction.
_:  ld  hl,(BASETABLE_STRIDE*$FF)+PAGETABLE
    ld  hl,(hl)
    add hl,bc
    ld  de,(hl)
    ld.s (ix+REGPC),de
    jp  i6502FirstLoad

;RTI - Return from Interrupt
;The status register is pulled with the break flag
;and bit 5 ignored. Then PC is pulled from the stack.
;pull SR, pull PC      N Z C I D V
;                      from stack
;implied	RTI	40	1	6  
inst6502_rti:
    ld  hl,STACKBASE
    ld  l,(ix+REGSP)
    inc l
    ld  a,(hl)
    inc l
    ld  e,(hl)
    inc l
    ld  d,(hl)
    ld  (ix+REGSP),l
    ld.s (ix+REGPC),de
    ld  b,(ix+REGSR)
    xor a,b
    and a,%11011111
    xor a,b
    ld  (ix+REGSR),a
    ADDCYC(6)
    jp  i6502FirstLoad



;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Jumps and Subroutines

;absolute	JMP oper	4C	3	3  
inst6052_jmp_abs:
    ld  a,(hl)
    inc hl
    inc e
    jr  nz,+_
    ld  d,(ix+REGPC+1)
    inc d
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl)
_:  ld  (ix+REGPC+0),a
    ld  a,(hl)
    ld  (ix+REGPC+1),a
    ADDCYC(3)
    jp i6502FirstLoad


;Note: In earlier 6502 implementations, cross-page reads on indirect is bugged.
;   The end effect would be that inst6502_jmp_indir_splitread would wrap around
;   to the start of the current page rather than try to read the next page.
;indirect	JMP (oper)	6C	3	5  
inst6502_jmp_indir:
    ADDCYC(5)
    ;Doing much the same as abs_split_start below, except with fewer things
    ;because we don't need to preserve any of the other stuff.
    ld  c,(hl)
    inc hl
    inc e
    jr  nz,+_
    ld  d,(ix+REGPC+1)
    inc d
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl)
_:  ld  b,(hl)
    ld  a,c
    inc c   ;check if there will be a split read.
    ld  c,BASETABLE_STRIDE  ;Flags not affected
    mlt bc                  ;Flags not affected
    ld  hl,PAGETABLE        ;Flags not affected
    jp  z,inst6502_jmp_indir_splitRead
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,a
    add hl,bc
    ld  hl,(hl)
    ld.s (ix+REGPC),hl
    jp  i6502FirstLoad
inst6502_jmp_indir_splitRead:
    add hl,bc
    ld  hl,(hl)
    ld  a,(hl)  ;high byte
    ld  bc,255
    add hl,bc
    ld  c,(hl)  ;low byte
    ld  b,a
    ld.s (ix+REGPC),bc
    jp  i6502FirstLoad





;absolute	JSR oper	20	3	6  
inst6502_jsr:
    ld  d,(ix+REGPC+1)
    ld  c,(hl)
    inc hl
    inc e
    jr  nz,+_
    inc d
    ld  a,d
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl)
    ld  d,a
    ld  e,0
_:  ld  b,(hl)
    ;push de to 6502stack
    ld  hl,STACKBASE
    ld  l,(ix+REGSP)
    ld  (hl),d
    dec l
    ld  (hl),e
    dec l
    ld  (ix+REGSP),l
    ld.s (ix+REGPC),bc
    ADDCYC(6)
    jp  i6502FirstLoad

;implied	RTS	60	1	6
inst6502_rts:
    ld  hl,STACKBASE
    ld  l,(ix+REGSP)
    inc l
    ld  e,(hl)
    inc l
    ld  d,(hl)
    ld  (ix+REGSP),l
    inc de
    ld.s (ix+REGPC),de
    ADDCYC(6)
    jp  i6502FirstLoad


;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;Instructions by type: Miscellaneous
;BIT - Test Bits in Memory with Accumulator
;
;bits 7 and 6 of operand are transfered to bit 7 and 6 of SR (N,V);
;the zero-flag is set according to the result of the operand AND
;the accumulator (set, if the result is zero, unset otherwise).
;This allows a quick check of a few bits at once without affecting
;any of the registers, other than the status register (SR).

;A AND M -> Z, M7 -> N, M6 -> V             N	Z	C	I	D	V
;                                           M7	+	-	-	-	M6
;addressing	assembler	opc	bytes	cycles
;zeropage	BIT oper	24	2	3  
inst6502_bit_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  c,a
_:  and a,(ix+REGA)
    ld  a,c     ;discard result, get bits from OPERANDs
    res SF_ZERO,a
    jr  nz,$+4
    set SF_ZERO,a
    ld  b,(ix+REGSR)    ;keep bits in flag other than NZ and V
    xor a,b
    and a,%11000010     ;1=keepA, 0=discardA,keepB
    xor a,b
    ld  (ix+REGSR),a
    jp  i6502NextLoad

;absolute	BIT oper	2C	3	4  
inst6502_bit_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld  c,a
    pop hl
    jr  -_    

;NOP - No Operation
;implied	NOP	EA	1	2  
inst6502_nop:
    ADDCYC(2)
    jp  i6502FinishLoad



;##############################################################################
;##############################################################################
;##############################################################################
;##-----#-#####-#####-----##---###---##-########-----#--##-##---#-----#----####
;####-###-#####-#####-#####-#####-###-#-##########-###--##-#-######-###-###-###
;####-###-#####-#####---###-##--#-----#-##########-###-#-#-##---###-###-----###
;####-###-#####-#####-#####-###-#-###-#-##########-###-##--#####-##-###-##-####
;##-----#-----#-----#-----##----#-###-#-----####-----#-##--#----###-###-###-#-#
;##############################################################################
;##############################################################################
;##############################################################################
;Instructions by type: Illegal Instructions

;NOP - No operations. All the no-operations. Even the ones that are linked
;to the machinery that operates an addressing mode, but does nothing with it.
;A whole lotta nothing.

;Bytes:1, Cycles:2, Opcodes: 1A, 3A, 5A, 7A, DA, FA
inst6502_nop_implied:
    ADDCYC(2)
    jp  i6502FinishLoad

;Bytes:2, Cycles:2, Opcodes: 80, 82, 89, C2, E2
inst6502_nop_imm:
    ADDCYC(2)
    jp  i6502NextLoad

;Bytes:2, Cycles:3, Opcodes: 04, 44, 64
inst6502_nop_zp:
    ADDCYC(3)
    jp  i6502NextLoad

;Bytes:2, Cycles:4, Opcodes: 14, 34, 54, 74, D4, F4
inst6502_nop_zpx:
    ADDCYC(4)
    jp  i6502NextLoad

;Bytes:3, Cycles:4, Opcode: 0C
inst6502_nop_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        READ_ACCESS
    pop hl
    jp  i6502NextLoad

;Note: This thing latches all over the place but does nothing. All these
;READ_ACCESS thingies are in case the ROM wants to clear PPU flags or something
;using these instructions. But the one below is noted to do the touchy-feelies
;at ABS and (ABS+X)&0xFF
;Bytes:3, Cycles:4*, Opcodes: 1C, 3C, 5C, 7C, DC, FC
inst6502_nop_absx:
    ADDCYC(4)
    PUSH_ABSXSPLIT
        READ_ACCESS
    pop hl
    jp  i6502NextLoad

;-----------------------------------------------------------------------------
;ALR (ASR) - AND oper + LSR
;Affects CZN

;immediate	ALR #oper	4B	2	2 
inst6502_alr_imm:
    ADDCYC(2)
    ld  a,(ix+REGA)
    and a,(hl)
    srl a   ;Must do it this way. A-optimized instr do not affect Z
    ld  (ix+REGA),a
    FLAGS_CZN
    jp  i6502NextLoad

;-----------------------------------------------------------------------------

;ANC [ANC (ANC2)] - AND oper + set Carry as if ASL [ROL]

;immediate	ANC #oper	0B	2	2 
;immediate	ANC #oper	2B	2	2
instr6502_anc_imm:
instr6502_anc2_imm:
    ADDCYC(2)
    ld  a,(ix+REGA)
    and a,(hl)
    ld  (ix+REGA),a
    rlc a
    ld  a,(ix+REGSR)
    ;A small optimiztion here, letting us merge OPRFLG_C and OPRFLG_N
    res SF_CARRY,a
    res SF_NEG,a
    jr  nc,+_
    set SF_CARRY,a
    set SF_NEG,a
_:  res SF_ZERO,a
    jr  nz,$+4
    set SF_ZERO,a
    ld  (ix+REGSR),a
    jp  i6502NextLoad

;-----------------------------------------------------------------------------

;ANE (XAA) - (A OR ??) AND X AND oper -> A
;immediate	ANE #oper	8B	2	2  	â€ â€ 
instr6502_ane_imm:
    ADDCYC(2)
    ld  a,r     ;?? HIGHLY UNSTABLE INSTRUCTION
    or  a,(ix+REGA)
    and a,(ix+REGX)
    and a,(hl)
    ld  (ix+REGA),a
    FLAGS_ZN
    jp  i6502NextLoad

;-----------------------------------------------------------------------------


;ARR - AND OPER + ROR
;Something hinky is going on with the flags. "This operation involves the adder"
;I need to get a better handle over what that might be.
;CVZN flags affected.
;
;Primary sources reads:
;----------------------
;This operation involves the adder:
;V-flag is set according to (A AND oper) + oper
;The carry is not set, but bit 7 (sign) is exchanged with the carry
;A AND oper, C -> [76543210] -> C
;
;Secondary source reads:
;-----------------------
;Similar to AND #i then ROR A, except sets the flags differently. 
;N and Z are normal, but C is bit 6 and V is bit 6 xor bit 5. 
;A fast way to perform signed division by 4 is: CMP #$80; ARR #$FF; ROR. 
;This can be extended to larger powers of two.

;immediate	ARR #oper	6B	2	2  
instr6502_arr_imm:
    ADDCYC(2)
    ld  a,(ix+REGA)
    and a,(hl)
    ld  b,a
    ld  a,(ix+REGSR)
    ld  c,a
    rrca    ;extract carry. This carry will go into sign bit of result
    res SF_NEG,c
    jr  nc,$+4
    set SF_NEG,c
    rr b
    res SF_ZERO,c
    jr  nz,$+4
    set SF_ZERO,c
    ld  (ix+REGA),b
    ld  a,b
    and a,%01000000
    res SF_CARRY,c
    jr  z,$+4
    set SF_CARRY,c
    rrca
    xor a,%00100000
    and a,%00100000
    res SF_OVER,c
    jr  z,$+4
    set SF_OVER,c
    ld  (ix+REGSR),c
    ;TODO: Figure out a more efficient way to emulate this instruction.
    jp  i6502NextLoad

;-----------------------------------------------------------------------------
;DCP (DCM) - DEC oper + CMP oper
;M-1->M, A-M. Affects CZN
;addressing	assembler	opc	bytes	cycles	

;zeropage	DCP oper	C7	2	5  	
inst6502_dcp_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    dec a
    ld  (bc),a
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;zeropage,X	DCP oper,X	D7	2	6  	
inst6520_dcp_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    dec a
    ld  (bc),a
    ld  b,a
    jp  subroutine6502_cmp_combined_end

;absolute	DCP oper	CF	3	6  	
inst6502_dcp_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        dec a
        ld b,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_cmp_combined_end

;absolut,X	DCP oper,X	DF	3	7  	
inst6502_dcp_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        dec a
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_cmp_combined_end

;absolut,Y	DCP oper,Y	DB	3	7  	
inst6502_dcp_absy:
    ADDCYC(7)
    PUSH_ABSYSPLIT_NODEP
        READ_ACCESS
        dec a
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_cmp_combined_end

;(indirect,X)	DCP (oper,X)	C3	2	8  	
inst6502_dcp_indx:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
        dec a
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_cmp_combined_end

;(indirect),Y	DCP (oper),Y	D3	2	8  
inst6502_dcp_indy:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        dec a
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_cmp_combined_end

;-----------------------------------------------------------------------------
;ISC (ISB, INS) - INC oper + SBC oper
;M+1->M, A-M-not(C)->A, affects VCZN
;addressing	assembler	opc	bytes	cycles	



;zeropage	ISC oper	E7	2	5  	
inst6502_isc_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    inc a
    ld  (bc),a
    ld  c,a
    jp  subroutine6502_sbc_combined_end

;zeropage,X	ISC oper,X	F7	2	6  
inst6520_isc_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    inc a
    ld  (bc),a
    ld  c,a
    jp  subroutine6502_sbc_combined_end

;absolute	ISC oper	EF	3	6  	
inst6502_isc_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        inc a
        ld b,a
        ld c,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_sbc_combined_end

;absolut,X	ISC oper,X	FF	3	7  	
inst6502_isc_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        inc a
        ld  b,a
        ld  c,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_sbc_combined_end

;absolut,Y	ISC oper,Y	FB	3	7  	
inst6502_isc_absy:
    ADDCYC(7)
    PUSH_ABSYSPLIT_NODEP
        READ_ACCESS
        inc a
        ld  b,a
        ld  c,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_sbc_combined_end

;(indirect,X)	ISC (oper,X)	E3	2	8  	
inst6502_isc_indx:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
        inc a
        ld  b,a
        ld  c,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_sbc_combined_end

;(indirect),Y	ISC (oper),Y	F3	2	8  
inst6502_isc_indy:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        inc a
        ld  b,a
        ld  c,a
        push bc
            WRITE_ACCESS
        pop bc
    pop hl
    jp  subroutine6502_sbc_combined_end
;-----------------------------------------------------------------------------
;LAS (LAR) - LDA/TSX oper
;M AND SP -> A, X, SP. Affects ZN
;addressing	assembler	opc	bytes	cycles	
;absolut,Y	LAS oper,Y	BB	3	4* 
inst6502_las_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
    pop hl
    and a,(ix+REGSP)
    ld  (ix+REGA),A
    ld  (ix+REGX),A
    ld  (ix+REGSP),A
    FLAGS_ZN
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;LAX - LDA oper + LDX oper
;M -> A -> X. Flags affected: ZN
;addressing	assembler	opc	bytes	cycles	
;zeropage	LAX oper	A7	2	3  	
inst6502_lax_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    ld  (ix+REGA),a
    ld  (ix+REGX),a
    FLAGS_ZN
    jp i6502NextLoad

;zeropage,Y	LAX oper,Y	B7	2	4  	
inst6502_lax_zpy:
    ADDCYC(4)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGY)
    ld  c,a
    ld  a,(bc)
    ld  (ix+REGA),a
    ld  (ix+REGX),a
    FLAGS_ZN
    jp i6502NextLoad

;absolute	LAX oper	AF	3	4  	
inst6502_lax_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld (ix+REGA),a
        ld (ix+REGX),a
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;absolut,Y	LAX oper,Y	BF	3	4* 	
inst6502_lax_absy:
    ADDCYC(4)
    PUSH_ABSYSPLIT
        READ_ACCESS
        ld (ix+REGA),a
        ld (ix+REGX),a
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;(indirect,X)	LAX (oper,X)	A3	2	6  	
inst6502_lax_indx:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
        ld (ix+REGA),a
        ld (ix+REGX),a
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;(indirect),Y	LAX (oper),Y	B3	2	5* 
inst6502_lax_indy:
    ADDCYC(5)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        ADDCYC(1)
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        ld  (ix+REGA),a
        ld  (ix+REGX),a
        FLAGS_ZN
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;LXA (LAX immediate)
;Store * AND oper in A and X
;Highly unstable, involves a 'magic' constant, see ANE
;(A OR CONST) AND oper -> A -> X
;immediate	LXA #oper	AB	2	2  	â€ â€ 
inst6502_lxa:
    ADDCYC(2)
    ld  a,r     ;?? HIGHLY UNSTABLE INSTRUCTION
    or  a,(ix+REGA)
    and a,(hl)
    ld  (ix+REGA),a
    ld  (ix+REGX),a
    FLAGS_ZN
    jp  i6502NextLoad

;-----------------------------------------------------------------------------
;RLA - ROL oper + AND oper
;M = C <- [76543210] <- C, A AND M -> A. flags CZN
;addressing	assembler	opc	bytes	cycles	
;zeropage	RLA oper	27	2	5  	
inst6502_rla_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(ix+REGSR)
    rra
    ld  a,(bc)
    rla
    ld  (bc),a
    ;Flag breakdown to optimize for split operation
    ld  b,(ix+REGSR)
    OPRFLG_C
    and a,(ix+REGA)
    ld  (ix+REGA),a
    OPRFLG_Z
    add a,a
    OPRFLG_N
    ld  (ix+REGSR),b
    jp i6502NextLoad

;zeropage,X	RLA oper,X	37	2	6  	
inst6502_rla_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(ix+REGSR)
    rra
    ld  a,(bc)
    rla
    ld  (bc),a
    ;Flag breakdown to optimize for split operation
    ld  b,(ix+REGSR)
    OPRFLG_C
    and a,(ix+REGA)
    ld  (ix+REGA),a
    OPRFLG_Z
    add a,a
    OPRFLG_N
    ld  (ix+REGSR),b
    jp i6502NextLoad

;absolute	RLA oper	2F	3	6  	
inst6502_rla_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rla
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        and a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolut,X	RLA oper,X	3F	3	7  	
inst6502_rla_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rla
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        and a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolut,Y	RLA oper,Y	3B	3	7  	
inst6502_rla_absy:
    ADDCYC(7)
    PUSH_ABSYSPLIT_NODEP
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rla
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        and a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;(indirect,X)	RLA (oper,X)	23	2	8  	
isnt6502_rla_indx:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rla
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        and a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp  i6502NextLoad

;(indirect),Y	RLA (oper),Y	33	2	8  
inst6502_rla_indy:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rla
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        and a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp  i6502NextLoad

;-----------------------------------------------------------------------------
;RRA
;ROR oper + ADC oper
;M = C -> [76543210] -> C, A + M + C -> A, C. Affects VCZN

;addressing	assembler	opc	bytes	cycles	
;zeropage	RRA oper	67	2	5  	
inst6502_rra_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(ix+REGSR)
    rra
    ld  a,(bc)
    rra
    ld  (bc),a
    res SF_CARRY,(ix+REGSR)
    jr nc,$+6
    set SF_CARRY,(ix+REGSR)
    ld  c,a
    jp  subroutine6502_adc_combined_end

;zeropage,X	RRA oper,X	77	2	6  	
inst6502_rra_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(ix+REGSR)
    rra
    ld  a,(bc)
    rra
    ld  (bc),a
    res SF_CARRY,(ix+REGSR)
    jr nc,$+6
    set SF_CARRY,(ix+REGSR)
    ld  c,a
    jp  subroutine6502_adc_combined_end

;absolute	RRA oper	6F	3	6  	
inst6502_rra_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rra
        res SF_CARRY,(ix+REGSR)
        jr nc,$+6
        set SF_CARRY,(ix+REGSR)
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
        ld c,b
    pop hl
    jp  subroutine6502_adc_combined_end

;absolut,X	RRA oper,X	7F	3	7  	
inst6502_rra_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rra
        res SF_CARRY,(ix+REGSR)
        jr nc,$+6
        set SF_CARRY,(ix+REGSR)
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
        ld c,b
    pop hl
    jp  subroutine6502_adc_combined_end

;absolut,Y	RRA oper,Y	7B	3	7  	
inst6502_rra_absy:
    ADDCYC(7)
    PUSH_ABSYSPLIT_NODEP
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rra
        res SF_CARRY,(ix+REGSR)
        jr nc,$+6
        set SF_CARRY,(ix+REGSR)
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
        ld c,b
    pop hl
    jp  subroutine6502_adc_combined_end

;(indirect,X)	RRA (oper,X)	63	2	8  	
isnt6502_rra_indx:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rra
        res SF_CARRY,(ix+REGSR)
        jr nc,$+6
        set SF_CARRY,(ix+REGSR)
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
        ld c,b
    pop hl
    jp  subroutine6502_adc_combined_end

;(indirect),Y	RRA (oper),Y	73	2	8  
inst6502_rra_indy:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        ld  b,(ix+REGSR)
        rr b
        rra
        res SF_CARRY,(ix+REGSR)
        jr nc,$+6
        set SF_CARRY,(ix+REGSR)
        ld  b,a
        push bc
            WRITE_ACCESS
        pop bc
        ld c,b
    pop hl
    jp  subroutine6502_adc_combined_end

;-----------------------------------------------------------------------------
;SAX (AXS, AAX) - A AND X -> M
;A and X are put on the bus at the same time (resulting effectively in an 
;AND operation) and stored in M. Flags not affected.
;addressing	assembler	opc	bytes	cycles	
;zeropage	SAX oper	87	2	3  	
inst6502_sax_zp:
    ADDCYC(3)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(ix+REGA)
    and a,(ix+REGX)
    ld  (bc),a
    jp i6502NextLoad


;zeropage,Y	SAX oper,Y	97	2	4  	
inst6502_sax_zpy:
    ADDCYC(4)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGY)
    ld  c,a
    ld  a,(ix+REGA)
    and a,(ix+REGX)
    ld  (bc),a
    jp i6502NextLoad


;absolute	SAX oper	8F	3	4  	
inst6502_sax_abs:
    ADDCYC(4)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        ld  a,(ix+REGA)
        and a,(ix+REGX)
        ld  b,a
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;(indirect,X)	SAX (oper,X)	83	2	6  
inst6502_sax_indx:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        ld  a,(ix+REGA)
        and a,(ix+REGX)
        ld  b,a
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;SBX (AXS, SAX) - CMP and DEX at once, sets flags like CMP
;(A AND X) - oper -> X.  Flags affected: CZN
;addressing	assembler	opc	bytes	cycles	
;immediate	SBX #oper	CB	2	2  
inst6502_sbx_imm:
    ld  a,(ix+REGA)
    and a,(ix+REGX)
    sub a,(hl)
    ld  (ix+REGX),a
    ccf
    FLAGS_CZN
    jp  i6502NextLoad

;-----------------------------------------------------------------------------
;SHA (AHX, AXA) - Stores A AND X AND (high-byte of addr. + 1) at addr.
;unstable: sometimes 'AND (H+1)' is dropped, 
;page boundary crossings may not work 
;(with the high-byte of the value used as the high-byte of the address)
;A AND X AND (H+1) -> M
;addressing	assembler	opc	bytes	cycles	
;
;NOTE: NOT GOING TO IMPLEMENT THESE. THEY'LL ADVANCE THE 6502 PC IN THE CORRECT
;MANNER BUT NOTHING MORE. THE CPU WILL HALT WHEN ENCOUNTERING ONE OF THESE.
;
;absolut,Y	SHA oper,Y	9F	3	5  	â€ 
inst6502_sha_absy:
    ADDCYC(5)
    PUSH_ABSYSPLIT
        jr $
    pop hl
    jp i6502NextLoad

;(indirect),Y	SHA (oper),Y	93	2	6  	â€ 
inst6502_sha_indy:
    ADDCYC(6)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        jr $
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;SHX (A11, SXA, XAS)
;SHY (A11, SYA, SAY)
;TAS (XAS, SHS)
;Not going to implement these, but they'll still get the program
;counter to make the correct noises. Right before locking up the core.
;All of these instructions are marked as "unstable" in that they'll sometimes
;drop the high byte, and page crossings sometimes won't work.

;absolut,Y	SHX oper,Y	9E	3	5  	â€ 
inst6502_shx_absy:
    ADDCYC(5)
    PUSH_ABSYSPLIT_NODEP
        jr $
    pop hl
    jp i6502NextLoad

;absolut,X	SHY oper,X	9C	3	5  	â€ 
inst6502_shy_absx:
    ADDCYC(5)
    PUSH_ABSXSPLIT_NODEP
        jr $
    pop hl
    jp i6502NextLoad

;absolut,Y	TAS oper,Y	9B	3	5  	â€ 
inst6502_tas_absy:
    ADDCYC(5)
    PUSH_ABSYSPLIT_NODEP
        jr $
    pop hl
    jp i6502NextLoad

;-----------------------------------------------------------------------------
;SLO (ASO) - ASL oper + ORA oper
;M = C <- [76543210] <- 0, A OR M -> A. Affects: CZN
;addressing	assembler	opc	bytes	cycles	

;zeropage	SLO oper	07	2	5  	
inst6502_slo_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    sla a
    ld  (bc),a
    ;Flag breakdown to optimize for split operation
    ld  b,(ix+REGSR)
    OPRFLG_C
    or  a,(ix+REGA)
    ld  (ix+REGA),a
    OPRFLG_Z
    add a,a
    OPRFLG_N
    ld  (ix+REGSR),b
    jp i6502NextLoad

;zeropage,X	SLO oper,X	17	2	6  	
inst6502_slo_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    sla a
    ld  (bc),a
    ;Flag breakdown to optimize for split operation
    ld  b,(ix+REGSR)
    OPRFLG_C
    or  a,(ix+REGA)
    ld  (ix+REGA),a
    OPRFLG_Z
    add a,a
    OPRFLG_N
    ld  (ix+REGSR),b
    jp i6502NextLoad

;absolute	SLO oper	0F	3	6  	
inst6502_slo_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        sla a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        or  a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolut,X	SLO oper,X	1F	3	7  	
inst6502_slo_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        sla a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        or  a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolut,Y	SLO oper,Y	1B	3	7  	
inst6502_slo_absy:
    ADDCYC(7)
    PUSH_ABSYSPLIT_NODEP
        READ_ACCESS
        sla a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        or  a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;(indirect,X)	SLO (oper,X)	03	2	8  	
isnt6502_slo_indx:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
        sla a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        or  a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp  i6502NextLoad

;(indirect),Y	SLO (oper),Y	13	2	8  
inst6502_slo_indy:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        sla a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        or  a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp  i6502NextLoad

;-----------------------------------------------------------------------------
;SRE (LSE) - LSR oper + EOR oper
;M = 0 -> [76543210] -> C, A EOR M -> A. Affects: CZN
;addressing	assembler	opc	bytes	cycles	

;zeropage	SRE oper	47	2	5  	
inst6502_sre_zp:
    ADDCYC(5)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    ld  c,a
    ld  a,(bc)
    srl a
    ld  (bc),a
    ;Flag breakdown to optimize for split operation
    ld  b,(ix+REGSR)
    OPRFLG_C
    xor a,(ix+REGA)
    ld  (ix+REGA),a
    OPRFLG_Z
    add a,a
    OPRFLG_N
    ld  (ix+REGSR),b
    jp i6502NextLoad

;zeropage,X	SRE oper,X	57	2	6  	
inst6502_sre_zpx:
    ADDCYC(6)
    ld  a,(hl)
    ld  bc,ZEROPAGE
    add a,c
    add a,(ix+REGX)
    ld  c,a
    ld  a,(bc)
    srl a
    ld  (bc),a
    ;Flag breakdown to optimize for split operation
    ld  b,(ix+REGSR)
    OPRFLG_C
    xor a,(ix+REGA)
    ld  (ix+REGA),a
    OPRFLG_Z
    add a,a
    OPRFLG_N
    ld  (ix+REGSR),b
    jp i6502NextLoad

;absolute	SRE oper	4F	3	6  	
inst6502_sre_abs:
    ADDCYC(6)
    call subroutine6502_abs_split_start
    push hl
        ld  d,b
        ld  a,c
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc   ;full address
        READ_ACCESS
        srl a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        xor a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolut,X	SRE oper,X	5F	3	7  	
inst6502_sre_absx:
    ADDCYC(7)
    PUSH_ABSXSPLIT_NODEP
        READ_ACCESS
        srl a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        xor a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;absolut,Y	SRE oper,Y	5B	3	7  	
inst6502_sre_absy:
    ADDCYC(7)
    PUSH_ABSYSPLIT_NODEP
        READ_ACCESS
        srl a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        xor a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp i6502NextLoad

;(indirect,X)	SRE (oper,X)	43	2	8  	
isnt6502_sre_indx:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        add a,(ix+REGX)
        ld  L,a
        ld  a,(hl)
        inc L
        ld  d,(hl)
        ld  b,d
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,PAGETABLE
        add hl,bc
        ld  hl,(hl)
        ld  b,0
        ld  c,a
        add hl,bc
        READ_ACCESS
        srl a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        xor a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp  i6502NextLoad

;(indirect),Y	SRE (oper),Y	53	2	8  
inst6502_sre_indy:
    ADDCYC(8)
    push hl
        ld  a,(hl)
        ld  hl,ZEROPAGE
        add a,L
        ld  L,a
        ld  a,(hl)      ;LSB. Keep in A for now.
        inc L
        add a,(ix+REGY)    ;Adjust LSB for post-idx
        ld  h,(hl)      ;Retrieve MSB.
        jr  nc,+_       ;Skip MSB/CC adjust if addition did not carry.
        inc h
_:      ld  d,h         ;save MSB of read address for access controls
        ld  L,BASETABLE_STRIDE
        mlt hl          ;23.
        ld  bc,PAGETABLE
        add hl,bc
        ld  hl,(hl)     ;address get.
        ld  bc,0
        ld  c,a
        add hl,bc       ;Full address get.
        READ_ACCESS
        srl a
        ld  c,a ;save the result of the rotation. This is written back to mem.
        ;Split oper
        ld  b,(ix+REGSR)
        OPRFLG_C
        xor a,(ix+REGA)
        ld  (ix+REGA),a
        OPRFLG_Z
        add a,a
        OPRFLG_N
        ld  (ix+REGSR),b
        ld  b,c
        WRITE_ACCESS
    pop hl
    jp  i6502NextLoad

;-----------------------------------------------------------------------------
;USBC (USBC)
;immediate	USBC #oper	EB	2	2  
;Map this to instruction $E9 (inst6502_sbc_imm)

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------

inst6502_instruction_set:
.dl	inst6502_brk					;00
.dl	inst6502_ora_indx				;01
.dl	inst6502_jam_02 				;02
.dl	isnt6502_slo_indx				;03
.dl	inst6502_nop_zp 				;04
.dl	inst6502_ora_zp					;05
.dl	inst6502_asl_zp					;06
.dl	inst6502_slo_zp 				;07
.dl	inst6502_php					;08
.dl	inst6502_ora_imm				;09
.dl	inst6502_asl					;0A
.dl	instr6502_anc_imm				;0B
.dl	inst6502_nop_abs				;0C
.dl	inst6502_ora_abs				;0D
.dl	inst6502_asl_abs				;0E
.dl	inst6502_slo_abs				;0F
.dl	inst6502_bpl					;10
.dl	inst6502_ora_indy				;11
.dl	inst6502_jam_12_halt			;12 JAM. Used to halt emulation for inspection
.dl	inst6502_slo_indy				;13
.dl	inst6502_nop_zpx				;14
.dl	inst6502_ora_zpx				;15
.dl	inst6502_asl_zpx				;16
.dl	inst6502_slo_zpx				;17
.dl	inst6502_clc					;18
.dl	inst6502_ora_absy				;19
.dl	inst6502_nop_implied    		;1A
.dl	inst6502_slo_absy				;1B
.dl	inst6502_nop_absx				;1C
.dl	inst6502_ora_absx				;1D
.dl	inst6502_asl_absx				;1E
.dl	inst6502_slo_absx				;1F
.dl	inst6502_jsr					;20
.dl	inst6502_and_indx				;21
.dl	inst6502_jam_22 				;22
.dl	isnt6502_rla_indx				;23
.dl	inst6502_bit_zp					;24
.dl	inst6502_and_zp					;25
.dl	inst6502_rol_zp					;26
.dl	inst6502_rla_zp 				;27
.dl	inst6502_plp					;28
.dl	inst6502_and_imm				;29
.dl	inst6502_rol					;2A
.dl	instr6502_anc2_imm				;2B
.dl	inst6502_bit_abs				;2C
.dl	inst6502_and_abs				;2D
.dl	inst6502_rol_abs				;2E
.dl	inst6502_rla_abs				;2F
.dl	inst6502_bmi					;30
.dl	inst6502_and_indy				;31
.dl	inst6502_jam_32 				;32
.dl	inst6502_rla_indy				;33
.dl	inst6502_nop_zpx				;34
.dl	inst6502_and_zpx				;35
.dl	inst6502_rol_zpx				;36
.dl	inst6502_rla_zpx				;37
.dl	inst6502_sec					;38
.dl	inst6502_and_absy				;39
.dl	inst6502_nop_implied			;3A
.dl	inst6502_rla_absy   			;3B
.dl	inst6502_nop_absx   			;3C
.dl	inst6502_and_absx				;3D
.dl	inst6502_rol_absx				;3E
.dl	inst6502_rla_absx   			;3F
.dl	inst6502_rti					;40
.dl	inst6502_eor_indx				;41
.dl	inst6502_jam_42     			;42
.dl	isnt6502_sre_indx   			;43
.dl	inst6502_nop_zp     			;44
.dl	inst6502_eor_zp					;45
.dl	inst6502_lsr_zp					;46
.dl	inst6502_sre_zp     			;47
.dl	inst6502_pha					;48
.dl	inst6502_eor_imm				;49
.dl	inst6502_lsr					;4A
.dl	inst6502_alr_imm    			;4B
.dl	inst6052_jmp_abs				;4C
.dl	inst6502_eor_abs				;4D
.dl	inst6502_lsr_abs				;4E
.dl	inst6502_sre_abs    			;4F
.dl	inst6502_bvc					;50
.dl	inst6502_eor_indy				;51
.dl	inst6502_jam_52     			;52
.dl	inst6502_sre_indy   			;53
.dl	inst6502_nop_zpx    			;54
.dl	inst6502_eor_zpx				;55
.dl	inst6502_lsr_zpx				;56
.dl	inst6502_sre_zpx    			;57
.dl	inst6502_cli					;58
.dl	inst6502_eor_absy				;59
.dl	inst6502_nop_implied			;5A
.dl	inst6502_sre_absy   			;5B
.dl	inst6502_nop_absx   			;5C
.dl	inst6502_eor_absx				;5D
.dl	inst6502_lsr_absx				;5E
.dl	inst6502_sre_absx   			;5F
.dl	inst6502_rts					;60
.dl	inst6502_adc_indx				;61
.dl	inst6502_jam_62     			;62
.dl	isnt6502_rra_indx   			;63
.dl	inst6502_nop_zp     			;64
.dl	inst6502_adc_zp					;65
.dl	inst6502_ror_zp					;66
.dl	inst6502_rra_zp     			;67
.dl	inst6502_pla					;68
.dl	inst6502_adc_imm				;69
.dl	inst6502_ror					;6A
.dl	instr6502_arr_imm   			;6B
.dl	inst6502_jmp_indir				;6C
.dl	inst6502_adc_abs				;6D
.dl	inst6502_ror_abs				;6E
.dl	inst6502_rra_abs    			;6F
.dl	inst6502_bvs					;70
.dl	inst6502_adc_indy				;71
.dl	inst6502_jam_72     			;72
.dl	inst6502_rra_indy   			;73
.dl	inst6502_nop_zpx    			;74
.dl	inst6502_adc_zpx				;75
.dl	inst6502_ror_zpx				;76
.dl	inst6502_rra_zpx    			;77
.dl	inst6502_sei					;78
.dl	inst6502_adc_absy				;79
.dl	inst6502_nop_implied			;7A
.dl	inst6502_rra_absy   			;7B
.dl	inst6502_nop_absx   			;7C
.dl	inst6502_adc_absx				;7D
.dl	inst6502_ror_absx				;7E
.dl	inst6502_rra_absx   			;7F
.dl	inst6502_nop_imm    			;80
.dl	inst6502_sta_indx				;81
.dl	inst6502_nop_imm    			;82
.dl	inst6502_sax_indx   			;83
.dl	inst6502_sty_zp					;84
.dl	inst6502_sta_zp					;85
.dl	inst6502_stx_zp					;86
.dl	inst6502_sax_zp     			;87
.dl	inst6502_dey					;88
.dl	inst6502_nop_imm    			;89
.dl	inst6502_txa					;8A
.dl	instr6502_ane_imm   			;8B
.dl	inst6502_sty_abs				;8C
.dl	inst6502_sta_abs				;8D
.dl	inst6502_stx_abs				;8E
.dl	inst6502_sax_abs    			;8F
.dl	inst6502_bcc					;90
.dl	inst6502_sta_indy				;91
.dl	inst6502_jam_92     			;92
.dl	inst6502_sha_indy   			;93
.dl	inst6502_sty_zpx				;94
.dl	inst6502_sta_zpx				;95
.dl	inst6502_stx_zpy				;96
.dl	inst6502_sax_zpy    			;97
.dl	inst6502_tya					;98
.dl	inst6502_sta_absy				;99
.dl	inst6502_txs					;9A
.dl	inst6502_tas_absy   			;9B
.dl	inst6502_shy_absx   			;9C
.dl	inst6502_sta_absx				;9D
.dl	inst6502_shx_absy   			;9E
.dl	inst6502_sha_absy   			;9F
.dl	inst6502_ldy_imm				;A0
.dl	inst6502_lda_indx				;A1
.dl	inst6502_ldx_imm				;A2
.dl	inst6502_lax_indx   			;A3
.dl	inst6502_ldy_zp					;A4
.dl	inst6502_lda_zp					;A5
.dl	inst6502_ldx_zp					;A6
.dl	inst6502_lax_zp     			;A7
.dl	inst6502_tay					;A8
.dl	inst6502_lda_imm				;A9
.dl	inst6502_tax					;AA
.dl	inst6502_lxa        			;AB
.dl	inst6502_ldy_abs				;AC
.dl	inst6502_lda_abs				;AD
.dl	inst6502_ldx_abs				;AE
.dl	inst6502_lax_abs    			;AF
.dl	inst6502_bcs					;B0
.dl	inst6502_lda_indy				;B1
.dl	inst6502_jam_B2     			;B2
.dl	inst6502_lax_indy   			;B3
.dl	inst6502_ldy_zpx				;B4
.dl	inst6502_lda_zpx				;B5
.dl	inst6502_ldx_zpy				;B6
.dl	inst6502_lax_zpy    			;B7
.dl	inst6502_clv					;B8
.dl	inst6502_lda_absy				;B9
.dl	inst6502_tsx					;BA
.dl	inst6502_las_absy   			;BB
.dl	inst6502_ldy_absx				;BC
.dl	inst6502_lda_absx				;BD
.dl	inst6502_ldx_absy				;BE
.dl	inst6502_lax_absy   			;BF
.dl	inst6502_cpy_imm				;C0
.dl	inst6502_cmp_indx				;C1
.dl	inst6502_nop_imm    			;C2
.dl	inst6502_dcp_indx   			;C3
.dl	inst6502_cpy_zp					;C4
.dl	inst6502_cmp_zp					;C5
.dl	inst6502_dec_zp					;C6
.dl	inst6502_dcp_zp     			;C7
.dl	inst6502_iny					;C8
.dl	inst6502_cmp_imm				;C9
.dl	inst6502_dex					;CA
.dl	inst6502_sbx_imm    			;CB
.dl	inst6502_cpy_abs				;CC
.dl	inst6502_cmp_abs				;CD
.dl	inst6502_dec_abs				;CE
.dl	inst6502_dcp_abs    			;CF
.dl	inst6502_bne					;D0
.dl	inst6502_cmp_indy				;D1
.dl	inst6502_jam_D2     			;D2
.dl	inst6502_dcp_indy   			;D3
.dl	inst6502_nop_zpx    			;D4
.dl	inst6502_cmp_zpx				;D5
.dl	inst6502_dec_zpx				;D6
.dl	inst6520_dcp_zpx    			;D7
.dl	inst6502_cld					;D8
.dl	inst6502_cmp_absy				;D9
.dl	inst6502_nop_implied			;DA
.dl	inst6502_dcp_absy   			;DB
.dl	inst6502_nop_absx   			;DC
.dl	inst6502_cmp_absx				;DD
.dl	inst6502_dec_absx				;DE
.dl	inst6502_dcp_absx   			;DF
.dl	inst6502_cpx_imm				;E0
.dl	inst6502_sbc_indx				;E1
.dl	inst6502_nop_imm    			;E2
.dl	inst6502_isc_indx   			;E3
.dl	inst6502_cpx_zp					;E4
.dl	inst6502_sbc_zp					;E5
.dl	inst6502_inc_zp					;E6
.dl	inst6502_isc_zp     			;E7
.dl	inst6502_inx					;E8
.dl	inst6502_sbc_imm				;E9
.dl	inst6502_nop					;EA
.dl	inst6502_sbc_imm			    ;EB *DUPLICATE OF E9
.dl	inst6502_cpx_abs				;EC
.dl	inst6502_sbc_abs				;ED
.dl	inst6502_inc_abs				;EE
.dl	inst6502_isc_abs    			;EF
.dl	inst6502_beq					;F0
.dl	inst6502_sbc_indy				;F1
.dl	inst6502_jam_F2     			;F2
.dl	inst6502_isc_indy   			;F3
.dl	inst6502_nop_zpx    			;F4
.dl	inst6502_sbc_zpx				;F5
.dl	inst6502_inc_zpx				;F6
.dl	inst6520_isc_zpx    			;F7
.dl	inst6502_sed					;F8
.dl	inst6502_sbc_absy				;F9
.dl	inst6502_nop_implied			;FA
.dl	inst6502_isc_absy   			;FB
.dl	inst6502_nop_absx   			;FC
.dl	inst6502_sbc_absx				;FD
.dl	inst6502_inc_absx				;FE
.dl	inst6502_isc_absx   			;FF

;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;These instructions are located here because they perform a function outside
;the context of emulating instructions. These are mapped to instructions that
;would, on the real hardware, freeze the CPU and require a reset to continue.
;
;Here, they'll let us perform useful things. Like exiting the emulator.
;Or jamming in one spot. Or other things in the future. Debugging things.
;Future stuff like breakpoints and console output. That sorta thing.
;

inst6502_:
    ret

inst6502_jam_12_halt:
    jr $
    jp i6502FinishLoad

inst6502_jam_02:
inst6502_jam_22:
inst6502_jam_32:
inst6502_jam_42:
inst6502_jam_52:
inst6502_jam_62:
inst6502_jam_72:
inst6502_jam_92:
inst6502_jam_B2:
inst6502_jam_D2:
inst6502_jam_F2:
    ret













