#include "ti84pce.inc"
.org userMem-2
.db $EF, $7B

;SPASM help msg
;-E = Assemble eZ80 code
;-T = Generate code listing
;-C = Code counter mode
;-L = Symbol table mode
;-S = Stats mode
;-O = Don't write to output file
;-I [directory] = Add include directory
;-A = Labels are cAse-sensitive
;-D<name>[=value] = Create a define 'name' [with 'value']
;-N = Don't use colors for messages
;-V <Expression> = Pipe expression directly into assembly
;-H = Print this help message




programStart:
    di
    ;Continuous. Else it'd be possible for an NES ROM to tank the CPU
    ;performance by constantly polling the keyboard.
    ld  hl,mpKeyMode
    ld  (hl),3      
    ld  (save_spl),sp
    ld  a,MB
    ld  (save_mbase),a
    ld  a,$D0
    ld  MB,a
    call startGfx
    ;
    ; todo; write test 6502 program, map it into rom.
    ; map virtual screen device into ram too. 32x30 screen ascii display
    ; is probably looking nice right about now.
    ; Could probably map it into PPU space since we're not actually doing
    ; anything about that until long after we're done testing core integrity
    ; You'll probably want to create a mockup vector table then do some equate
    ; magic to offset it and map it to $FFXX such that the three vectors will
    ; magically line up with $FFFA-$FFFF. NMI, RES, and IRQ. In that order.
    ; The rest of the page won't need to matter. It could literally be the
    ; surrounding eZ80 data/code. Just... don't allow writes to it.
    ;

    ld  hl,screenBuf1
    ld  de,screenBuf1+1
    ld  bc,(2*240*320)-1
    ld  (hl),$00
    ldir

    ;Makes sure all non-ROM areas have a mapping
    ld  hl,scrap_mapping
    ld  bc,$008001
    ld  e,0
    call i6502_map_pages



    ;load reset vectors
    ld  hl,testVectors
    ld  bc,$000101
    ld  e,$FF
    call i6502_map_pages
    ;load program ROM to lowmem
    ld  hl,testCode
    ld  bc,$002008
    ld  e,$80
    call i6502_map_pages
    ;map nametable to writeable address space. Write routine to mirror this
    ;memory to screen.
    ld  hl,NAMETABLE1
    ld  bc,$002004
    ld  e,$40
    call i6502_map_pages
    ;Everything should be ready. Set up the debug environment and then
    ;start the emulation.
    ;jr $
    call clearTextBuf
    ld  a,1
    call setLineStart
    call setCurLine
    ld  hl,text001
    call printString
    ld  iy,firstFileHeader
    ld  bc,0
    ld  c,(iy-1)
    call vatTraverse
    jp  c,err_noContainersFound
    push de
        ld  hl,text003
        call printString
        ld  b,(ix-6)
        lea hl,ix-7
_:      ld  a,(hl)
        dec hl
        push hl
            push bc
                call PrintBigFont
            pop bc
        pop hl
        djnz -_
        call newLine
    pop de
    call loadROMFile

    ;REMOVE THE FOLLOWING BLOCK WHEN DONE TESTING NESTEST
    ;
    ;
    ld  hl,timings_file
    call _Mov9ToOP1
    call _ChkFindSym
    jp  c,endCurrentRun
    call _ChkInRam
    ex  de,hl
    jr  nc,+_
    ld  de,9
    add hl,de
    ld  e,(hl)
    add hl,de
    inc hl
_:  ld  e,(hl)
    inc hl
    ld  d,(hl)
    inc hl
    ld  (timings_base),hl
    ;
    ;
    ;


    ld  hl,text004
    call printString

    ;jr $
#ifdef COREDEBUG
    call dbg_resetScreen
#endif
    ld  ix,$F20000
    ld  hl,(ix+$30)
    res 0,L ;turn off timer 0
    res 1,L ;timer 0 uses CPU clock
    res 2,L ;disables timer 0 interrupt generator
    set 1,H ;timer 0 counts upward
    ld  (ix+$30),hl
    
    xor a,a
    sbc hl,hl
    ld  (ix+0),hl
    ld  (ix+3),a

    call i6502Init


    ld  ix,$F20000
    ld  a,(ix+$30)
    res 0,a ;turn off timer 0
    set 1,a ;timer 0 uses 32768Hz clock
    res 2,a ;disables timer 0 interrupt generator
    ld  (ix+$30),a
    ;
    ld  hl,($F20000)

endCurrentRun:
    call dbg_prepNextLine
    call newLine
    ld  hl,text005
    call printString

    ;call printTextBuf
    call fastCopy
    nop
    call waituntilnewkeypress
    call waituntilkeyrelease

    ;
    ;
    ;
programExit:
    call stopGfx
    ld  sp,(save_spl)
    ld  a,(save_mbase)
    ld  MB,a
    ld  iy,flags
    ret


testFilename:
.db AppVarObj,"NESTEST",0


;NMI, RES, and IRQ. In that order.
testVectors .equ $-(256-6)
.dw $8000
.dw $8000
.dw $8000
testCode:
.db $A9,$00,$AA,$A8
.db $BD,$14,$80
.db $C9,$00
.db $F0,$08
.db $99,$21,$40
.db $E8,$C8
;.db $12
.db $4C,$04,$80,$02
.db $48,$65,$6C,$6C,$6F,$2C,$20,$57,$6F
.db $72,$6C,$64,$21,$00


.db $A9,$00,$AA,$A8,$BD,$11,$80,$C9,$00,$F0,$05,$99,$21,$40,$D0
.db $F4,$02,$48,$65,$6C,$6C,$6F,$2C,$20,$57,$6F,$72,$6C,$64,$21,$00
.db $02     ;JAM. Emulator terminates on unsupported instructions or JAMs.

helloWorld:
.db "Hello, World!",0

timings_file:
.db AppVarObj,"timings",0

text001:
.db "Looking up nestest...\n",0
text003:
.db "File found: ",0
text004:
.db "ROMFile loaded and ready to run.\n",0
text005:
;    0123456789012345678901234567890123456789
.db "CPU Execution Halted                  ",0
text006:


.db 7
firstFileHeader:
.db "CENROM",0

err_:

err_err:
    pop hl
    call printString
err_err_quit:
    call fastCopy
    nop
    call waituntilnewkeypress
    call waituntilkeyrelease
    jp programExit

err_noContainersFound:
    call err_err
.db "Traverse found no candidates.\n",0

err_missingFiles:
    push af
        ld  hl,err_missingFiles_str
        call printString
    pop af
    call printSmallNumPair
    jp err_err_quit
err_missingFiles_str:
.db "Number of files missing: ",0

err_tooManyFiles:
    call err_err
.db "Too many files found.",0

err_PRGROMTooLarge:
    call err_err
.db "PRG_ROM too large.",0
err_CHRROMTooLarge:
    call err_err
.db "CHR_ROM too large.",0

err_missingROMDetected:
    call err_err
.db "PRG+CHR > Actual file data.",0

err_ROMHeaderDamaged:
    call err_err
.db "INES ROM header damaged.",0

err_MapperOutOfRange:
    call err_err
.db "Mapper specified out of range.",0

err_CHRROMNotFound:
    call err_err
.db "CHR_ROM not found inside file",0


;Input: DE = Address of first file after the container header signature
;Outputs: ROM vectors recorded and ready to map
;Destroys: All registers.
loadROMFile:
    ex  de,hl
    xor a,a
    ld  (missing_files),a
_:  cp  (hl)    ;
    inc hl      ;
    jr  nz,-_   ;skips past zero-terminated string containing full ROM name
    ld  (basefile_sig),hl
    ld  bc,SIZEOF_INTEGRITY_HASH
    add hl,bc
    ld  a,(hl)
    cp  a,MAXNUMFILES
    jp  nc,err_tooManyFiles
    ld  (inputNumFiles),a
    ld  b,a
;    ld  c,SIZEOF_INTEGRITY_HASH     ;c already set to this value from earlier.
    mlt bc
    inc hl
    push hl
        add hl,bc
        ld  iy,FILETABLE
        ld  c,(hl)
        inc hl
        ld  b,(hl)
        inc hl
        ld.s (iy+FILE_SIZE_OFFSET),bc
        ld  (iy+FILE_ADR_OFFSET),hl
    pop hl
    inc a
    dec a
    jr  z,loadROMFile_singleFileLoad
    ;If more than one file, fill FILETABLE.
    ;NOTE: For now, this machinery is disabled. Only a single file is allowed.
    lea iy,iy+FILETABLE_STRIDE
    ld  b,a
loadROMFile_multiFileLoadLoop:
    push bc
        ld  (iy+FILE_SIG_ADR_OFFSET),hl
        ld  bc,16
        ld  de,loadROMFile_tempSigHash
        ldir
        push hl
            push iy
                ld  bc,23
                ld  iy,loadROMFile_tempSig
                call vatTraverse    ;returns DE @ datasection size if found
                jr  nc,+_
                ld  hl,missing_files
                inc (hl)
_:          pop iy
            ex  de,hl
            ld  e,(hl)
            inc hl
            ld  d,(hl)
            inc hl
            ld.s (iy+FILE_SIZE_OFFSET),de
            ld  (iy+FILE_ADR_OFFSET),hl
        pop hl
    pop bc
    lea iy,iy+FILETABLE_STRIDE
    djnz loadROMFile_multiFileLoadLoop
    ld  a,(missing_files)
    or  a,a
    jp  nz,err_missingFiles
loadROMFile_singleFileLoad:
    ;Compute size of ROM by summing filesizes, less INES header
    ld  a,(inputNumFiles)
    inc a
    ld  b,a
    ld  hl,0
    ld  ix,FILETABLE
_:  ld.s de,(ix+FILE_SIZE_OFFSET)
    add hl,de
    lea ix,ix+FILETABLE_STRIDE
    djnz -_
    ld  bc,-16
    add hl,bc   ;subtract INES header
    ld  (total_rom_size),hl
    ;Verify that the file actually contains an INES header.
    ;TODO: Do this at an earlier stage. Such as file selection.
    ld  ix,(FILETABLE+FILE_ADR_OFFSET)
    ld  hl,(ix+0)
    ld  de,$53454E         ;4E 45 53 == "NES"
    or  a,a
    sbc hl,de   ;Note: add does not affect zero flag. Can't test this via -DE
_:  jp  nz,err_ROMHeaderDamaged
    ld  a,(ix+3)
    cp  a,$1A
    jr  nz,-_   ;19
    ;Compute ROM size by reading INES header. This should be equ or lt above.
    ;Note: The below line is optimized from...
    ld  ix,(FILETABLE+FILE_ADR_OFFSET)
    ;... these lines. But the intent might not be perfectly clear. We'll keep
    ;these here just in case there's ever a question about it.
;    ld  ix,FILETABLE
;    ld  ix,(ix+FILE_ADR_OFFSET)
    ld  L,(ix+4)    ;PRG ROM count, low
    ld  e,(ix+5)    ;CHR ROM count, low
    ld  h,0
    ld  d,h
    ld  a,(ix+7)    ;Check for INES2 bits
    and a,%00001100
    cp  a,%00001000
    jr  nz,+_
    ld  a,(ix+9)
    ld  b,a
    and a,$0F
    cp  a,MAXPRGROM_HINIB+1
    jp  nc,err_PRGROMTooLarge
    ld  h,a
    ld  a,b
    and a,$F0
    rlca
    rlca
    rlca
    rlca
    cp  a,MAXCHRROM_HINIB+1
    jp  nc,err_CHRROMTooLarge
    ld  d,a
_:  xor a,a
    ld  (prg_rom_size),a
    ld  (chr_rom_size),a
    add hl,hl   ;x2
    add hl,hl   ;x4
    add hl,hl   ;x8
    add hl,hl   ;x16
    add hl,hl   ;x32
    add hl,hl   ;x64
    ld.s (prg_rom_size+1),hl    ;x64x256
    ex  de,hl
    add hl,hl   ;x2
    add hl,hl   ;x4
    add hl,hl   ;x8
    add hl,hl   ;x16
    add hl,hl   ;x32
    ld.s (chr_rom_size+1),hl    ;x32x256
    ld  hl,(chr_rom_size)
    ld  de,(prg_rom_size)
    add hl,de
    ld  de,(total_rom_size)
    or  a,a
    sbc hl,de   ;declared-actual. declared must be equal to or smaller.
    jr  z,+_
    jp  nc,err_missingROMDetected
_:  ;Find trainer, PRG, and CHR base addresses
    lea hl,ix+16
    ld  (trainer_base),hl   ;whether it exists or not.
    ld  de,0
    bit 2,(ix+6)
    jr  z,+_
    ld  de,512
_:  add hl,de
    ld  (prg_rom_base),hl
    ld  iy,FILETABLE
    ld.s hl,(iy+FILE_SIZE_OFFSET)
    or  a,a
    sbc hl,de   ;less possible trainer
    ld  de,16
    sbc hl,de   ;less iNES header. Remaining is now size of current file.
    ex  de,hl   ;curfilesize is now in DE
    ld  hl,(prg_rom_size)   ;keep subtracting filesize from this until carry.
    or  a,a
    sbc hl,de   ;if carry, prg_rom end is inside this file. Undo: HL is offset.
    ld  c,0     ;0th file current
    jr  c,loadROMFile_locatedCHRROM
    ld  a,(inputNumFiles)
    or  a,a
    jr  z,loadROMFile_noCHRROMFound
    ld  b,a
_:  lea iy,iy+FILETABLE_STRIDE
    ld.s de,(FILE_SIZE_OFFSET)
    inc c
    or  a,a
    sbc hl,de   ;
    jr  c,loadROMFile_locatedCHRROM
    djnz -_
loadROMFile_noCHRROMFound:
    jp  err_CHRROMNotFound
loadROMFile_locatedCHRROM:
    add hl,de       ;Undid subtract. HL is now offset in current file
    ld  de,(iy+FILE_ADR_OFFSET) ;so get address inside that file.
    add hl,de
    ld  a,c
    ld  (chr_rom_base),hl
    ld  (chr_rom_base_file),a
    ;Detect mapper and run its initializer
    ld  a,(ix+6)
    ld  b,(ix+7)
    rlca
    rlca
    rlca
    rlca
    xor a,b
    and a,$0F
    xor a,b
    ex.s de,hl  ;clears HLU,DEU
    ld  e,a
    ld  hl,submapper
    ld  (hl),0
    ld  a,b
    and a,%00001100
    cp  a,%00001000
    ld  a,0
    jr  nz,+_
    ld  b,(ix+8)
    ld  a,b
    rlca
    rlca
    rlca
    rlca
    and a,$0F
    ld  (hl),a
    ld  a,b
    and a,$0F
_:  ld  d,a
    ld  (mapper_id),de
    ld  hl,-NUMBER_OF_MAPPERS
    add hl,de
    jp  c,err_MapperOutOfRange
    sbc hl,hl
    add hl,de               ;hl=de. both are mapper IDs
    ld  L,MAPPER_STRIDE
    ld  d,L
    mlt hl                  ;high byte multiply
    ld  h,L
    ld  L,0
    mlt de                  ;low byte multiply
    add hl,de               ;This is the best 16bit * 8bit I know to do.
    ld  de,mapper_table
    add hl,de
    ld  (mapper_adr_base),hl
    ld  hl,(hl)
    jp  (hl)

mapper_table:   ;entries 9 wide
.dl mapper0_init
.dl mapper0_read
.dl mapper0_write

mapper0_init:
    ;map trainer, if exist
    bit 2,(ix+6)
    jr  z,+_
    ld  hl,(trainer_base)
    ld  e,$70
    ld  c,2
    ld  b,c
    call i6502_map_pages
_:  ld  hl,(prg_rom_size)
    ld  de,-(16384+1)
    add hl,de   ;carry if more than 1 16KB segment
    ld  hl,(prg_rom_base)
    ;jr  $
    ld  b,$80
    ld  e,b
    ld  c,$40
    jr  nc,+_
    sla c
_:  call i6502_map_pages
    ret


mapper0_read:
    ld  a,d
    add a,a
    jr  nc,+_
    ld  a,(hl)  ;is $8000 or above
    ret
    cp  a,$20*2
    jr  c,+_
    ld  a,(hl)  ;is below $2000
    ret
_:  add a,a
    jr  nc,mapper0_ppu_read     ;wasn't $4000 or higher.
    jr  z,mapper0_apu_read      ;high byte was exactly $40
    ld  a,(hl)
    ret
mapper0_apu_read:
    ld  a,e
    cp  a,$16
    jr  nz,+_
    xor a,a
    srl (ix+APU_KEYPAD)
    adc a,a                 ;TODO: Open bus behavior on bits 5-7
    ret
_:  ld  a,(hl)  ;hope that the dummy map page is good enough to not crash.
    ret
mapper0_ppu_read:
    ;TODO: PPU SUPPORT
    ld  a,(hl)
    ret



mapper0_write:
    ld  a,d
    cp  a,$20
    jr  nc,+_
    ld  (hl),b
    ret
_:  cp  a,$40
    jr  c,mapper0_ppu_write
    jr  z,mapper0_apu_write
    add a,a
    ret c       ;don't write anything to above $8000
    ld  (hl),b  ;but allow it in $4100-$7FFF because it might be RAM.
    ret
mapper0_apu_write:
    ld  a,e
    cp  a,$16
    jr  nz,+_
    ld  a,(ix+APU_KEYLATCH)
    xor a,b     ;Bit 0 is set if we're trying to change controller poll state.
    rrca        ;And this is how we're going to get it.
    ret nc      ;Only support NES standard controller.
    bit 0,b     ;So... what are we changing it to?
    ld  (ix+APU_KEYLATCH),b
    ld  hl,mpKeyMode
    jr  z,mapper0_apu_stop_keyboard
    ld  a,(hl)
    cp  a,3
    ret z       ;don't do anything to the keyboard if running continuous.
    ld  (hl),a  ;else set to continuous and keep going.
    ret
mapper0_apu_stop_keyboard:
    ld  L,$12   ;76543210 : del mode 2nd y= wind zoom trace graph
    ld  a,(hl)
    ld  L,$1E   ;----3210 : up right left down
    ld  c,(hl)
    xor a,c
    and a,%11110000
    xor a,c     ;keymapping has changed. We need to further alter it.
    ;[DE MO 2N Y= UP RI LE DO] maps to [SE, B, A, ST, UP, RI, LE, DO]
    ;The above must be rearranged to become:
    ;            [RI, LE, DO, UP, ST, SE, B , A ]
    ;as compared to
    ;            [SE, B , A , ST, UP, RI, LE, DO]
    rlca        ;[B , A , ST, UP, RI, LE, DO, SE]
    ld  c,a     ;b4  : UP is in correct position.
    rlca        ;[A , ST, UP, RI, LE, DO, SE, B ]
    rlca        ;[ST, UP, RI, LE, DO, SE, B , A ]
    ld  b,a     ;b0-2:SE, B , and A are in the correct position
    rlca        ;[UP, RI, LE, DO, SE, B , A , ST]
    rlca        ;[RI, LE, DO, SE, B , A , ST, UP]
    ld  d,a     ;b5-7: RI LE DO in correct position.
    rlca        ;[LE, DO, SE, B , A , ST, UP, RI]
    rlca        ;b3: ST is in the correct position.
    xor a,c     ;
    and a,%00001000 ;keep A3, merge others
    xor a,c     ;Has: A3. Merge-in contains b4
    xor a,b     ;
    and a,%00011000 ;keep A3-4
    xor a,b     ;Merge-in contains b0-2
    xor a,d     ;
    and a,%00011111 ;keep A0-4
    xor a,d     ;Merge-in contains b5-7. Is complete.
    ld  (ix+APU_KEYPAD),a
    ret
_:  ;not even going to try to emulate the second controller.
    ld  (hl),b
    ret
mapper0_ppu_write:
    ld  (hl),b
    ret






loadROMFile_tempSig:    ;total 23 bytes
.db "CENRO2",0
loadROMFile_tempSigHash:
.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;16 bytes for hash


;Input: IY = locationOfSignature. 
;       BC=size of signature (long load to clear BCU), still limited to 255.
;Output: carry=1: Variable not found.
;Output: carry=0: DE=address of variable data start after the signature
;        IX=location of current variable's VAT location.
;Destroys: All registers not in use.
;NOTES: This routine is capable of resuming a search that has ended.

;To continue searching:
;call vatTraverse_continue with the following inputs:
;   IX preserved from a non-carry return of vatTraverse.
;   BC = same as input for vatTraverse. vatTraverse does not destroy this reg.
;   WARNING: DO NOT KEEP SEARCHING AFTER CALL RETURNS CARRY. START A NEW SEARCH.
vatTraverse:
    ;progPtr = progvat start; ptemp = progvatend
    ld  ix,(progPtr)
vatTraverse_loop:
    ld  hl,(pTemp)
    lea de,ix+0
    or  a,a
    sbc hl,de   ;HL<DE while in pVAT, else carry set.
    ccf
    ret c
    ld  a,(de)
    and a,$1F
    cp  a,AppVarObj
    jr  nz,vatTraverse_skip
    ld  de,(ix-7)   ;puts "page" byte in DEU
    ld  e,(ix-3)
    ld  d,(ix-4)
    call _ChkInRam
    ex  de,hl
    jr  nc,+_
    ld  de,9
    add hl,de
    ld  e,(hl)
    add hl,de
    inc hl
_:  ld  e,(hl)
    inc hl
    ld  d,(hl)
    inc hl
    ex  de,hl
    or  a,a
    sbc hl,bc   ;varsize-entrysize. If carry, entry cannot possibly be in var.
    jr  c,vatTraverse_skip
    lea hl,iy+0
    push bc
_:      ld  a,(de)
        inc de
        cpi
        jr  nz,vatTraverse_sigNoMatch
        jp  pe,-_
    pop bc
    or  a,a
    ret         ;NC. DE = past the signature.
vatTraverse_sigNoMatch:
    pop bc
vatTraverse_continue:
vatTraverse_skip:
    ld  a,7
    ld  de,-1
    add a,(ix-6)
    neg
    ld  e,a
    add ix,de   ;because "sbc ix,de" isn't a thing. Boo.
    jr  vatTraverse_loop

;Copied from my Falldown2 project. I didn't want to have to
;find yet another hardware reference for something I already did.
;But I'll have to do it again anyway because this isn't exactly
;what we're looking for. Here, we output the same sort of
;game keys that I've used basically all my programming life.
;Anyhoo. We'll be using the following:
;kbitDown	equ 00h
;kbitLeft	equ 01h
;kbitRight	equ 02h
;kbitUp		equ 03h
;kbitYequ equ 04h
;kbit2nd		equ 05h
;kbitMode	equ 06h
;kbitDel		equ 07h
;You can find the other defines approximately where I found the stuff above.

getkbd_adl:
	ld  ix,mpKeyMode
	lea hl,ix+0
	ld  (hl),keyModeScanOnce
	xor a
_:  cp  (hl)
	jr  nz,-_
	ld  a,(ix+kbdG1-mpKeyRange)
	ld  l,(ix+kbdG7-mpKeyRange)
	xor L
	and 11110000b	;mask out lower bits to let me shove dpad bits in
	xor L
	ret

waituntilkeyrelease:
    call getkbd_adl
    or  a,a
    jr  nz,waituntilkeyrelease
	ret

waituntilnewkeypress:
    call waituntilkeyrelease
_:  call getkbd_adl
	or  a,a
	jr  z,-_
    ret

#include "lcd.z80"
#include "core.z80"
#include "debug.z80"
.echo "Main program size: ",$-programStart