;------------------------------------------------------------------------------
;DELETE THIS SEGMENT WHEN DONE TESTING. THIS IS A HEADER FOR 
;A STANDALONE IMPLEMENTATION OF THIS FOR COMPILING PURPOSES
;#include "defs.inc"
;.org usermem-2
;.db $EF, $7B
;------------------------------------------------------------------------------

a6502_rwaccess_indtable .equ write_access_ptr
;Later, put in actual test. Z if not triggered, NZ if triggered. This
;alters the behavior of the BRK instruction.
#define WAS_NMI_TRIGGERED bit 0,(ix+NMI_TRIGGERED)





a6502_module_start:
a6502_init:
i6502Init:
    ;scf
    ;sbc hl,hl
    ;ld  (hl),2  ;opens the debugger
    ;It'll be at this part of the initialization where you'll be afforded the
    ;opportunity to paint certain routines red. Everyone knows red ones go
    ;faster, but our bucket of red paint is so very limited. Only about 1000
    ;drops worth, and over half of it is dedicated to the PPU.
    ;If you use too much red paint, some of it will spill out onto the console.
    ;It'll be a very angry red. Avoid it by painting slowly and checking often.

    ;THE PAINTBRUSH GOES HERE. That's done with:
    ;       copy_autoalloc(oldtarget, newtarget, segmentsize)
    ;The bucket of paint is managed with:
    ;       autoreloc() and endautoreloc()
    ;The paint bucket's emptiness is reported at the end of main.z80 with:
    ;       reportautoreloc()
    copy_autoalloc(a6502_fetcher_start, i6502RetryFirstLoad, a6502_fetcher_end-a6502_fetcher_start)

    #if AUTONESTEST > 0
        call a6502_nestest_init
    #endif 

    ;Map in 2KB main RAM
    ld  hl,main_ram
    ld  bc,$002008
    ld  e,$00
    call a6502_map_pages
    ;Map in PPU memory
    ;NOTE: In-page mirroring happens at R/W access.
    ld  hl,core_memory_ix+PPU_CTRL
    ld  bc,$002001
    ld  e,$20
    call a6502_map_pages
    ;Load various lookup tables
    call a6502_flags6502ToNativeLUTGen
    call a6502_flagsz80to6502
    call a6502_build_calltable
    ;Initialize core memory
    ld  ix,core_memory_ix
    lea hl,ix+0
    lea de,ix+1
    ld  bc,126
    ld  (hl),b
    ldir
    or  a,a
    ;Preserve SP for exit vector
    sbc hl,hl
    add hl,sp
    ld  (ix+CORE_STACK_BASE),hl
    ;Initialize register state as if RESET had been triggered.
    ld  iy,8
    ld  (ix+REGSP),$FD
    ld  (ix+REGSR),$24
    ld  hl,(PAGETABLE+(255*BASETABLE_STRIDE))
    ld  de,$0000FC  ;Offset to RESET vector ($FE=IRQ, $FA=NMI)
    add hl,de       ;HL now points to byte at vector.
    ld  hl,(hl)     ;Pull address from RESET vector.
    ex  af,af'
    or  a,1         ;Z unset, C unset, S unset.
    ex  af,af'
    #if AUTONESTEST > 0
        ld  hl,$C000    ;NESTEST headless start
        ld  iy,7        ;nestest starts at 7cc
    #endif
    ld.s (ix+REGPC),hl
    ; -- DEBUGGING -- ENABLE TIMER 0.
    ld  hl,$F20030  \ set 0,(hl)
    ; Core registers initialized. Jump to E:HL loading
    jp  a6502_reload_then_getInstruction



;#############################################################################

;  # ###   ## ### ##  # #  ## ### #  #  ##      ### ### ### ## # # # ##   ##
;  # #  # #    #  # # # # #    #  # # # # #     #   #    # #   # # # # # #  
;  # #  #  ##  #  ##  # # #    #  # # # # #     ##  ##   # #   ### # # # #  
;  # #  #    # #  # # # # #    #  # # # # #     #   #    # #   # # # # # # #
;  # #  #  ##  #  # # ###  ##  #  #  #  # #     #   ###  #  ## # # # # # ###

;#############################################################################

a6502_fetcher_start:
autoreloc()
;------------------------------
;Reloads E:HL cache at the prior PC location. This is to
;restart the current instruction load in the event of
;an interrupt doing that thing.
i6502RetryFirstLoad:
a6502_retry_getInstruction:
    ld.s bc,(ix+REGPC)
    dec  bc
    jr  +_
;------------------------------
;Reloads the E:HL cache at the current PC location, then
;begins executing instructions at that point.
a6502_reload_then_getInstruction:
    ld.s bc,(ix+REGPC)
_:  ld  e,c
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,e
    add hl,bc
    jr  a6502_getInstruction
;------------------------------
;Jumped to if an instruction ends with PC already on the next
;instruction, but shadow registers are still swapped in.
;Avoid this situation if at all possible.
a6502_getInstruction_exx:
    exx
    jr  a6502_getInstruction
;------------------------------
;Jumped to if advancing to the start of the next
;instruction byte triggered a page crossing.
a6502_newfetch_pagecross:
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  b,d
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    jr  a6502_newfetch_continue
;------------------------------
;Jumped to if advancing to the byte after the current
;instruction byte triggered a page crossing.
a6502_nextargfetch_pagecross:
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  b,d
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    jr  a6502_nextargfetch_continue
;------------------------------
;Advance PC by one to the start of the next instruction.
;Call this from a routine that exits with shadow registers
;still swapped in.
a6502_newfetch_exx:
    exx
;Advance PC by one to the start of the next instruction.
;Call this if PC is at the end of the previous instruction.
a6502_newfetch:
    inc hl
    inc e
    jr  z,a6502_newfetch_pagecross
a6502_newfetch_continue:
a6502_getInstruction:
    #if AUTONESTEST > 0
        ld  a,(hl)
        ld  (ix+REGPC+0),e
        exx
        #if NESTEST_BRKPT > 0
            ld  de,(ix+REGPC)
            ld  hl,NESTEST_BRKPT
            or  a,a
            sbc.s hl,de
            jr  z,$
        #endif
        ld  hl,(ix+CORE_STACK_BASE)
        ld  sp,hl
        call a6502_nestest_verify
        exx
    #endif
    ;Fetch instruction, then advance PC
    ld  a,(hl)
    ;cp  a,$FC   \   jr z,$
    inc hl
    inc e
    jr  z,a6502_nextargfetch_pagecross
a6502_nextargfetch_continue:
    exx
    lea hl,iy+0
i6502_interrupt_timer   .equ $+1
a6502_int_timer         .equ $+1
    #if AUTONESTEST > 0
        ld  bc,-26554 ;
    #else
        ld  bc,-27939
    #endif
    add hl,bc
    jp  c,a6502_int_take
a6502_int_cancel_take:
    ld  L,a
    ld  h,BASETABLE_STRIDE
    mlt hl
    ld  sp,CALLTABLE
    add hl,sp
    ld  sp,hl
    pop bc
    add iy,bc   ;advance instruction timer
    exx
    ret

endautoreloc()
a6502_fetcher_end:

;Assume there's always an interrupt in the wings.
a6502_int_take:
    #if AUTONESTEST == 0
        add hl,hl
        jp  c,a6502_int_cancel_take
        exx
        ld  (ix+REGPC+0),e
        ld  hl,flagsZ80to6502LUT
        ex  af,af'
        push.s af
        pop.s bc
        ld  l,c
        ld  a,(hl)
        ld  b,(ix+REGSR)
        xor a,b
        and a,%10000011
        xor a,b
        ld  (ix+REGSR),a
        ld  hl,(ix+CORE_STACK_BASE)
        ld  sp,hl
        ld  hl,(INT_TABLE)
        jp  (hl)
    #else
        scf
        sbc hl,hl
        ld  (hl),2  ;opens the debugger
        jp  a6502_int_cancel_take
    #endif


;##############################################################################

;          ###  #   # ####  ####   ###  #   # ##### # ##  # #####  ###             
;         #     #   # #   # #   # #   # #   #   #   # ##  # #     # 
;          ###  #   # ####  ####  #   # #   #   #   # # # # ###    ###          
;             # #   # #   # #   # #   # #   #   #   # #  ## #         #       
;          ###   ###  ####  #   #  ###   ###    #   # #  ## #####  ###                             

;##############################################################################

;Call this during init. This table is used in the BIT instruction which sets
;NVZ without bothering to consult the status register. As such, we won't.
;Only the carry is the odd one out, but we're converting the whole mass
;to native anyway.
;This table can also be used during the PLP and RTI instructions to move some
;registers back into native.
;Src: [AB-- --CD]  => [AC-- -B-D]
a6502_flags6502ToNativeLUTGen:
    ld  hl,flags6502toNativeLUT
_:  ld  a,L     ;A and D can stay where they are. Concerned with B and C
    rrca        ;[DAB- ---C]
    rrca        ;[CDAB ----]
    rrca        ;[-CDA B---]
    ld  b,a     ;C moved into position
    rrca        ;[--CD AB--] B moved into position
    xor a,b     ;Merge position C into byte containing position B
    and a,%10111111
    xor a,b     ;[-C-- -B--]
    xor a,L     ;Merge AD into byte BA
    and a,%01111110
    xor a,L
    and a,%11000101 ;Removing gabage bits.
    ld  (hl),a      ;z80 maskout value %00111010 with LUT not-A operand on xor.
    inc L
    jr  nz,-_
    ret

;Z80: [12-- ---3] -> 6502: [1--- --23]
;Usage: retrieve Z80 flags via pushaf\popbc sequence, then use this LUT
;to get mask-in values for 6502 CZN. This is to be used as part of PHP and BRK.
;Use this AND mask to merge in external 6502 flags if LUTRES:A, EXTF:B
;AND A,%10000011
a6502_flagsz80to6502:   ;Converts CZN to be masked in later
    ld  hl,flagsZ80to6502LUT
_:  ld  a,L
    rlca
    rlca
    rlca    ;Only bit 7 needs to be moved to the bit 1 position.
    xor a,L ;All the other bits can stay where they are.
    and a,%00000010
    xor a,L
    and a,%10000011 ;remove unused bits.
    ld  (hl),a
    inc L
    jr  nz,-_
    ret

a6502_macc: .db 0
a6502_adrm: .db 0
a6502_isc: .db 0
a6502_bcc: .db 0

;Detroys IY and IX. Be sure to reset IX to core_memory_ix. IY ought not be
;initialized to any persistent value at this point. You're not trying to
;rebuild the core table AFTER the core started running, are you? *glares*
a6502_build_calltable:
    ld  b,0
    ld  ix,a6502_main_table
a6502_build_calltable_mainLoop:
    push bc
        ;ld  a,b
        ;cp  a,$C3
        ;.error "YOU MUST FIX TABLEGEN FOR DCP (AND POSSIBLY OTHERS)"
        ;jr  z,$
        ld  c,BASETABLE_STRIDE
        mlt bc
        ld  hl,CALLTABLE
        add hl,bc
        push hl
        pop iy          ;iy = start of this instruction's calltable entry
        ;Retrieve and store clock cycle count for that instruction
        ld  c,(ix+0)
        ld  b,(ix+1)
        ld  a,c
        and a,3
        ld  (a6502_macc),a
        ld  a,c
        rrca
        rrca        ;00XXXX00 -> 0000XXXX
        and a,15
        ld  (a6502_adrm),a
        ld  a,b
        rra         ;0000000X -> C:X
        ld  a,c
        rla
        rla
        rla         ;X:000000XX -> 00000XXX
        and a,7
        add a,2
        ld  (a6502_bcc),a
        sbc hl,hl
        ld  L,a
        ld  (iy+0),hl
        lea iy,iy+3     ;advance
        ld  a,b
        rrca
        and a,127
        ld  (a6502_isc),a
        ;Retrieve instruction ID and branch based on which table it uses
        ;NOTE: Instruction ID already fetched. Process what we have.
        cp  a,ISC_NONSPECIAL_LASTENTRY+1
        jp  nc,a6502_build_calltable_skipNonspecialHandle
        ;Build table as normal here.
        ;Address mode ADRMODE_SPEC is illegal in this context.

        ;BPUSH ADRMODE
        ld  a,(a6502_adrm)
        or  a,a
        jp  z,a6502_build_calltable_normalModeImm
        ld  c,a
        ld  b,3
        mlt bc
        ld  hl,a6502_adrtype_table
        add hl,bc
        ld  bc,(hl)
        ld  (iy+0),bc
        lea iy,iy+3
        ;BPUSH READ_MEMORY_ACCESS_IF_APPLICABLE
        ;read values: NONE, WRITE, READ, READWRITE (0,1,2,3)
        ;Table pointers: write,read,rmw
        ld  a,(a6502_macc)
        or  a,a
        ;We may only push either READ OR READWRITE here.
        ;If NONE or WRITE specified, we do not do anything here.
        tst a,%00000010 ;z if none or write.
        jr  z,+_
        dec a
        and a,3
        ld  c,a
        ld  b,3
        mlt bc
        ld  hl,a6502_rwaccess_indtable
        add hl,bc
        ld  hl,(hl)
        ld  (iy+0),hl
        lea iy,iy+3
_:      ;BPUSH INSFUNC
        ld  a,(a6502_isc)
        ld  c,a
        ld  b,6
        mlt bc
        ld  hl,a6502_norm_func_table
        add hl,bc
        ld  a,(a6502_adrm)
        cp  a,ADRMODE_ABS
        jr  c,+_    ;if not abs or greater, use first entry, else entryHL
        ld  bc,3
        add hl,bc
_:      ld  hl,(hl)
        or a,a \ ld  c,0 \ sbc hl,bc \ jr z,$    ;LOCK IF TRYING TO USE ILLEGAL MODE
        ld  (iy+0),hl
        lea iy,iy+3
        ;BPUSH WRITE_MEMORY_ACCESS_IF_APPLICABLE
        ;read values: NONE, WRITE, READ, READWRITE (0,1,2,3)
        ;Table pointers: write,read,rmw
        ld  a,(a6502_macc)
        ld  c,a
        tst a,%00000001 ;z if none or read
        ;We may only push WRITE here. Skip if value here is 0 or 2.
        ;If NONE or WRITE specified, we do not do anything here.
        jr  z,+_
        ld  hl,(a6502_rwaccess_indtable)    ;write-access
        ld  (iy+0),hl
        lea iy,iy+3
_:      ;BPUSH RETURNADDRESS
        ;a6502_newfetch_exx if memmode else a6502_newfetch
        ld  hl,a6502_newfetch_exx
        inc c
        dec c
        jr  nz,+_
        ld  hl,a6502_newfetch
_:      ld  (iy+0),hl
        jp  a6502_build_calltable_collectAfter
a6502_build_calltable_normalModeImm:
        ;Abbreviated normal mode for instructions that support operand IMM.
        ;BPUSH INSFUNC
        ld  a,(a6502_isc)
        ld  c,a
        ld  b,6
        mlt bc
        ld  hl,a6502_norm_func_table
        add hl,bc
        ld  hl,(hl)
        dec hl          ;get to the "ld a,(hl)" prior to funcstart.
        ld  (iy+0),hl
        ld  hl,a6502_newfetch
        ld  (iy+3),hl
        jp  a6502_build_calltable_collectAfter
a6502_build_calltable_skipNonspecialHandle:
        cp  a,ISC_SPECIAL_NONMODED_LASTENTRY+1
        jr  nc,a6502_build_calltable_skipSpecialHandle
        ;Build table based on specialness.
        sub a,ISC_NONSPECIAL_LASTENTRY+1
        ld  hl,a6502_special_specific_case_func_table
        jr  z,++_
        ld  b,a
_:      ld  a,(hl)
        or  a,a
        jr  z,$ ;halt if entry is dead. debug tool.
        ld  e,a
        ld  d,3
        inc hl
        mlt de
        add hl,de
        djnz -_
_:      ld  a,(hl)
        or  a,a
        jr  z,$ ;this entry dead entry? lock up if so.
        inc hl
        ld  b,a
        ld  c,3
        mlt bc
        lea de,iy+0
        ldir
        jp  a6502_build_calltable_collectAfter
a6502_build_calltable_skipSpecialHandle:
        sub a,ISC_SPECIAL_NONMODED_LASTENTRY+1
        ;Build table based on normal table above, except the jump table has
        ;an extra entry for split function before and after WRITE_ACCESS,
        ;if the address mode specifies such accesses.
        ;Address mode ADRMODE_SPEC is illegal in this context.
        ;BPUSH ADRMODE
        ld  a,(a6502_adrm)
        or  a,a
        jp  z,$     ;THESE INSTRUCTIONS CANNOT TAKE IMM. HALT FOR DEBUG
        ld  c,a
        ld  b,3
        mlt bc
        ld  hl,a6502_adrtype_table
        add hl,bc
        ld  bc,(hl)
        ld  (iy+0),bc
        lea iy,iy+3
        ;BPUSH READ_MEMORY_ACCESS_IF_APPLICABLE
        ;read values: NONE, WRITE, READ, READWRITE (0,1,2,3)
        ;Table pointers: write,read,rmw
        ld  a,(a6502_macc)
        or  a,a
        ;We may only push either READ OR READWRITE here.
        ;If NONE or WRITE specified, we do not do anything here.
        tst a,%00000010 ;z if none or write.
        jr  z,+_
        dec a
        and a,3
        ld  c,a
        ld  b,3
        mlt bc
        ld  hl,a6502_rwaccess_indtable
        add hl,bc
        ld  hl,(hl)
        ld  (iy+0),hl
        lea iy,iy+3
_:      ;BPUSH INSFUNC
        ld  a,(a6502_isc)
        sub a,ISC_SPECIAL_NONMODED_LASTENTRY+1
        ld  c,a
        ld  b,9
        mlt bc
        ld  hl,a6502_special_moded_func_table
        add hl,bc
        ld  a,(a6502_adrm)
        cp  a,ADRMODE_ABS
        jr  c,+_    ;if not abs or greater, use first entry, else entryHL
        ld  bc,3
        add hl,bc
_:      ld  hl,(hl)
        or a,a \ ld  c,0 \ sbc hl,bc \ jr z,$    ;LOCK IF TRYING TO USE ILLEGAL MODE
        ld  (iy+0),hl
        lea iy,iy+3
        ;BPUSH WRITE_MEMORY_ACCESS_IF_APPLICABLE
        ;read values: NONE, WRITE, READ, READWRITE (0,1,2,3)
        ;Table pointers: write,read,rmw
        ld  a,(a6502_macc)
        ld  c,a
        tst a,%00000001 ;z if none or read
        ;We may only push WRITE here. Skip if value here is 0 or 2.
        ;If NONE or WRITE specified, we do not do anything here.
        jr  z,+_
        ld  hl,(a6502_rwaccess_indtable)    ;write-access
        ld  (iy+0),hl
        ld  a,(a6502_isc)    ;If we wrote a WRITEACC, must put seg2 afterward.
        sub a,ISC_SPECIAL_NONMODED_LASTENTRY+1
        ld  c,a
        ld  b,9
        mlt bc
        ld  hl,a6502_special_moded_func_table+6
        add hl,bc
        ld  hl,(hl)
        ld  (iy+3),hl
        lea iy,iy+6
_:      ;BPUSH RETURNADDRESS
        ;a6502_newfetch_exx if memmode else a6502_newfetch
        ld  hl,a6502_newfetch_exx
        ld  a,(a6502_macc)
        or  a,a
        jr  nz,+_
        ld  hl,a6502_newfetch
_:      ld  (iy+0),hl
a6502_build_calltable_collectAfter:
    pop bc
    lea ix,ix+2
    inc b
    jp  nz,a6502_build_calltable_mainLoop
    ret

;HL=Base_ez80_address, C=Numpages_in_map, B=numpages_in_space, E=starting_page
;Example: To map and mirror 2KB RAM at $D03800 inside first 8KB of 6502 space
;HL=$D03800, C=$08, B=$20, E=$00
;Note: B should be a power of two and evenly divisible by C.
i6502_map_pages:
a6502_map_pages:
    ld  d,BASETABLE_STRIDE
    mlt de
    ld  ix,PAGETABLE
    add ix,de
    ld  a,b     ;A = main counter for total number of pages in mapping space
    ld  de,256
    push hl
    pop iy
_:  ld  b,c     ;looping for number of pages to map
_:  ld  (ix+0),hl
    add hl,de                   ;next page z80
    lea ix,ix+BASETABLE_STRIDE  ;next page entry
    dec a
    ret z
    djnz -_
    lea hl,iy+0     ;start z80 pages over again for mirroring
    jr --_

;==============================================================================
;
;    #   # ##### #   #  ###  #### #   #     #   #  ###  ####  #####  ###  
;    ## ## #     ## ## #   # #   # # #      ## ## #   # #   # #     #     
;    # # # ###   # # # #   # ####   #       # # # #   # #   # ###    ###  
;    # # # #     # # # #   # #  ##  #       #   # #   # #   # #         # 
;    #   # ##### #   #  ###  #   #  #       #   #  ###  ####  #####  ###  
;
;==============================================================================

;:You probably shouldn't.
;EDIT. YOU SHALL NOT. THIS IS BEING BAKED INTO EACH INSTRUCTION.
;a6502_adrmode_read_imm:
;    ld  a,(hl)
;    ret

;That ret is making it slow.
a6502_adrmode_read_zp:
    ld  bc,ZEROPAGE
    ld  c,(hl)
    ld  a,(bc)
    ret

a6502_adrmode_read_zpx:
    ld  bc,ZEROPAGE
    ld  a,(ix+REGX)
    add a,(hl)
    ld  c,a
    ld  a,(bc)
    ret

a6502_adrmode_read_zpy:
    ld  bc,ZEROPAGE
    ld  a,(ix+REGY)
    add a,(hl)
    ld  c,a
    ld  a,(bc)
    ret

;Oh yeah. It gets juicy.
a6502_adrmode_read_abs:
    ld  a,(hl)
    inc hl
    inc e
    jr  nz,+_
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  b,d
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
_:  exx
    ld  e,a         ;LSB
    exx
    ld  a,(hl)
    exx
    ld  b,a
    ld  d,a
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,e
    add hl,bc
    ret                     ;D=MSB, C=LSB, HL=address

a6502_adrmode_read_absx:
    ld  a,(hl)              ;read first byte of abs val
    inc hl
    inc e
    jr  nz,+_               ;and adjust page if needed
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  c,BASETABLE_STRIDE
    ld  b,d
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
_:  exx
    add a,(ix+REGX)         ;add X to abs lsb
    ld  e,a                 ;and store to shadow E
    exx
    ld  a,(hl)              ;read second byte of abs val
    exx
    jr  nc,+_               ;adjust timing if page increment
    ADDCYC(1)
    inc a
_:  ld  b,a                 ;MSB to page lookup. MSB peserved to A
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)             ;page address found
    ld  b,0
    ld  c,e
    add hl,bc
    ld  d,a                 ;D=MSB, C=LSB, HL=address
    ret

a6502_adrmode_read_absy:
    ld  a,(hl)          ;fetch LSB of abs val
    inc hl
    inc e
    jr  nz,+_           ;page adjust if needed
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  c,BASETABLE_STRIDE
    ld  b,d
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
_:  exx
    add a,(ix+REGY)
    ld  e,a                 ;and store to shadow E
    exx
    ld  a,(hl)              ;read second byte of abs val
    exx
    jr  nc,+_               ;adjust timing if page increment
    ADDCYC(1)
    inc a
_:  ld  b,a                 ;MSB to page lookup. MSB peserved to A
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)             ;page address found
    ld  b,0
    ld  c,e
    add hl,bc
    ld  d,a                 ;D=MSB, C=LSB, HL=address
    ret

;Much the same as above, but does not adjust cycle count on page crossing
a6502_adrmode_write_absx:
    ld  a,(hl)
    inc hl
    inc e
    jr  nz,+_
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  c,BASETABLE_STRIDE
    ld  b,d
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
_:  exx
    add a,(ix+REGX)
    ld  e,a     ;LSB
    exx
    ld  a,(hl)
    exx
    adc a,0     ;MSB adjusted if needed
    ld  b,a     ;MSB D and A
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,e
    add hl,bc
    ld  d,a     ;D=MSB, C=LSB, HL=address
    ret


a6502_adrmode_write_absy:
    ld  a,(hl)
    inc hl
    inc e
    jr  nz,+_
    ld  d,(ix+REGPC+1)
    inc d
    ld.s (ix+REGPC),de
    ld  c,BASETABLE_STRIDE
    ld  b,d
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
_:  exx
    add a,(ix+REGY)
    ld  e,a     ;LSB
    exx
    ld  a,(hl)
    exx
    adc a,0     ;MSB adjusted if needed
    ld  b,a     ;MSB D and A
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,e
    add hl,bc
    ld  d,a     ;D=MSB, C=LSB, HL=address
    ret

a6502_adrmode_read_indx:
    ld  a,(hl)
    exx
    ld  hl,ZEROPAGE
    add a,(ix+REGX)
    ld  L,a
    ld  a,(hl)
    inc L
    ld  d,(hl)
    ld  b,d
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,a
    add hl,bc
    ret

a6502_adrmode_read_indy:
    ld  a,(hl)
    exx
    ld  hl,ZEROPAGE
    ld  L,a
    ld  a,(hl)
    inc L
    add a,(ix+REGY)
    ld  b,(hl)
    jr  nc,+_
    ADDCYC(1)
    inc b
_:  ld  d,b
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,a
    add hl,bc
    ret         ;D=MSB C=LSB HL=address

a6502_adrmode_write_indy:
    ld  a,(hl)
    exx
    ld  hl,ZEROPAGE
    ld  L,a
    ld  a,(hl)
    inc L
    add a,(ix+REGY)
    ld  e,a         ;LSB
    ld  a,(hl)
    adc a,0
    ld  d,a
    ld  b,a
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,e
    add hl,bc
    ret         ;D=MSB C=LSB HL=address


;==============================================================================
;
; #   #  #  ##  ### ##   ### ##  #  ## ### ###  # #  ## ### ###  ##  ##  #  ## 
; ## ## # # # # #   # #   #  ##  # #    #  #  # # # #    #   #  #  # ##  # #   
; # # # # # # # ##  # #   #  # # #  ##  #  ###  # # #    #   #  #  # # # #  ## 
; #   # # # # # #   # #   #  #  ##    # #  #  # # # #    #   #  #  # #  ##    #
; #   #  #  ##  ### ##   ### #  ##  ##  #  #  # ###  ##  #  ###  ##  #  ##  ## 
;
;==============================================================================
; * For read-only instructions, you accept data in register A. The constructor
;   will have a read or read/write opener that outputs data to A, and flips
;   the registers to the nonshadow versions by the time it is receieved.
; * For instructions containing writes, they come in two forms:
;   1. Write-to-(BC)
;       These aren't gated, and the data in (BC) is also in A. Best to use A
;       since I think there's a few illegals that takes immediate data too.
;   2. Write-to-(HL).
;       All registers incoming are shadow registers. Your free and available
;       registers are thus B and E.
;       Read-accesses are passed in through register A, for which you do ops.
;       Write-accesses are passed in through register B to input D=MSB, C=LSB,
;           and HL=address.
;       DO NOT EXX AT THE END. THE RETURN-TO-INSTRUCTION-FETCHER WILL DO THAT.



;------------------------------------------
    ld  a,(hl)
a6502_inst_lda:
    ld  (ix+REGA),a
    ld  b,a
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_ldx:
    ld  (ix+REGX),a
    ld  b,a
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_ldy:
    ld  (ix+REGY),a
    ld  b,a
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
;------------------------------------------
a6502_inst_sta_bc:
    ld  a,(ix+REGA)
    ld  (bc),a
    ret

a6502_inst_sta_hl:
    ld  b,(ix+REGA)
    ret
;------------------------------------------
a6502_inst_stx_bc:
    ld  a,(ix+REGX)
    ld  (bc),a
    ret

a6502_inst_stx_hl:
    ld  b,(ix+REGX)
    ret
;------------------------------------------
a6502_inst_sty_bc:
    ld  a,(ix+REGY)
    ld  (bc),a
    ret

a6502_inst_sty_hl:
    ld  b,(ix+REGY)
    ret
;------------------------------------------
a6502_inst_dec_bc:
    dec a
    ld  (bc),a
    ld  b,a
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret

a6502_inst_dec_hl:
    ld  b,a
    ex  af,af'
    dec b
    ex  af,af'
    ret
;------------------------------------------
a6502_inst_inc_bc:
    inc a
    ld  (bc),a
    ld  b,a
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret

a6502_inst_inc_hl:
    ld  b,a
    ex  af,af'
    inc b
    ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_adc_bc:
a6502_inst_adc_hl:
    ld  b,a
    ex  af,af'
    ld  a,(ix+REGA)
    adc a,b
    ld  (ix+REGA),a
    res SF_OVER,(ix+REGSR)
    jp  po,+_
    set SF_OVER,(ix+REGSR)
_:  ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_sbc_bc:
a6502_inst_sbc_hl:
    ld  b,a
    ex  af,af'
    ld  a,(ix+REGA)
    ccf
    sbc a,b
    ccf
    ld  (ix+REGA),a
    res SF_OVER,(ix+REGSR)
    jp  po,+_
    set SF_OVER,(ix+REGSR)
_:  ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_and_bc:
a6502_inst_and_hl:
    ld  c,a
    ex  af,af'
    ld  a,c
    ld  b,(ix+REGA)
    jr  nc,+_
    and a,b
    ld  (ix+REGA),a
    scf
    ex  af,af'
    ret
_:  and a,b
    ld  (ix+REGA),a
    ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_eor_bc:
a6502_inst_eor_hl:
    ld  c,a
    ex  af,af'
    ld  a,c
    ld  b,(ix+REGA)
    jr  nc,+_
    xor a,b
    ld  (ix+REGA),a
    scf
    ex  af,af'
    ret
_:  xor a,b
    ld  (ix+REGA),a
    ex  af,af'
    ret

;------------------------------------------
    ld  a,(hl)
a6502_inst_or_bc:
a6502_inst_or_hl:
    ld  c,a
    ex  af,af'
    ld  a,c
    ld  b,(ix+REGA)
    jr  nc,+_
    or  a,b
    ld  (ix+REGA),a
    scf
    ex  af,af'
    ret
_:  or  a,b
    ld  (ix+REGA),a
    ex  af,af'
    ret

;------------------------------------------
a6502_inst_asl_bc:
    ld  d,a
    ex  af,af'
    sla d
    ex  af,af'
    ld  a,d
    ld  (bc),a
    ret

a6502_inst_asl_hl:
    ld  b,a
    ex  af,af'
    sla b
    ex  af,af'
    ret
;------------------------------------------
a6502_inst_lsr_bc:
    ld  d,a
    ex  af,af'
    srl d
    ex  af,af'
    ld  a,d
    ld  (bc),a
    ret

a6502_inst_lsr_hl:
    ld  b,a
    ex  af,af'
    srl b
    ex  af,af'
    ret
;------------------------------------------
a6502_inst_rol_bc:
    ld  d,a
    ex  af,af'
    rl  d
    ex  af,af'
    ld  a,d
    ld  (bc),a
    ret

a6502_inst_rol_hl:
    ld  b,a
    ex  af,af'
    rl  b
    ex  af,af'
    ret
;------------------------------------------
a6502_inst_ror_bc:
    ld  d,a
    ex  af,af'
    rr  d
    ex  af,af'
    ld  a,d
    ld  (bc),a
    ret

a6502_inst_ror_hl:
    ld  b,a
    ex  af,af'
    rr  b
    ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_cmp_bc:
a6502_inst_cmp_hl:
    ld  b,a
    ex  af,af'
    ld  a,(ix+REGA)
    cp  a,b
    ccf
    ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_cpx_bc:
a6502_inst_cpx_hl:
    ld  b,a
    ex  af,af'
    ld  a,(ix+REGX)
    cp  a,b
    ccf
    ex  af,af'
    ret
;------------------------------------------
    ld  a,(hl)
a6502_inst_cpy_bc:
a6502_inst_cpy_hl:
    ld  b,a
    ex  af,af'
    ld  a,(ix+REGY)
    cp  a,b
    ccf
    ex  af,af'
    ret
;------------------------------------------
a6502_inst_bit_bc:  ;Only zp uses this.
a6502_inst_bit_hl:  ;Only abs uses this.
    ld  c,a         ;Save operand for bits 6 and 7
    and a,(ix+REGA) ;AND with A, discard actual result other than if zero
    ld  a,c         ;Restore operand
    res SF_ZERO,a
    jr  nz,+_
    set SF_ZERO,a   ;And manually set zero flag in the operand.
_:  ld  bc,flags6502toNativeLUT
    ld  c,a         ;Non-native bits in-place. Carry bit may or may not be set.
    ld  a,(bc)      ;Get native flags.
    rrca            ;[-SZ-H-PN]
    ld  c,a         ;save flag rotated to receive carry
    ex  af,af'      
    rl c            ;[SZ-H-PNC]
    push.s bc
    pop.s af        ;flags reestablished.
    res SF_OVER,(ix+REGSR)
    jp  po,+_
    set SF_OVER,(ix+REGSR)
_:  ex  af,af'
    ret


;-------------------------------------------------------------------------------
; # #  #  ### ##  #  #     #  ##   ##  #  ##  ###  ##    #  #  ## ### # ##   ##                                      
; # #  #  ## #   # # #    # # # # #   # # # # ##  #      #  # #    #  # # # #                               
; # #  #  #  # # ### #    # # ##  #   # # # # #    ##    #  #  ##  #  # # # # #                                     
; # ## ## ### ## # # ##    #  #    ##  #  ##  ### ##     ## # ##   #  # # #  ##                                       
;-------------------------------------------------------------------------------
 
a6502_inst_dcp_bc:
    dec a
    ld  (bc),a
    ld  c,a
    ex  af,af'
    ld  a,(ix+REGA)
    cp  a,c
    ccf
    ex  af,af'
    ret

;NOTE: a6502_inst_dcp_hl has special considerations, so must be special-cased
;       during generation
a6502_inst_dcp_hl_seg1: ;Placed after initial R/RMW access as normal.
    dec a
    ld  b,a
    ld  (+_+1),a
    ret

a6502_inst_dcp_hl_seg2: ;Placed after the W access
    ex  af,af'
    ld  a,(ix+REGA)
_:  cp  a,0     ;SMC'd for second segment.
    ccf
    ex  af,af'
    ret

;------------------------------------------------------------------------------
a6502_inst_isc_bc:
    inc a
    ld  (bc),a
    ld  c,a
    ex  af,af'
    ld  a,(ix+REGA)
    ccf
    sbc a,c
    ccf
    ld  (ix+REGA),a
    res SF_OVER,(ix+REGSR)
    jp  po,+_
    set SF_OVER,(ix+REGSR)
_:  ex  af,af'
    ret

;NOTE: a6502_inst_isc_hl also has special considerations,
;        so must be special-cased during generation.
a6502_inst_isc_hl_seg1: ;Placed after initial R/RMW access as normal.
    inc a
    ld  b,a
    ld  (+_+1),a
    ret

a6502_inst_isc_hl_seg2: ;Placed after the W access
    ex  af,af'
    ld  a,(ix+REGA)
    ccf
_:  sbc a,0
    ccf
    ld  (ix+REGA),a
    res SF_OVER,(ix+REGSR)
    jp  po,+_
    set SF_OVER,(ix+REGSR)
_:  ex  af,af'
    ret
;------------------------------------------------------------------------------
    ld  a,(hl)
a6502_inst_lax_bc:
a6502_inst_lax_hl:
    ld  (ix+REGA),a
    ld  (ix+REGX),a
    ld  b,a
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
;------------------------------------------------------------------------------
;M = C <- [76543210] <- C, A AND M -> A. flags CZN
;Flags juggling required to preserve C while doing (A AND M).
a6502_inst_rla_bc:
    ld  d,a
    ex  af,af'
    ld  a,d
    rla             ;1st half oper once
    ld  (bc),a
    and a,(ix+REGA) ;2nd half oper
    ld  (ix+REGA),a
    push.s af
    pop.s bc
    srl c       ;prep flag for carry insert
    rl d        ;1st half oper for carry
    rl c        ;realign flags
    push.s bc
    pop.s af    ;flags set
    ex  af,af'
    ret

a6502_inst_rla_hl_seg1:
    ld  b,a
    ex  af,af'
    rl  b
    ld  a,b
    ld  (+_+1),a
    ex  af,af'
    ret

a6502_inst_rla_hl_seg2:
    ld  a,(ix+REGA)
_:  and a,0
    ld  (ix+REGA),a
    push.s af
    ex  af,af'
    adc a,a
    pop.s bc
    srl c
    rrca
    rl c
    push.s bc
    pop.s af
    ex  af,af'
    ret
;------------------------------------------------------------------------------
;RRA
;ROR oper + ADC oper
;M = C -> [76543210] -> C, A + M + C -> A, C. Affects VCZN

a6502_inst_rra_bc:
    ld  d,a
    ex  af,af'
    ld  a,d
    rra
    ld  (bc),a
    adc a,(ix+REGA)
    ld  (ix+REGA),a
    res SF_OVER,(ix+REGSR)
    jp  po,+_
    set SF_OVER,(ix+REGSR)
_:  ex  af,af'
    ret

a6502_inst_rra_hl_seg1:
    ld  b,a
    ex  af,af'
    rr  b
    ld  a,b
    ex  af,af'
    ret

a6502_inst_rra_hl_seg2:
    ex  af,af'
    adc a,(ix+REGA)
    ld  (ix+REGA),a
    res SF_OVER,(ix+REGSR)
    jp  po,+_
    set SF_OVER,(ix+REGSR)
_:  ex  af,af'
    ret
;------------------------------------------------------------------------------
;SAX (AXS, AAX) - A AND X -> M
;A and X are put on the bus at the same time (resulting effectively in an 
;AND operation) and stored in M. Flags not affected.

a6502_inst_sax_bc:
    ld  a,(ix+REGA)
    and a,(ix+REGX)
    ld  (bc),a
    ret

a6502_inst_sax_hl:
    ld  a,(ix+REGA)
    and a,(ix+REGX)
    ld  b,a
    ret
;------------------------------------------------------------------------------
;SLO (ASO) - ASL oper + ORA oper
;M = C <- [76543210] <- 0, A OR M -> A. Affects: CZN
a6502_inst_slo_bc:
    ld  d,a
    ex  af,af'
    ld  a,d
    sla a           ;1st half oper once
    ld  (bc),a
    or  a,(ix+REGA) ;2nd half oper
    ld  (ix+REGA),a
    push.s af
    pop.s bc
    srl c       ;prep flag for carry insert
    sla d       ;1st half oper for carry
    rl c        ;realign flags
    push.s bc
    pop.s af    ;flags set
    ex  af,af'
    ret

a6502_inst_slo_hl_seg1:
    ld  b,a
    ex  af,af'
    sla b
    ld  a,b
    ld  (+_+1),a
    ex  af,af'
    ret

a6502_inst_slo_hl_seg2:
    ld  a,(ix+REGA)
_:  or  a,0
    ld  (ix+REGA),a
    push.s af
    ex  af,af'
    adc a,a
    pop.s bc
    srl c
    rrca
    rl c
    push.s bc
    pop.s af
    ex  af,af'
    ret
;-----------------------------------------------------------------------------
;SRE (LSE) - LSR oper + EOR oper
;M = 0 -> [76543210] -> C, A EOR M -> A. Affects: CZN
a6502_inst_sre_bc:
    ld  d,a
    ex  af,af'
    ld  a,d
    srl a           ;1st half oper once
    ld  (bc),a
    xor a,(ix+REGA) ;2nd half oper
    ld  (ix+REGA),a
    push.s af
    pop.s bc
    srl c       ;prep flag for carry insert
    srl d       ;1st half oper for carry
    rl c        ;realign flags
    push.s bc
    pop.s af    ;flags set
    ex  af,af'
    ret

a6502_inst_sre_hl_seg1:
    ld  b,a
    ex  af,af'
    srl b
    ld  a,b
    ld  (+_+1),a
    ex  af,af'
    ret

a6502_inst_sre_hl_seg2:
    ld  a,(ix+REGA)
_:  xor a,0
    ld  (ix+REGA),a
    push.s af
    ex  af,af'
    adc a,a
    pop.s bc
    srl c
    rrca
    rl c
    push.s bc
    pop.s af
    ex  af,af'
    ret


;==============================================================================
;
;  ##  ##  ### ## #  #  #    # ##  #  ## ### ###  # #  ## ### #  ##  ##  #  ## 
; #    # # #  #   # # # #    # ##  # #    #  #  # # # #    #  # #  # ##  # #   
;  ##  ##  ## #   # ### #    # # # #  ##  #  ###  # # #    #  # #  # # # #  ## 
;    # #   #  #   # # # #    # #  ##    # #  #  # # # #    #  # #  # #  ##    #
;  ##  #   ### ## # # # ###  # #  ##  ##  #  #  # ###  ##  #  #  ##  #  ##  ## 
;
;==============================================================================
; One or more of the following may be true about the instructions below:
; * It supports exactly one memory mode:
;       (e.g.) any transfer instruction (tax, txa, ...), flag instructions, etc.
; * The generalisation is either inefficient, or would make a giant mess to
;   try to clean up.
;       (e.g.) basically all branch and branch-adjacent instructions
; * In the future, you may opt to move certain instructions from normal to
;   special to provide finer-grained control over the return queue, at the cost
;   of having to manually reimplement the changes if the tables ever need to
;   be regenerated via `test.ipynb`
a6502_inst_tax: ;NZ 1b 2cc A->X
    ld  b,(ix+REGA)
    ld  (ix+REGX),b
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
a6502_inst_tay: ;NZ 1b 2cc A->Y
    ld  b,(ix+REGA)
    ld  (ix+REGY),b
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
a6502_inst_tsx: ;NZ 1b 2cc S->X
    ld  b,(ix+REGSP)
    ld  (ix+REGX),b
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
a6502_inst_txa: ;NZ 1b 2cc X->A
    ld  b,(ix+REGX)
    ld  (ix+REGA),b
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
a6502_inst_txs: ;-- 1b 2cc X->S
    ld  b,(ix+REGX)
    ld  (ix+REGSP),b
    ret
a6502_inst_tya: ;NZ 1b 2cc X->A
    ld  b,(ix+REGY)
    ld  (ix+REGA),b
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
a6502_inst_pha: ;flags not affected
    ld  a,(ix+REGA)
    ld  bc,STACKBASE
    ld  c,(ix+REGSP)
    ld  (bc),a
    dec c
    ld  (ix+REGSP),c
    ret

a6502_inst_php: ;Verify that the flags pushed are accurate.
    ex  af,af'
    push.s af
    pop.s bc
    ex  af,af'
    ld  a,c
    ld  bc,flagsZ80to6502LUT
    ld  c,a
    ld  a,(bc)
    ld  c,(ix+REGSR)
    xor a,c
    and a,%10000011
    xor a,c
    or  a,%00110000     ;Push value with BRK and b5 set.
    ld  bc,STACKBASE
    ld  c,(ix+REGSP)
    ld  (bc),a
    dec c
    ld  (ix+REGSP),c
    ret

a6502_inst_pla:
    ld  bc,STACKBASE
    ld  c,(ix+REGSP)
    inc c
    ld  a,(bc)
    ld  (ix+REGSP),c
    ld  (ix+REGA),a
    ld  b,a
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret

a6502_inst_plp:     ;Verify that flag reconstruct to native is valid.
    ld  bc,STACKBASE
    ld  c,(ix+REGSP)
    inc c
    ld  a,(bc)
    ld  (ix+REGSP),c
    ld  b,(ix+REGSR)
    xor a,b
    and a,%11001111
    xor a,b         ;BRK and b5 ignored when pulling
    ld  (ix+REGSR),a
    ld  bc,flags6502toNativeLUT
    ld  c,a
    ld  a,(bc)
    ld  c,a
    ex  af,af'
    push.s bc
    pop.s af
    ex  af,af'
    ret

a6502_inst_dex:
    ex  af,af'
    dec (ix+REGX)
    ex  af,af'
    ret
a6502_inst_dey:
    ex  af,af'
    dec (ix+REGY)
    ex  af,af'
    ret
a6502_inst_inx:
    ex  af,af'
    inc (ix+REGX)
    ex  af,af'
    ret
a6502_inst_iny:
    ex  af,af'
    inc (ix+REGY)
    ex  af,af'
    ret
a6502_inst_asl: ;it has other memory modes, but this one operates on reg A too.
    ex  af,af'
    sla (ix+REGA)
    ex  af,af'
    ret
a6502_inst_lsr: ;it has other memory modes, but this one operates on reg A too.
    ex  af,af'
    srl (ix+REGA)
    ex  af,af'
    ret
a6502_inst_rol: ;it has other memory modes, but this one operates on reg A too.
    ex  af,af'
    rl  (ix+REGA)
    ex  af,af'
    ret
a6502_inst_ror: ;it has other memory modes, but this one operates on reg A too.
    ex  af,af'
    rr  (ix+REGA)
    ex  af,af'
    ret
a6502_inst_clc:
    ex  af,af'
    scf
    ccf
    ex  af,af'
    ret
a6502_inst_cld:
    res SF_DEC,(ix+REGSR)
    ret
a6502_inst_cli:
    res SF_INT,(ix+REGSR)
    ret
a6502_inst_clv:
    res SF_OVER,(ix+REGSR)
    ret
a6502_inst_sec:
    ex  af,af'
    scf
    ex  af,af'
    ret
a6502_inst_sed:
    set SF_DEC,(ix+REGSR)
    ret
a6502_inst_sei:
    set SF_INT,(ix+REGSR)
    ret
;----------------------------
;Note: ALL BRANCH INSTRUCTIONS HAVE THEIR RET ADDRESS RETURN TO CONSUME THE
;       OFFSET BYTE [a6502_newfetch]. IF THE JUMP IS TAKEN, THIS IS OVERRIDDEN
;       SO THE RETURN WILL INSTEAD BE A JUMP TO [a6502_getInstruction]
a6502_isub_branch:
;Add waitloop detection by copying the routine but adding to it. Copy it to the
;bottom of the branch routine block to prevent any of the JRs being used there
;from going out of range.
a6502_isub_branch_detect_waitloop:
    ex  af,af'
a6502_isub_branch_no_ex:
    ADDCYC(1)
    ld  a,(hl)
    ld  L,a
    add a,a     ;detect if it should be sign-extended
    sbc a,a
    ld  H,a     ;sign-extending offset
    ld  d,(ix+REGPC+1)
    inc de      ;Offset starts from the beginning of the next instruction.
    add.s hl,de ;Calculate new position in HL
    ld  (ix+REGPC+1),h  ;New MSB is tucked away. Won't need to update LSB.
    ld  a,d
    cp  a,h
    jr  z,+_    ;Jump if no pagechange
    ADDCYC(1)
_:  ;Either way, recalculate HL since we lost that calculating new 6502:PC
    ex  de,hl   ;New position now in DE
    ld  b,d
    ld  c,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
    ld  b,0
    ld  c,e
    add hl,bc   ;New address to begin fetching with.
    jp  a6502_getInstruction
;----------------------------
a6502_inst_bcc:
    ex  af,af'
    jr  nc,a6502_isub_branch
    ex  af,af'
    ret
a6502_inst_bcs:
    ex  af,af'
    jr  c,a6502_isub_branch
    ex  af,af'
    ret
a6502_inst_beq:
    ex  af,af'
    jr  z,a6502_isub_branch_detect_waitloop
    ex  af,af'
    ret
a6502_inst_bmi:
    ex  af,af'
    jp  m,a6502_isub_branch
    ex  af,af'
    ret
a6502_inst_bne:
    ex  af,af'
    jr  nz,a6502_isub_branch
    ex  af,af'
    ret
a6502_inst_bpl:
    ex  af,af'
    jp  p,a6502_isub_branch
    ex  af,af'
    ret
a6502_inst_bvc:
    bit SF_OVER,(ix+REGSR)
    ret nz
    jr  a6502_isub_branch_no_ex
a6502_inst_bvs:
    bit SF_OVER,(ix+REGSR)
    ret z
    jr  a6502_isub_branch_no_ex

a6502_inst_brk_from_handler:
inst6502_brk_from_handler:
    ADDCYC(7)
    ld  hl,a6502_flags6502ToNativeLUTGen
    ld  L,(ix+REGSR)
    ld  c,(hl)
    ex  af,af'
    push.s bc
    pop.s af
    ex  af,af'
    ld  sp,CALLTABLE+(BASETABLE_STRIDE*0)+6 ;return address for BRK inst
    ld.s de,(ix+REGPC)
    dec de
    jr  +_

;return to full HL:E reload
a6502_inst_brk:
    ;jr $
    ld.s d,(ix+REGPC)
    inc de      ;that extra spacer.
_:  ld  hl,STACKBASE
    ld  L,(ix+REGSP)
    ld  (hl),d
    dec L
    ld  (hl),e
    dec L
    ex  af,af'
    push.s af
    pop.s bc
    ex  af,af'
    ld  a,c
    ld  bc,flagsZ80to6502LUT
    ld  c,a
    ld  a,(bc)
    ld  c,(ix+REGSR)
    xor a,c
    and a,%10000011
    xor a,c
    set SF_INT,a
    ld  (hl),a
    dec L
    ld  (ix+REGSP),L
    WAS_NMI_TRIGGERED
    ld  bc,$FE  ;IRQ vector
    jr  z,+_
    ld  bc,$FA  ;NMI vector, if NMI is hijacking this instruction.
_:  ld  hl,(BASETABLE_STRIDE*$FF)+PAGETABLE
    ld  hl,(hl)
    add hl,bc
    ld  de,(hl)
    ld.s (ix+REGPC),de
    ret

;Return to full HL:E reload
a6502_inst_rti:
    ld  hl,STACKBASE
    ld  L,(ix+REGSP)
    inc L
    ld  a,(hl)
    inc L
    ld  e,(hl)
    inc L
    ld  d,(hl)
    ld  (ix+REGSP),L
    ld.s (ix+REGPC),de
    ld  b,(ix+REGSR)
    xor a,b
    and a,%11001111
    xor a,b
    ld  (ix+REGSR),a
    ld  bc,flags6502toNativeLUT
    ld  c,a
    ld  a,(bc)
    ld  c,a
    ex  af,af'
    push.s bc
    pop.s af
    ex  af,af'
    ret

;Return to full HL:E reload
a6502_inst_jmp_abs:
    ld  d,(ix+REGPC+1)
    ld  a,(hl)
    inc hl
    inc e
    jr  nz,+_
    inc d
    ld  c,d
    ld  b,BASETABLE_STRIDE
    mlt bc
    ld  hl,PAGETABLE
    add hl,bc
    ld  hl,(hl)
_:  ld  h,(hl)
    ld  L,a     ;HL= new address
    dec de
    dec de
    ex.s de,hl
    or  a,a
    sbc hl,de
    ld.s (ix+REGPC),de
    ret nz
a6502_inf_loop_detected:
    ld  bc,(a6502_int_timer)
    or  a,a
    sbc hl,hl
    sbc hl,bc   ;negate expected interrupt result to a positive number
    ld  (ix+TEMP_MEMORY),hl ;Accurate timing be damned. I just want the next
    ld  iy,(ix+TEMP_MEMORY) ;interrupt-like event to trigger.
    ret

;return to full HL:E reload
a6502_inst_jmp_ind:
    ;jr $
    ld  bc,PAGETABLE
    ld  a,(hl)
    inc hl
    inc e
    jr  nz,+_
    ld  h,(ix+REGPC+1)
    inc h
    ld  L,BASETABLE_STRIDE
    mlt hl
    add hl,bc
    ld  hl,(hl)
_:  ld  h,(hl)  ;high byte destination address
    ld  L,a     ;low byte destination address
    inc L       ;Check if there will be a split read.
    ld  L,BASETABLE_STRIDE
    mlt hl
    jr  z,+_        ;jump if split read.
    add hl,bc       ;add high byte offset into pagetable
    ld  bc,(hl)     ;address of page start
    sbc hl,hl
    ld  L,a         ;set offset into page start
    add hl,bc       ;complete offset
    ld  de,(hl)     ;read address at that location
    ld.s (ix+REGPC),de  ;and store it, returning to full reload.
    ret
_:  add hl,bc       ;add high byte offset into pagetable
    ld  hl,(hl)     ;address of page start
    ld  d,(hl)      ;high byte at start of page
    ld  bc,255
    add hl,bc
    ld  e,(hl)      ;low byte at end of page
    ld.s (ix+REGPC),de
    ret

;Full HL:E reload
a6502_inst_jsr:
    ld  d,(ix+REGPC+1)
    ld  c,(hl)
    inc hl
    inc e
    jr  nz,+_
    inc d
    ld  a,d
    ld  e,BASETABLE_STRIDE
    mlt de
    ld  hl,PAGETABLE
    add hl,de
    ld  hl,(hl)
    ld  d,a
    ld  e,0
_:  ld  b,(hl)
    ld  hl,STACKBASE
    ld  L,(ix+REGSP)
    ld  (hl),d
    dec L
    ld  (hl),e
    dec L
    ld  (ix+REGSP),L
    ld.s (ix+REGPC),bc
    ret

;Full HL:E reload
a6502_inst_rts:
    ld  hl,STACKBASE
    ld  L,(ix+REGSP)
    inc L
    ld  e,(hl)
    inc L
    ld  d,(hl)
    ld  (ix+REGSP),L
    inc de
    ld.s (ix+REGPC),de
    ret

;Official NOP. Reload to immediately load the next instruction.
;This can be skipped.
a6502_inst_nop:
    ret

a6502_jamx:
    jr $

;-------------------------------------------------------------------------------
; # #  #  ### ##  #  #     #  ##   ##  #  ##  ###  ##    #  #  ## ### # ##   ##                                      
; # #  #  ## #   # # #    # # # # #   # # # # ##  #      #  # #    #  # # # #                               
; # #  #  #  # # ### #    # # ##  #   # # # # #    ##    #  #  ##  #  # # # # #                                     
; # ## ## ### ## # # ##    #  #    ##  #  ##  ### ##     ## # ##   #  # # #  ##                                       
;-------------------------------------------------------------------------------
;Unofficial instructions. Surprisingly many of them are usable. A few are
;unstable. A few more will lock up the CPU, making their use for alternate
;emulator-specific purposes an appealing idea. HINT HINT NUDGE NUDGE.
;
a6502_inst_alr:     ;imm, opc $4B
    ex  af,af'
    ld  a,(ix+REGA)
    and a,(hl)
    srl a
    ld  (ix+REGA),a
    ex  af,af'
    ret

a6502_inst_anc:     ;imm, opc $0B
a6502_inst_anc2:    ;imm, opc $2B
    ld  a,(ix+REGA)
    and a,(hl)
    ld  (ix+REGA),a
    ld  c,a
    ex  af,af'
    rl  c       ;Just affect flags.
    ex  af,af'
    ret

a6502_inst_ane:     ;imm, opc $88. Highly unstable. But probably implementable.
    ld  a,r
    or  a,(ix+REGA)
    and a,(ix+REGX)
    and a,(hl)
    ld  (ix+REGA),a
    ld  c,a
    ex  af,af'
    inc c
    dec c
    ex  af,af'
    ret

a6502_inst_arr:     ;imm, opc $6B
    ld  a,(ix+REGA)
    and a,(hl)
    ld  c,a ;oldval
    ex  af,af'
    rr  c
    ld  a,c
    add a,a
    xor a,c ;V check. V=b5^b6.
    res SF_OVER,(ix+REGSR)
    jr  z,+_
    set SF_OVER,(ix+REGSR)
_:  ld  a,c
    add a,a
    add a,a ;C check. Puts bit 6 into carry
    inc c
    dec c   ;Sets N and Z appropriately.
    ex  af,af'
    ret

a6502_inst_las:     ;absy, opc $BB. Prefix with normal absy. Read access only.
    and a,(ix+REGSP)
    ld  c,a
    ld  (ix+REGA),a
    ld  (ix+REGX),a
    ld  (ix+REGSP),a
    ex  af,af'
    inc c
    dec c
    ex  af,af'
    ret

a6502_inst_lxa:     ;imm, opc $AB. Highly unstable. See ANE.
    ld  a,r     ;?? HIGHLY UNSTABLE INSTRUCTION
    or  a,(ix+REGA)
    and a,(hl)
    ld  (ix+REGA),a
    ld  (ix+REGX),a
    ld  b,a
    ex  af,af'
    inc b
    dec b
    ex  af,af'
    ret
    
a6502_inst_sbx:     ;imm, opc $CB. (A AND X) - oper -> X. flags CZN
    ld  b,a
    ex  af,af'
    ld  a,(ix+REGA)
    and a,(ix+REGX)
    sub a,b
    ld  (ix+REGX),a
    ccf
    ex  af,af'
    ret

a6502_inst_sha:     ;9F, 93
a6502_inst_shx:     ;9E
a6502_inst_shy:     ;9C
a6502_inst_tas:     ;9B
a6502_inst_usbc:    ;EB Map this to instruction $E9 (inst6502_sbc_imm)
    ret








a6502_main_table:
A6502T(MEMACC_NO, ADRMODE_SPEC, 7, ISC_BRK)    ;00
A6502T(MEMACC_R , ADRMODE_INDX, 6, ISC_ORA)    ;01
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;02
A6502T(MEMACC_RW, ADRMODE_INDX, 8, ISC_SLO)    ;03
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_NOPM)    ;04
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_ORA)    ;05
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_ASL)    ;06
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_SLO)    ;07
A6502T(MEMACC_NO, ADRMODE_SPEC, 3, ISC_PHP)    ;08
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_ORA)    ;09
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_ASLA)    ;0A
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_ANC)    ;0B
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_NOPM)    ;0C
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_ORA)    ;0D
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_ASL)    ;0E
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_SLO)    ;0F
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_BPL)    ;10
A6502T(MEMACC_R , ADRMODE_INDY, 5, ISC_ORA)    ;11
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;12
A6502T(MEMACC_RW, ADRMODE_INDYF, 8, ISC_SLO)    ;13
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_NOPM)    ;14
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_ORA)    ;15
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_ASL)    ;16
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_SLO)    ;17
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_CLC)    ;18
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_ORA)    ;19
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_NOPI)    ;1A
A6502T(MEMACC_RW, ADRMODE_ABSYF, 7, ISC_SLO)    ;1B
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_NOPM)    ;1C
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_ORA)    ;1D
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_ASL)    ;1E
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_SLO)    ;1F
A6502T(MEMACC_NO, ADRMODE_SPEC, 6, ISC_JSR)    ;20
A6502T(MEMACC_R , ADRMODE_INDX, 6, ISC_AND)    ;21
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;22
A6502T(MEMACC_RW, ADRMODE_INDX, 8, ISC_RLA)    ;23
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_BIT)    ;24
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_AND)    ;25
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_ROL)    ;26
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_RLA)    ;27
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_PLP)    ;28
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_AND)    ;29
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_ROLA)    ;2A
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_ANC)    ;2B
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_BIT)    ;2C
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_AND)    ;2D
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_ROL)    ;2E
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_RLA)    ;2F
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_BMI)    ;30
A6502T(MEMACC_R , ADRMODE_INDY, 5, ISC_AND)    ;31
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;32
A6502T(MEMACC_RW, ADRMODE_INDYF, 8, ISC_RLA)    ;33
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_NOPM)    ;34
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_AND)    ;35
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_ROL)    ;36
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_RLA)    ;37
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_SEC)    ;38
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_AND)    ;39
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_NOPI)    ;3A
A6502T(MEMACC_RW, ADRMODE_ABSYF, 7, ISC_RLA)    ;3B
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_NOPM)    ;3C
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_AND)    ;3D
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_ROL)    ;3E
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_RLA)    ;3F
A6502T(MEMACC_NO, ADRMODE_SPEC, 6, ISC_RTI)    ;40
A6502T(MEMACC_R , ADRMODE_INDX, 6, ISC_EOR)    ;41
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;42
A6502T(MEMACC_RW, ADRMODE_INDX, 8, ISC_SRE)    ;43
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_NOPM)    ;44
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_EOR)    ;45
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_LSR)    ;46
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_SRE)    ;47
A6502T(MEMACC_NO, ADRMODE_SPEC, 3, ISC_PHA)    ;48
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_EOR)    ;49
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_LSRA)    ;4A
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_ALR)    ;4B
A6502T(MEMACC_NO, ADRMODE_SPEC, 3, ISC_JMPA)    ;4C
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_EOR)    ;4D
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_LSR)    ;4E
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_SRE)    ;4F
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_BVC)    ;50
A6502T(MEMACC_R , ADRMODE_INDY, 5, ISC_EOR)    ;51
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;52
A6502T(MEMACC_RW, ADRMODE_INDYF, 8, ISC_SRE)    ;53
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_NOPM)    ;54
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_EOR)    ;55
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_LSR)    ;56
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_SRE)    ;57
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_CLI)    ;58
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_EOR)    ;59
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_NOPI)    ;5A
A6502T(MEMACC_RW, ADRMODE_ABSYF, 7, ISC_SRE)    ;5B
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_NOPM)    ;5C
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_EOR)    ;5D
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_LSR)    ;5E
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_SRE)    ;5F
A6502T(MEMACC_NO, ADRMODE_SPEC, 6, ISC_RTS)    ;60
A6502T(MEMACC_R , ADRMODE_INDX, 6, ISC_ADC)    ;61
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;62
A6502T(MEMACC_RW, ADRMODE_INDX, 8, ISC_RRA)    ;63
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_NOPM)    ;64
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_ADC)    ;65
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_ROR)    ;66
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_RRA)    ;67
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_PLA)    ;68
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_ADC)    ;69
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_RORA)    ;6A
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_ARR)    ;6B
A6502T(MEMACC_NO, ADRMODE_SPEC, 5, ISC_JMPI)    ;6C
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_ADC)    ;6D
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_ROR)    ;6E
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_RRA)    ;6F
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_BVS)    ;70
A6502T(MEMACC_R , ADRMODE_INDY, 5, ISC_ADC)    ;71
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;72
A6502T(MEMACC_RW, ADRMODE_INDYF, 8, ISC_RRA)    ;73
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_NOPM)    ;74
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_ADC)    ;75
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_ROR)    ;76
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_RRA)    ;77
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_SEI)    ;78
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_ADC)    ;79
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_NOPI)    ;7A
A6502T(MEMACC_RW, ADRMODE_ABSYF, 7, ISC_RRA)    ;7B
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_NOPM)    ;7C
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_ADC)    ;7D
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_ROR)    ;7E
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_RRA)    ;7F
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_NOPM)    ;80
A6502T(MEMACC_W , ADRMODE_INDX, 6, ISC_STA)    ;81
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_NOPM)    ;82
A6502T(MEMACC_W , ADRMODE_INDX, 6, ISC_SAX)    ;83
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_STY)    ;84
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_STA)    ;85
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_STX)    ;86
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_SAX)    ;87
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_DEY)    ;88
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_NOPM)    ;89
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_TXA)    ;8A
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_ANE)    ;8B
A6502T(MEMACC_W , ADRMODE_ABS , 4, ISC_STY)    ;8C
A6502T(MEMACC_W , ADRMODE_ABS , 4, ISC_STA)    ;8D
A6502T(MEMACC_W , ADRMODE_ABS , 4, ISC_STX)    ;8E
A6502T(MEMACC_W , ADRMODE_ABS , 4, ISC_SAX)    ;8F
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_BCC)    ;90
A6502T(MEMACC_W , ADRMODE_INDYF, 6, ISC_STA)    ;91
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;92
A6502T(MEMACC_RW, ADRMODE_INDYF, 6, ISC_SHA)    ;93
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_STY)    ;94
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_STA)    ;95
A6502T(MEMACC_NO, ADRMODE_ZPY , 4, ISC_STX)    ;96
A6502T(MEMACC_NO, ADRMODE_ZPY , 4, ISC_SAX)    ;97
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_TYA)    ;98
A6502T(MEMACC_W , ADRMODE_ABSYF, 5, ISC_STA)    ;99
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_TXS)    ;9A
A6502T(MEMACC_R , ADRMODE_ABSY, 5, ISC_TAS)    ;9B
A6502T(MEMACC_R , ADRMODE_ABSX, 5, ISC_SHY)    ;9C
A6502T(MEMACC_W , ADRMODE_ABSXF, 5, ISC_STA)    ;9D
A6502T(MEMACC_R , ADRMODE_ABSY, 5, ISC_SHX)    ;9E
A6502T(MEMACC_RW, ADRMODE_ABSYF, 5, ISC_SHA)    ;9F
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_LDY)    ;A0
A6502T(MEMACC_R , ADRMODE_INDX, 6, ISC_LDA)    ;A1
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_LDX)    ;A2
A6502T(MEMACC_R , ADRMODE_INDX, 6, ISC_LAX)    ;A3
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_LDY)    ;A4
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_LDA)    ;A5
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_LDX)    ;A6
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_LAX)    ;A7
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_TAY)    ;A8
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_LDA)    ;A9
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_TAX)    ;AA
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_LXA)    ;AB
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_LDY)    ;AC
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_LDA)    ;AD
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_LDX)    ;AE
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_LAX)    ;AF
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_BCS)    ;B0
A6502T(MEMACC_R , ADRMODE_INDY, 5, ISC_LDA)    ;B1
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;B2
A6502T(MEMACC_R , ADRMODE_INDY, 5, ISC_LAX)    ;B3
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_LDY)    ;B4
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_LDA)    ;B5
A6502T(MEMACC_NO, ADRMODE_ZPY , 4, ISC_LDX)    ;B6
A6502T(MEMACC_NO, ADRMODE_ZPY , 4, ISC_LAX)    ;B7
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_CLV)    ;B8
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_LDA)    ;B9
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_TSX)    ;BA
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_LAS)    ;BB
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_LDY)    ;BC
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_LDA)    ;BD
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_LDX)    ;BE
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_LAX)    ;BF
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_CPY)    ;C0
A6502T(MEMACC_R , ADRMODE_INDX, 6, ISC_CMP)    ;C1
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_NOPM)    ;C2
A6502T(MEMACC_RW, ADRMODE_INDX, 8, ISC_DCP)    ;C3
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_CPY)    ;C4
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_CMP)    ;C5
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_DEC)    ;C6
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_DCP)    ;C7
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_INY)    ;C8
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_CMP)    ;C9
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_DEX)    ;CA
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_SBX)    ;CB
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_CPY)    ;CC
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_CMP)    ;CD
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_DEC)    ;CE
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_DCP)    ;CF
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_BNE)    ;D0
A6502T(MEMACC_R , ADRMODE_INDY, 5, ISC_CMP)    ;D1
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;D2
A6502T(MEMACC_RW, ADRMODE_INDYF, 8, ISC_DCP)    ;D3
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_NOPM)    ;D4
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_CMP)    ;D5
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_DEC)    ;D6
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_DCP)    ;D7
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_CLD)    ;D8
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_CMP)    ;D9
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_NOPI)    ;DA
A6502T(MEMACC_RW, ADRMODE_ABSYF, 7, ISC_DCP)    ;DB
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_NOPM)    ;DC
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_CMP)    ;DD
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_DEC)    ;DE
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_DCP)    ;DF
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_CPX)    ;E0
A6502T(MEMACC_R , ADRMODE_INDX, 6, ISC_SBC)    ;E1
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_NOPM)    ;E2
A6502T(MEMACC_RW, ADRMODE_INDX, 8, ISC_ISC)    ;E3
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_CPX)    ;E4
A6502T(MEMACC_NO, ADRMODE_ZP  , 3, ISC_SBC)    ;E5
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_INC)    ;E6
A6502T(MEMACC_NO, ADRMODE_ZP  , 5, ISC_ISC)    ;E7
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_INX)    ;E8
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_SBC)    ;E9
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_NOP)    ;EA
A6502T(MEMACC_NO, ADRMODE_IMM , 2, ISC_SBC)    ;EB
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_CPX)    ;EC
A6502T(MEMACC_R , ADRMODE_ABS , 4, ISC_SBC)    ;ED
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_INC)    ;EE
A6502T(MEMACC_RW, ADRMODE_ABS , 6, ISC_ISC)    ;EF
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_BEQ)    ;F0
A6502T(MEMACC_R , ADRMODE_INDY, 5, ISC_SBC)    ;F1
A6502T(MEMACC_NO, ADRMODE_SPEC, 4, ISC_JAM)    ;F2
A6502T(MEMACC_RW, ADRMODE_INDYF, 8, ISC_ISC)    ;F3
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_NOPM)    ;F4
A6502T(MEMACC_NO, ADRMODE_ZPX , 4, ISC_SBC)    ;F5
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_INC)    ;F6
A6502T(MEMACC_NO, ADRMODE_ZPX , 6, ISC_ISC)    ;F7
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_SED)    ;F8
A6502T(MEMACC_R , ADRMODE_ABSY, 4, ISC_SBC)    ;F9
A6502T(MEMACC_NO, ADRMODE_SPEC, 2, ISC_NOPI)    ;FA
A6502T(MEMACC_RW, ADRMODE_ABSYF, 7, ISC_ISC)    ;FB
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_NOPM)    ;FC
A6502T(MEMACC_R , ADRMODE_ABSX, 4, ISC_SBC)    ;FD
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_INC)    ;FE
A6502T(MEMACC_RW, ADRMODE_ABSXF, 7, ISC_ISC)    ;FF
a6502_main_table_end:

a6502_norm_func_table:
.dl a6502_inst_nop    ,a6502_inst_nop      ;ISC_NOPM .equ 0 
.dl a6502_inst_tas    ,a6502_inst_tas      ;ISC_TAS  .equ 1 
.dl a6502_inst_shy    ,a6502_inst_shy      ;ISC_SHY  .equ 2 
.dl a6502_inst_shx    ,a6502_inst_shx      ;ISC_SHX  .equ 3 
.dl a6502_inst_sha    ,a6502_inst_sha      ;ISC_SHA  .equ 4 
.dl a6502_inst_sbx    ,a6502_inst_sbx      ;ISC_SBX  .equ 5 
.dl a6502_inst_sax_bc ,a6502_inst_sax_hl   ;ISC_SAX  .equ 6 
.dl a6502_inst_lxa    ,a6502_inst_lxa      ;ISC_LXA  .equ 7 
.dl a6502_inst_lax_bc ,a6502_inst_lax_hl   ;ISC_LAX  .equ 8 
.dl a6502_inst_las    ,a6502_inst_las      ;ISC_LAS  .equ 9 
.dl a6502_inst_arr    ,a6502_inst_arr      ;ISC_ARR  .equ 10
.dl a6502_inst_ane    ,a6502_inst_ane      ;ISC_ANE  .equ 11
.dl a6502_inst_anc    ,a6502_inst_anc      ;ISC_ANC  .equ 12
.dl a6502_inst_alr    ,a6502_inst_alr      ;ISC_ALR  .equ 13
.dl a6502_inst_bit_bc ,a6502_inst_bit_hl   ;ISC_BIT  .equ 14
.dl a6502_inst_cpy_bc ,a6502_inst_cpy_hl   ;ISC_CPY  .equ 15
.dl a6502_inst_cpx_bc ,a6502_inst_cpx_hl   ;ISC_CPX  .equ 16
.dl a6502_inst_cmp_bc ,a6502_inst_cmp_hl   ;ISC_CMP  .equ 17
.dl a6502_inst_ror_bc ,a6502_inst_ror_hl   ;ISC_ROR  .equ 18
.dl a6502_inst_rol_bc ,a6502_inst_rol_hl   ;ISC_ROL  .equ 19
.dl a6502_inst_lsr_bc ,a6502_inst_lsr_hl   ;ISC_LSR  .equ 20
.dl a6502_inst_asl_bc ,a6502_inst_asl_hl   ;ISC_ASL  .equ 21
.dl a6502_inst_or_bc  ,a6502_inst_or_hl    ;ISC_ORA  .equ 22
.dl a6502_inst_eor_bc ,a6502_inst_eor_hl   ;ISC_EOR  .equ 23
.dl a6502_inst_and_bc ,a6502_inst_and_hl   ;ISC_AND  .equ 24
.dl a6502_inst_sbc_bc ,a6502_inst_sbc_hl   ;ISC_SBC  .equ 25
.dl a6502_inst_adc_bc ,a6502_inst_adc_hl   ;ISC_ADC  .equ 26
.dl a6502_inst_inc_bc ,a6502_inst_inc_hl   ;ISC_INC  .equ 27
.dl a6502_inst_dec_bc ,a6502_inst_dec_hl   ;ISC_DEC  .equ 28
.dl a6502_inst_sty_bc ,a6502_inst_sty_hl   ;ISC_STY  .equ 29
.dl a6502_inst_stx_bc ,a6502_inst_stx_hl   ;ISC_STX  .equ 30
.dl a6502_inst_sta_bc ,a6502_inst_sta_hl   ;ISC_STA  .equ 31
.dl a6502_inst_ldy ,a6502_inst_ldy         ;ISC_LDY  .equ 32
.dl a6502_inst_ldx ,a6502_inst_ldx         ;ISC_LDX  .equ 33
.dl a6502_inst_lda ,a6502_inst_lda         ;ISC_LDA  .equ 34

;Note: Register timings are always in the main table. You should be using that
;to retrieve instruction timings. DO NOT INCLUDE THAT INFORMATION HERE.

a6502_special_specific_case_func_table:
.db 2 \.dl a6502_inst_tax, a6502_getInstruction ;ISC_TAX  .equ 35
.db 2 \.dl a6502_inst_tay, a6502_getInstruction ;ISC_TAY  .equ 36
.db 2 \.dl a6502_inst_tsx, a6502_getInstruction ;ISC_TSX  .equ 37
.db 2 \.dl a6502_inst_txa, a6502_getInstruction ;ISC_TXA  .equ 38
.db 2 \.dl a6502_inst_txs, a6502_getInstruction ;ISC_TXS  .equ 39
.db 2 \.dl a6502_inst_tya, a6502_getInstruction ;ISC_TYA  .equ 40
.db 2 \.dl a6502_inst_pha, a6502_getInstruction ;ISC_PHA  .equ 41
.db 2 \.dl a6502_inst_php, a6502_getInstruction ;ISC_PHP  .equ 42
.db 2 \.dl a6502_inst_pla, a6502_getInstruction ;ISC_PLA  .equ 43
.db 2 \.dl a6502_inst_plp, a6502_getInstruction ;ISC_PLP  .equ 44
.db 2 \.dl a6502_inst_dex, a6502_getInstruction ;ISC_DEX  .equ 45
.db 2 \.dl a6502_inst_dey, a6502_getInstruction ;ISC_DEY  .equ 46
.db 2 \.dl a6502_inst_inx, a6502_getInstruction ;ISC_INX  .equ 47
.db 2 \.dl a6502_inst_iny, a6502_getInstruction ;ISC_INY  .equ 48
.db 2 \.dl a6502_inst_asl, a6502_getInstruction ;ISC_ASLA .equ 49
.db 2 \.dl a6502_inst_lsr, a6502_getInstruction ;ISC_LSRA .equ 50
.db 2 \.dl a6502_inst_rol, a6502_getInstruction ;ISC_ROLA .equ 51
.db 2 \.dl a6502_inst_ror, a6502_getInstruction ;ISC_RORA .equ 52
.db 2 \.dl a6502_inst_clc, a6502_getInstruction ;ISC_CLC  .equ 53
.db 2 \.dl a6502_inst_cld, a6502_getInstruction ;ISC_CLD  .equ 54
.db 2 \.dl a6502_inst_cli, a6502_getInstruction ;ISC_CLI  .equ 55
.db 2 \.dl a6502_inst_clv, a6502_getInstruction ;ISC_CLV  .equ 56
.db 2 \.dl a6502_inst_sec, a6502_getInstruction ;ISC_SEC  .equ 57
.db 2 \.dl a6502_inst_sed, a6502_getInstruction ;ISC_SED  .equ 58
.db 2 \.dl a6502_inst_sei, a6502_getInstruction ;ISC_SEI  .equ 59
.db 2 \.dl a6502_inst_bcc, a6502_newfetch       ;ISC_BCC  .equ 60
.db 2 \.dl a6502_inst_bcs, a6502_newfetch       ;ISC_BCS  .equ 61
.db 2 \.dl a6502_inst_beq, a6502_newfetch       ;ISC_BEQ  .equ 62
.db 2 \.dl a6502_inst_bmi, a6502_newfetch       ;ISC_BMI  .equ 63
.db 2 \.dl a6502_inst_bne, a6502_newfetch       ;ISC_BNE  .equ 64
.db 2 \.dl a6502_inst_bpl, a6502_newfetch       ;ISC_BPL  .equ 65
.db 2 \.dl a6502_inst_bvc, a6502_newfetch       ;ISC_BVC  .equ 66
.db 2 \.dl a6502_inst_bvs, a6502_newfetch       ;ISC_BVS  .equ 67
.db 2 \.dl a6502_inst_brk, a6502_reload_then_getInstruction     ;ISC_BRK  .equ 68
.db 2 \.dl a6502_inst_rti, a6502_reload_then_getInstruction     ;ISC_RTI  .equ 69
.db 2 \.dl a6502_inst_rts, a6502_reload_then_getInstruction     ;ISC_RTS  .equ 70
.db 1 \.dl a6502_getInstruction                                 ;ISC_NOP  .equ 71
.db 1 \.dl a6502_getInstruction                                 ;ISC_NOPI .equ 72
.db 2 \.dl a6502_inst_jsr, a6502_reload_then_getInstruction     ;ISC_JSR  .equ 73
.db 2 \.dl a6502_inst_jmp_abs, a6502_reload_then_getInstruction ;ISC_JMPA .equ 74
.db 2 \.dl a6502_inst_jmp_ind, a6502_reload_then_getInstruction ;ISC_JMPI .equ 75
.db 2 \.dl a6502_jamx, a6502_reload_then_getInstruction         ;ISC_JAM  .equ 76
.db 0

a6502_special_moded_func_table:
.dl a6502_inst_sre_bc,a6502_inst_sre_hl_seg1,a6502_inst_sre_hl_seg2 ;ISC_SRE .equ 77
.dl a6502_inst_slo_bc,a6502_inst_slo_hl_seg1,a6502_inst_slo_hl_seg2 ;ISC_SLO .equ 78
.dl a6502_inst_rra_bc,a6502_inst_rra_hl_seg1,a6502_inst_rra_hl_seg2 ;ISC_RRA .equ 79
.dl a6502_inst_rla_bc,a6502_inst_rla_hl_seg1,a6502_inst_rla_hl_seg2 ;ISC_RLA .equ 80
.dl a6502_inst_isc_bc,a6502_inst_isc_hl_seg1,a6502_inst_isc_hl_seg2 ;ISC_ISC .equ 81
.dl a6502_inst_dcp_bc,a6502_inst_dcp_hl_seg1,a6502_inst_dcp_hl_seg2 ;ISC_DCP .equ 82



a6502_adrtype_table:
.dl 0                        ;ADRMODE_IMM     .equ 0
.dl a6502_adrmode_read_zp    ;ADRMODE_ZP      .equ 1
.dl a6502_adrmode_read_zpx   ;ADRMODE_ZPX     .equ 2
.dl a6502_adrmode_read_zpy   ;ADRMODE_ZPY     .equ 3
.dl a6502_adrmode_read_abs   ;ADRMODE_ABS     .equ 4
.dl a6502_adrmode_read_absx  ;ADRMODE_ABSX    .equ 5
.dl a6502_adrmode_read_absy  ;ADRMODE_ABSY    .equ 6
.dl 0                        ;ADRMODE_IND     .equ 7
.dl a6502_adrmode_read_indx  ;ADRMODE_INDX    .equ 8
.dl a6502_adrmode_read_indy  ;ADRMODE_INDY    .equ 9
.dl a6502_adrmode_write_absx ;ADRMODE_ABSXF   .equ 10
.dl a6502_adrmode_write_absy ;ADRMODE_ABSYF   .equ 11
.dl a6502_adrmode_write_indy ;ADRMODE_INDYF   .equ 12
.dl 0                        ;ADRMODE_SPEC    .equ 13 










.echo "Core 2 module size: ",$-a6502_module_start
